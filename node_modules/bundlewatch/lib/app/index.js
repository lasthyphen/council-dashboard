'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.STATUSES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _getLocalFileDetails = require('./getLocalFileDetails');

var _getLocalFileDetails2 = _interopRequireDefault(_getLocalFileDetails);

var _BundleWatchService = require('./reporting/BundleWatchService');

var _BundleWatchService2 = _interopRequireDefault(_BundleWatchService);

var _GitHubService = require('./reporting/GitHubService');

var _GitHubService2 = _interopRequireDefault(_GitHubService);

var _analyze = require('./analyze');

var _analyze2 = _interopRequireDefault(_analyze);

var _analyzeFiles = require('./analyze/analyzeFiles');

var _getConfig = require('./config/getConfig');

var _getConfig2 = _interopRequireDefault(_getConfig);

var _createURL = require('./resultsPage/createURL');

var _createURL2 = _interopRequireDefault(_createURL);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const main = (() => {
    var _ref = _asyncToGenerator(function* ({
        files,
        bundlewatchServiceHost,
        ci,
        defaultCompression
    }) {
        const currentBranchFileDetails = (0, _getLocalFileDetails2.default)({
            files,
            defaultCompression: defaultCompression
        });

        const bundlewatchService = new _BundleWatchService2.default({
            repoOwner: ci.repoOwner,
            repoName: ci.repoName,
            repoCurrentBranch: ci.repoCurrentBranch,
            repoBranchBase: ci.repoBranchBase,
            commitSha: ci.commitSha,
            bundlewatchServiceHost,
            githubAccessToken: ci.githubAccessToken
        });

        const baseBranchFileDetails = yield bundlewatchService.getFileDetailsForBaseBranch();
        yield bundlewatchService.saveFileDetailsForCurrentBranch({
            fileDetailsByPath: currentBranchFileDetails,
            trackBranches: ci.trackBranches
        });

        const results = (0, _analyze2.default)({
            currentBranchFileDetails,
            baseBranchFileDetails,
            baseBranchName: ci.repoBranchBase
        });

        const url = yield (0, _createURL2.default)({
            results,
            bundlewatchServiceHost,
            repoOwner: ci.repoOwner,
            repoName: ci.repoName,
            repoCurrentBranch: ci.repoCurrentBranch,
            repoBranchBase: ci.repoBranchBase,
            commitSha: ci.commitSha
        });

        return _extends({}, results, {
            url
        });
    });

    return function main(_x) {
        return _ref.apply(this, arguments);
    };
})();

const bundlewatchApi = (() => {
    var _ref2 = _asyncToGenerator(function* (customConfig) {
        const config = (0, _getConfig2.default)(customConfig);
        const githubService = new _GitHubService2.default({
            repoOwner: config.ci.repoOwner,
            repoName: config.ci.repoName,
            commitSha: config.ci.commitSha,
            githubAccessToken: config.ci.githubAccessToken
        });
        yield githubService.start({ message: 'Checking bundlewatch...' });

        try {
            const results = yield main(config);
            if (results.status === _analyzeFiles.STATUSES.FAIL) {
                yield githubService.fail({
                    message: results.summary,
                    url: results.url
                });

                yield Promise.all(results.fullResults.map(function (result) {
                    if (result.status === _analyzeFiles.STATUSES.FAIL) {
                        return githubService.fail({
                            message: result.message,
                            filePath: result.filePath
                        });
                    }
                    return Promise.resolve();
                }));
            } else {
                // TODO: add warn
                yield githubService.pass({
                    message: results.summary,
                    url: results.url
                });
            }
            return results;
        } catch (e) {
            yield githubService.error({
                message: `Unable to analyze, check logs. ${e ? e.messsage : ''}`
            });
            throw e;
        }
    });

    return function bundlewatchApi(_x2) {
        return _ref2.apply(this, arguments);
    };
})();

exports.default = bundlewatchApi;
exports.STATUSES = _analyzeFiles.STATUSES;