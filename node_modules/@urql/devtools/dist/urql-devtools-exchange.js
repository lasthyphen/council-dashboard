"use strict";

var wonka = require("wonka");

var React = require("react");

function _extends() {
  return (_extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

var CurrentOwner = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;

var isComponentFiber = function(fiber) {
  return fiber && (0 === fiber.tag || 1 === fiber.tag || 2 === fiber.tag);
};

var getDisplayName = function() {
  var source = "Component";
  var owner = CurrentOwner.current;
  if (null !== owner && isComponentFiber(owner)) {
    var Component = owner.type;
    if (function(Component) {
      return "Query" === Component.name || "Mutation" === Component.name || "Subscription" === Component.name;
    }(Component) && isComponentFiber(owner._debugOwner)) {
      Component = owner._debugOwner.type;
    }
    if ("function" == typeof Component) {
      source = Component.displayName || Component.name || source;
    }
  }
  return source;
};

var nodejsCustomInspectSymbol = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : void 0;

function _typeof(obj) {
  if ("function" == typeof Symbol && "symbol" == typeof Symbol.iterator) {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}

var MAX_ARRAY_LENGTH = 10;

var MAX_RECURSIVE_DEPTH = 2;

function formatValue(value, seenValues) {
  switch (_typeof(value)) {
   case "string":
    return JSON.stringify(value);

   case "function":
    return value.name ? "[function ".concat(value.name, "]") : "[function]";

   case "object":
    if (null === value) {
      return "null";
    }
    return function formatObjectValue(value, previouslySeenValues) {
      if (-1 !== previouslySeenValues.indexOf(value)) {
        return "[Circular]";
      }
      var seenValues = [].concat(previouslySeenValues, [ value ]);
      var customInspectFn = function getCustomFn(object) {
        var customInspectFn = object[String(nodejsCustomInspectSymbol)];
        if ("function" == typeof customInspectFn) {
          return customInspectFn;
        }
        if ("function" == typeof object.inspect) {
          return object.inspect;
        }
      }(value);
      if (void 0 !== customInspectFn) {
        var customValue = customInspectFn.call(value);
        if (customValue !== value) {
          return "string" == typeof customValue ? customValue : formatValue(customValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return function formatArray(array, seenValues) {
          if (0 === array.length) {
            return "[]";
          }
          if (seenValues.length > MAX_RECURSIVE_DEPTH) {
            return "[Array]";
          }
          var len = Math.min(MAX_ARRAY_LENGTH, array.length);
          var remaining = array.length - len;
          var items = [];
          for (var i = 0; i < len; ++i) {
            items.push(formatValue(array[i], seenValues));
          }
          if (1 === remaining) {
            items.push("... 1 more item");
          } else if (remaining > 1) {
            items.push("... ".concat(remaining, " more items"));
          }
          return "[" + items.join(", ") + "]";
        }(value, seenValues);
      }
      return function formatObject(object, seenValues) {
        var keys = Object.keys(object);
        if (0 === keys.length) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH) {
          return "[" + function getObjectTag(object) {
            var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
            if ("Object" === tag && "function" == typeof object.constructor) {
              var name = object.constructor.name;
              if ("string" == typeof name && "" !== name) {
                return name;
              }
            }
            return tag;
          }(object) + "]";
        }
        return "{ " + keys.map((function(key) {
          return key + ": " + formatValue(object[key], seenValues);
        })).join(", ") + " }";
      }(value, seenValues);
    }(value, seenValues);

   default:
    return String(value);
  }
}

function devAssert(condition, message) {
  if (!Boolean(condition)) {
    throw new Error(message);
  }
}

function defineToJSON(classObject) {
  var fn = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : classObject.prototype.toString;
  classObject.prototype.toJSON = fn;
  classObject.prototype.inspect = fn;
  if (nodejsCustomInspectSymbol) {
    classObject.prototype[nodejsCustomInspectSymbol] = fn;
  }
}

function _typeof$1(obj) {
  if ("function" == typeof Symbol && "symbol" == typeof Symbol.iterator) {
    _typeof$1 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function _typeof(obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof$1(obj);
}

function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;
  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }
  return {
    line: line,
    column: column
  };
}

function printLocation(location) {
  return printSourceLocation(location.source, getLocation(location.source, location.start));
}

function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineNum = sourceLocation.line + (source.locationOffset.line - 1);
  var columnNum = sourceLocation.column + (1 === sourceLocation.line ? firstLineColumnOffset : 0);
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var sublineIndex = Math.floor(columnNum / 80);
    var sublineColumnNum = columnNum % 80;
    var sublines = [];
    for (var i = 0; i < locationLine.length; i += 80) {
      sublines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([ [ "".concat(lineNum), sublines[0] ] ].concat(sublines.slice(1, sublineIndex + 1).map((function(subline) {
      return [ "", subline ];
    })), [ [ " ", whitespace(sublineColumnNum - 1) + "^" ], [ "", sublines[sublineIndex + 1] ] ]));
  }
  return locationStr + printPrefixedLines([ [ "".concat(lineNum - 1), lines[lineIndex - 1] ], [ "".concat(lineNum), locationLine ], [ "", whitespace(columnNum - 1) + "^" ], [ "".concat(lineNum + 1), lines[lineIndex + 1] ] ]);
}

function printPrefixedLines(lines) {
  var existingLines = lines.filter((function(_ref) {
    return void 0 !== _ref[1];
  }));
  var padLen = Math.max.apply(Math, existingLines.map((function(_ref2) {
    return _ref2[0].length;
  })));
  return existingLines.map((function(_ref3) {
    var line = _ref3[1];
    return function lpad(len, str) {
      return whitespace(len - str.length) + str;
    }(padLen, _ref3[0]) + (line ? " | " + line : " |");
  })).join("\n");
}

function whitespace(len) {
  return Array(len + 1).join(" ");
}

function GraphQLError(message, nodes, source, positions, path, originalError, extensions) {
  var _nodes = Array.isArray(nodes) ? 0 !== nodes.length ? nodes : void 0 : nodes ? [ nodes ] : void 0;
  var _source = source;
  if (!_source && _nodes) {
    var node = _nodes[0];
    _source = node && node.loc && node.loc.source;
  }
  var _positions = positions;
  if (!_positions && _nodes) {
    _positions = _nodes.reduce((function(list, node) {
      if (node.loc) {
        list.push(node.loc.start);
      }
      return list;
    }), []);
  }
  if (_positions && 0 === _positions.length) {
    _positions = void 0;
  }
  var _locations;
  if (positions && source) {
    _locations = positions.map((function(pos) {
      return getLocation(source, pos);
    }));
  } else if (_nodes) {
    _locations = _nodes.reduce((function(list, node) {
      if (node.loc) {
        list.push(getLocation(node.loc.source, node.loc.start));
      }
      return list;
    }), []);
  }
  var _extensions = extensions;
  if (null == _extensions && null != originalError) {
    var originalExtensions = originalError.extensions;
    if (function isObjectLike(value) {
      return "object" == _typeof$1(value) && null !== value;
    }(originalExtensions)) {
      _extensions = originalExtensions;
    }
  }
  Object.defineProperties(this, {
    message: {
      value: message,
      enumerable: !0,
      writable: !0
    },
    locations: {
      value: _locations || void 0,
      enumerable: Boolean(_locations)
    },
    path: {
      value: path || void 0,
      enumerable: Boolean(path)
    },
    nodes: {
      value: _nodes || void 0
    },
    source: {
      value: _source || void 0
    },
    positions: {
      value: _positions || void 0
    },
    originalError: {
      value: originalError
    },
    extensions: {
      value: _extensions || void 0,
      enumerable: Boolean(_extensions)
    }
  });
  if (originalError && originalError.stack) {
    Object.defineProperty(this, "stack", {
      value: originalError.stack,
      writable: !0,
      configurable: !0
    });
  } else if (Error.captureStackTrace) {
    Error.captureStackTrace(this, GraphQLError);
  } else {
    Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
}

GraphQLError.prototype = Object.create(Error.prototype, {
  constructor: {
    value: GraphQLError
  },
  name: {
    value: "GraphQLError"
  },
  toString: {
    value: function toString() {
      return function printError(error) {
        var output = error.message;
        if (error.nodes) {
          for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {
            var node = _error$nodes2[_i2];
            if (node.loc) {
              output += "\n\n" + printLocation(node.loc);
            }
          }
        } else if (error.source && error.locations) {
          for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {
            output += "\n\n" + printSourceLocation(error.source, _error$locations2[_i4]);
          }
        }
        return output;
      }(this);
    }
  }
});

function syntaxError(source, position, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [ position ]);
}

var Kind = Object.freeze({
  NAME: "Name",
  DOCUMENT: "Document",
  OPERATION_DEFINITION: "OperationDefinition",
  VARIABLE_DEFINITION: "VariableDefinition",
  SELECTION_SET: "SelectionSet",
  FIELD: "Field",
  ARGUMENT: "Argument",
  FRAGMENT_SPREAD: "FragmentSpread",
  INLINE_FRAGMENT: "InlineFragment",
  FRAGMENT_DEFINITION: "FragmentDefinition",
  VARIABLE: "Variable",
  INT: "IntValue",
  FLOAT: "FloatValue",
  STRING: "StringValue",
  BOOLEAN: "BooleanValue",
  NULL: "NullValue",
  ENUM: "EnumValue",
  LIST: "ListValue",
  OBJECT: "ObjectValue",
  OBJECT_FIELD: "ObjectField",
  DIRECTIVE: "Directive",
  NAMED_TYPE: "NamedType",
  LIST_TYPE: "ListType",
  NON_NULL_TYPE: "NonNullType",
  SCHEMA_DEFINITION: "SchemaDefinition",
  OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
  SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
  OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
  FIELD_DEFINITION: "FieldDefinition",
  INPUT_VALUE_DEFINITION: "InputValueDefinition",
  INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
  UNION_TYPE_DEFINITION: "UnionTypeDefinition",
  ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
  ENUM_VALUE_DEFINITION: "EnumValueDefinition",
  INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
  DIRECTIVE_DEFINITION: "DirectiveDefinition",
  SCHEMA_EXTENSION: "SchemaExtension",
  SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
  OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
  INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
  UNION_TYPE_EXTENSION: "UnionTypeExtension",
  ENUM_TYPE_EXTENSION: "EnumTypeExtension",
  INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
});

var Source = function Source(body, name, locationOffset) {
  this.body = body;
  this.name = name || "GraphQL request";
  this.locationOffset = locationOffset || {
    line: 1,
    column: 1
  };
  this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive");
  this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive");
};

!function defineToStringTag(classObject) {
  if ("function" == typeof Symbol && Symbol.toStringTag) {
    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {
      get: function get() {
        return this.constructor.name;
      }
    });
  }
}(Source);

function dedentBlockStringValue(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = function getBlockStringIndentation(lines) {
    var commonIndent = null;
    for (var i = 1; i < lines.length; i++) {
      var line = lines[i];
      var indent = leadingWhitespace(line);
      if (indent === line.length) {
        continue;
      }
      if (null === commonIndent || indent < commonIndent) {
        if (0 === (commonIndent = indent)) {
          break;
        }
      }
    }
    return null === commonIndent ? 0 : commonIndent;
  }(lines);
  if (0 !== commonIndent) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}

function leadingWhitespace(str) {
  var i = 0;
  while (i < str.length && (" " === str[i] || "\t" === str[i])) {
    i++;
  }
  return i;
}

function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}

var TokenKind = Object.freeze({
  SOF: "<SOF>",
  EOF: "<EOF>",
  BANG: "!",
  DOLLAR: "$",
  AMP: "&",
  PAREN_L: "(",
  PAREN_R: ")",
  SPREAD: "...",
  COLON: ":",
  EQUALS: "=",
  AT: "@",
  BRACKET_L: "[",
  BRACKET_R: "]",
  BRACE_L: "{",
  PIPE: "|",
  BRACE_R: "}",
  NAME: "Name",
  INT: "Int",
  FLOAT: "Float",
  STRING: "String",
  BLOCK_STRING: "BlockString",
  COMMENT: "Comment"
});

function advanceLexer() {
  this.lastToken = this.token;
  return this.token = this.lookahead();
}

function lookahead() {
  var token = this.token;
  if (token.kind !== TokenKind.EOF) {
    do {
      token = token.next || (token.next = readToken(this, token));
    } while (token.kind === TokenKind.COMMENT);
  }
  return token;
}

function Tok(kind, start, end, line, column, prev, value) {
  this.kind = kind;
  this.start = start;
  this.end = end;
  this.line = line;
  this.column = column;
  this.value = value;
  this.prev = prev;
  this.next = null;
}

defineToJSON(Tok, (function() {
  return {
    kind: this.kind,
    value: this.value,
    line: this.line,
    column: this.column
  };
}));

function printCharCode(code) {
  return isNaN(code) ? TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
}

function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = function positionAfterWhitespace(body, startPosition, lexer) {
    var bodyLength = body.length;
    var position = startPosition;
    while (position < bodyLength) {
      var code = body.charCodeAt(position);
      if (9 === code || 32 === code || 44 === code || 65279 === code) {
        ++position;
      } else if (10 === code) {
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
      } else if (13 === code) {
        if (10 === body.charCodeAt(position + 1)) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
      } else {
        break;
      }
    }
    return position;
  }(body, prev.end, lexer);
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  if (pos >= bodyLength) {
    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
  }
  var code = body.charCodeAt(pos);
  switch (code) {
   case 33:
    return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);

   case 35:
    return function readComment(source, start, line, col, prev) {
      var body = source.body;
      var code;
      var position = start;
      do {
        code = body.charCodeAt(++position);
      } while (!isNaN(code) && (code > 31 || 9 === code));
      return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
    }(source, pos, line, col, prev);

   case 36:
    return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);

   case 38:
    return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);

   case 40:
    return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);

   case 41:
    return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);

   case 46:
    if (46 === body.charCodeAt(pos + 1) && 46 === body.charCodeAt(pos + 2)) {
      return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);
    }
    break;

   case 58:
    return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);

   case 61:
    return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);

   case 64:
    return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);

   case 91:
    return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);

   case 93:
    return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);

   case 123:
    return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);

   case 124:
    return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);

   case 125:
    return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);

   case 65:
   case 66:
   case 67:
   case 68:
   case 69:
   case 70:
   case 71:
   case 72:
   case 73:
   case 74:
   case 75:
   case 76:
   case 77:
   case 78:
   case 79:
   case 80:
   case 81:
   case 82:
   case 83:
   case 84:
   case 85:
   case 86:
   case 87:
   case 88:
   case 89:
   case 90:
   case 95:
   case 97:
   case 98:
   case 99:
   case 100:
   case 101:
   case 102:
   case 103:
   case 104:
   case 105:
   case 106:
   case 107:
   case 108:
   case 109:
   case 110:
   case 111:
   case 112:
   case 113:
   case 114:
   case 115:
   case 116:
   case 117:
   case 118:
   case 119:
   case 120:
   case 121:
   case 122:
    return function readName(source, start, line, col, prev) {
      var body = source.body;
      var bodyLength = body.length;
      var position = start + 1;
      var code = 0;
      while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (95 === code || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
        ++position;
      }
      return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
    }(source, pos, line, col, prev);

   case 45:
   case 48:
   case 49:
   case 50:
   case 51:
   case 52:
   case 53:
   case 54:
   case 55:
   case 56:
   case 57:
    return function readNumber(source, start, firstCode, line, col, prev) {
      var body = source.body;
      var code = firstCode;
      var position = start;
      var isFloat = !1;
      if (45 === code) {
        code = body.charCodeAt(++position);
      }
      if (48 === code) {
        if ((code = body.charCodeAt(++position)) >= 48 && code <= 57) {
          throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
        }
      } else {
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (46 === code) {
        isFloat = !0;
        code = body.charCodeAt(++position);
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (69 === code || 101 === code) {
        isFloat = !0;
        if (43 === (code = body.charCodeAt(++position)) || 45 === code) {
          code = body.charCodeAt(++position);
        }
        position = readDigits(source, position, code);
        code = body.charCodeAt(position);
      }
      if (46 === code || 69 === code || 101 === code) {
        throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
      }
      return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
    }(source, pos, code, line, col, prev);

   case 34:
    if (34 === body.charCodeAt(pos + 1) && 34 === body.charCodeAt(pos + 2)) {
      return function readBlockString(source, start, line, col, prev, lexer) {
        var body = source.body;
        var position = start + 3;
        var chunkStart = position;
        var code = 0;
        var rawValue = "";
        while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
          if (34 === code && 34 === body.charCodeAt(position + 1) && 34 === body.charCodeAt(position + 2)) {
            rawValue += body.slice(chunkStart, position);
            return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));
          }
          if (code < 32 && 9 !== code && 10 !== code && 13 !== code) {
            throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
          }
          if (10 === code) {
            ++position;
            ++lexer.line;
            lexer.lineStart = position;
          } else if (13 === code) {
            if (10 === body.charCodeAt(position + 1)) {
              position += 2;
            } else {
              ++position;
            }
            ++lexer.line;
            lexer.lineStart = position;
          } else if (92 === code && 34 === body.charCodeAt(position + 1) && 34 === body.charCodeAt(position + 2) && 34 === body.charCodeAt(position + 3)) {
            rawValue += body.slice(chunkStart, position) + '"""';
            chunkStart = position += 4;
          } else {
            ++position;
          }
        }
        throw syntaxError(source, position, "Unterminated string.");
      }(source, pos, line, col, prev, lexer);
    }
    return function readString(source, start, line, col, prev) {
      var body = source.body;
      var position = start + 1;
      var chunkStart = position;
      var code = 0;
      var value = "";
      while (position < body.length && !isNaN(code = body.charCodeAt(position)) && 10 !== code && 13 !== code) {
        if (34 === code) {
          value += body.slice(chunkStart, position);
          return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);
        }
        if (code < 32 && 9 !== code) {
          throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
        }
        ++position;
        if (92 === code) {
          value += body.slice(chunkStart, position - 1);
          switch (code = body.charCodeAt(position)) {
           case 34:
            value += '"';
            break;

           case 47:
            value += "/";
            break;

           case 92:
            value += "\\";
            break;

           case 98:
            value += "\b";
            break;

           case 102:
            value += "\f";
            break;

           case 110:
            value += "\n";
            break;

           case 114:
            value += "\r";
            break;

           case 116:
            value += "\t";
            break;

           case 117:
            var charCode = (a = body.charCodeAt(position + 1), b = body.charCodeAt(position + 2), 
            c = body.charCodeAt(position + 3), d = body.charCodeAt(position + 4), char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d));
            if (charCode < 0) {
              var invalidSequence = body.slice(position + 1, position + 5);
              throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
            }
            value += String.fromCharCode(charCode);
            position += 4;
            break;

           default:
            throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
          }
          ++position;
          chunkStart = position;
        }
      }
      var a, b, c, d;
      throw syntaxError(source, position, "Unterminated string.");
    }(source, pos, line, col, prev);
  }
  throw syntaxError(source, pos, function unexpectedCharacterMessage(code) {
    if (code < 32 && 9 !== code && 10 !== code && 13 !== code) {
      return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
    }
    if (39 === code) {
      return "Unexpected single quote character ('), did you mean to use a double quote (\")?";
    }
    return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
  }(code));
}

function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;
  if (code >= 48 && code <= 57) {
    do {
      code = body.charCodeAt(++position);
    } while (code >= 48 && code <= 57);
    return position;
  }
  throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}

function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
}

var DirectiveLocation = Object.freeze({
  QUERY: "QUERY",
  MUTATION: "MUTATION",
  SUBSCRIPTION: "SUBSCRIPTION",
  FIELD: "FIELD",
  FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
  FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
  INLINE_FRAGMENT: "INLINE_FRAGMENT",
  VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
  SCHEMA: "SCHEMA",
  SCALAR: "SCALAR",
  OBJECT: "OBJECT",
  FIELD_DEFINITION: "FIELD_DEFINITION",
  ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
  INTERFACE: "INTERFACE",
  UNION: "UNION",
  ENUM: "ENUM",
  ENUM_VALUE: "ENUM_VALUE",
  INPUT_OBJECT: "INPUT_OBJECT",
  INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
});

var Parser = function() {
  function Parser(source, options) {
    var sourceObj = "string" == typeof source ? new Source(source) : source;
    sourceObj instanceof Source || devAssert(0, "Must provide Source. Received: ".concat(function inspect(value) {
      return formatValue(value, []);
    }(sourceObj)));
    this._lexer = function createLexer(source, options) {
      var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);
      return {
        source: source,
        options: options,
        lastToken: startOfFileToken,
        token: startOfFileToken,
        line: 1,
        lineStart: 0,
        advance: advanceLexer,
        lookahead: lookahead
      };
    }(sourceObj);
    this._options = options || {};
  }
  var _proto = Parser.prototype;
  _proto.parseName = function parseName() {
    var token = this.expectToken(TokenKind.NAME);
    return {
      kind: Kind.NAME,
      value: token.value,
      loc: this.loc(token)
    };
  };
  _proto.parseDocument = function parseDocument() {
    var start = this._lexer.token;
    return {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
      loc: this.loc(start)
    };
  };
  _proto.parseDefinition = function parseDefinition() {
    if (this.peek(TokenKind.NAME)) {
      switch (this._lexer.token.value) {
       case "query":
       case "mutation":
       case "subscription":
        return this.parseOperationDefinition();

       case "fragment":
        return this.parseFragmentDefinition();

       case "schema":
       case "scalar":
       case "type":
       case "interface":
       case "union":
       case "enum":
       case "input":
       case "directive":
        return this.parseTypeSystemDefinition();

       case "extend":
        return this.parseTypeSystemExtension();
      }
    } else if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    } else if (this.peekDescription()) {
      return this.parseTypeSystemDefinition();
    }
    throw this.unexpected();
  };
  _proto.parseOperationDefinition = function parseOperationDefinition() {
    var start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return {
        kind: Kind.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    var operation = this.parseOperationType();
    var name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return {
      kind: Kind.OPERATION_DEFINITION,
      operation: operation,
      name: name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseOperationType = function parseOperationType() {
    var operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
     case "query":
      return "query";

     case "mutation":
      return "mutation";

     case "subscription":
      return "subscription";
    }
    throw this.unexpected(operationToken);
  };
  _proto.parseVariableDefinitions = function parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  };
  _proto.parseVariableDefinition = function parseVariableDefinition() {
    var start = this._lexer.token;
    return {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(!0) : void 0,
      directives: this.parseDirectives(!0),
      loc: this.loc(start)
    };
  };
  _proto.parseVariable = function parseVariable() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return {
      kind: Kind.VARIABLE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseSelectionSet = function parseSelectionSet() {
    var start = this._lexer.token;
    return {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseSelection = function parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  };
  _proto.parseField = function parseField() {
    var start = this._lexer.token;
    var nameOrAlias = this.parseName();
    var alias;
    var name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return {
      kind: Kind.FIELD,
      alias: alias,
      name: name,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
      loc: this.loc(start)
    };
  };
  _proto.parseArguments = function parseArguments(isConst) {
    return this.optionalMany(TokenKind.PAREN_L, isConst ? this.parseConstArgument : this.parseArgument, TokenKind.PAREN_R);
  };
  _proto.parseArgument = function parseArgument() {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.ARGUMENT,
      name: name,
      value: this.parseValueLiteral(!1),
      loc: this.loc(start)
    };
  };
  _proto.parseConstArgument = function parseConstArgument() {
    var start = this._lexer.token;
    return {
      kind: Kind.ARGUMENT,
      name: this.parseName(),
      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(!0)),
      loc: this.loc(start)
    };
  };
  _proto.parseFragment = function parseFragment() {
    var start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    var hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(!1),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentDefinition = function parseFragmentDefinition() {
    var start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.experimentalFragmentVariables) {
      return {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(start)
      };
    }
    return {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet(),
      loc: this.loc(start)
    };
  };
  _proto.parseFragmentName = function parseFragmentName() {
    if ("on" === this._lexer.token.value) {
      throw this.unexpected();
    }
    return this.parseName();
  };
  _proto.parseValueLiteral = function parseValueLiteral(isConst) {
    var token = this._lexer.token;
    switch (token.kind) {
     case TokenKind.BRACKET_L:
      return this.parseList(isConst);

     case TokenKind.BRACE_L:
      return this.parseObject(isConst);

     case TokenKind.INT:
      this._lexer.advance();
      return {
        kind: Kind.INT,
        value: token.value,
        loc: this.loc(token)
      };

     case TokenKind.FLOAT:
      this._lexer.advance();
      return {
        kind: Kind.FLOAT,
        value: token.value,
        loc: this.loc(token)
      };

     case TokenKind.STRING:
     case TokenKind.BLOCK_STRING:
      return this.parseStringLiteral();

     case TokenKind.NAME:
      if ("true" === token.value || "false" === token.value) {
        this._lexer.advance();
        return {
          kind: Kind.BOOLEAN,
          value: "true" === token.value,
          loc: this.loc(token)
        };
      } else if ("null" === token.value) {
        this._lexer.advance();
        return {
          kind: Kind.NULL,
          loc: this.loc(token)
        };
      }
      this._lexer.advance();
      return {
        kind: Kind.ENUM,
        value: token.value,
        loc: this.loc(token)
      };

     case TokenKind.DOLLAR:
      if (!isConst) {
        return this.parseVariable();
      }
    }
    throw this.unexpected();
  };
  _proto.parseStringLiteral = function parseStringLiteral() {
    var token = this._lexer.token;
    this._lexer.advance();
    return {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING,
      loc: this.loc(token)
    };
  };
  _proto.parseList = function parseList(isConst) {
    var _this = this;
    var start = this._lexer.token;
    return {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, (function item() {
        return _this.parseValueLiteral(isConst);
      }), TokenKind.BRACKET_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObject = function parseObject(isConst) {
    var _this2 = this;
    var start = this._lexer.token;
    return {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, (function item() {
        return _this2.parseObjectField(isConst);
      }), TokenKind.BRACE_R),
      loc: this.loc(start)
    };
  };
  _proto.parseObjectField = function parseObjectField(isConst) {
    var start = this._lexer.token;
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return {
      kind: Kind.OBJECT_FIELD,
      name: name,
      value: this.parseValueLiteral(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseDirectives = function parseDirectives(isConst) {
    var directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  };
  _proto.parseDirective = function parseDirective(isConst) {
    var start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeReference = function parseTypeReference() {
    var start = this._lexer.token;
    var type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      type = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = {
        kind: Kind.LIST_TYPE,
        type: type,
        loc: this.loc(start)
      };
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return {
        kind: Kind.NON_NULL_TYPE,
        type: type,
        loc: this.loc(start)
      };
    }
    return type;
  };
  _proto.parseNamedType = function parseNamedType() {
    var start = this._lexer.token;
    return {
      kind: Kind.NAMED_TYPE,
      name: this.parseName(),
      loc: this.loc(start)
    };
  };
  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
       case "schema":
        return this.parseSchemaDefinition();

       case "scalar":
        return this.parseScalarTypeDefinition();

       case "type":
        return this.parseObjectTypeDefinition();

       case "interface":
        return this.parseInterfaceTypeDefinition();

       case "union":
        return this.parseUnionTypeDefinition();

       case "enum":
        return this.parseEnumTypeDefinition();

       case "input":
        return this.parseInputObjectTypeDefinition();

       case "directive":
        return this.parseDirectiveDefinition();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.peekDescription = function peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  };
  _proto.parseDescription = function parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  };
  _proto.parseSchemaDefinition = function parseSchemaDefinition() {
    var start = this._lexer.token;
    this.expectKeyword("schema");
    var directives = this.parseDirectives(!0);
    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return {
      kind: Kind.SCHEMA_DEFINITION,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
    var start = this._lexer.token;
    var operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    var type = this.parseNamedType();
    return {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation: operation,
      type: type,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    return {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(!0);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  };
  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
    var types = [];
    if (this.expectOptionalKeyword("implements")) {
      this.expectOptionalToken(TokenKind.AMP);
      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(TokenKind.AMP) || this._options.allowLegacySDLImplementsInterfaces && this.peek(TokenKind.NAME));
    }
    return types;
  };
  _proto.parseFieldsDefinition = function parseFieldsDefinition() {
    if (this._options.allowLegacySDLEmptyFields && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
      this._lexer.advance();
      this._lexer.advance();
      return [];
    }
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  };
  _proto.parseFieldDefinition = function parseFieldDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var directives = this.parseDirectives(!0);
    return {
      kind: Kind.FIELD_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      type: type,
      directives: directives,
      loc: this.loc(start)
    };
  };
  _proto.parseArgumentDefs = function parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  };
  _proto.parseInputValueDef = function parseInputValueDef() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    this.expectToken(TokenKind.COLON);
    var type = this.parseTypeReference();
    var defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseValueLiteral(!0);
    }
    var directives = this.parseDirectives(!0);
    return {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description: description,
      name: name,
      type: type,
      defaultValue: defaultValue,
      directives: directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("interface");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var fields = this.parseFieldsDefinition();
    return {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var types = this.parseUnionMemberTypes();
    return {
      kind: Kind.UNION_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
    var types = [];
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      this.expectOptionalToken(TokenKind.PIPE);
      do {
        types.push(this.parseNamedType());
      } while (this.expectOptionalToken(TokenKind.PIPE));
    }
    return types;
  };
  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var values = this.parseEnumValuesDefinition();
    return {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  };
  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    return {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var fields = this.parseInputFieldsDefinition();
    return {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description: description,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  };
  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
    var keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
       case "schema":
        return this.parseSchemaExtension();

       case "scalar":
        return this.parseScalarTypeExtension();

       case "type":
        return this.parseObjectTypeExtension();

       case "interface":
        return this.parseInterfaceTypeExtension();

       case "union":
        return this.parseUnionTypeExtension();

       case "enum":
        return this.parseEnumTypeExtension();

       case "input":
        return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  };
  _proto.parseSchemaExtension = function parseSchemaExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    var directives = this.parseDirectives(!0);
    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (0 === directives.length && 0 === operationTypes.length) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCHEMA_EXTENSION,
      directives: directives,
      operationTypes: operationTypes,
      loc: this.loc(start)
    };
  };
  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    if (0 === directives.length) {
      throw this.unexpected();
    }
    return {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name: name,
      directives: directives,
      loc: this.loc(start)
    };
  };
  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    var name = this.parseName();
    var interfaces = this.parseImplementsInterfaces();
    var directives = this.parseDirectives(!0);
    var fields = this.parseFieldsDefinition();
    if (0 === interfaces.length && 0 === directives.length && 0 === fields.length) {
      throw this.unexpected();
    }
    return {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name: name,
      interfaces: interfaces,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  };
  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var fields = this.parseFieldsDefinition();
    if (0 === directives.length && 0 === fields.length) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  };
  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var types = this.parseUnionMemberTypes();
    if (0 === directives.length && 0 === types.length) {
      throw this.unexpected();
    }
    return {
      kind: Kind.UNION_TYPE_EXTENSION,
      name: name,
      directives: directives,
      types: types,
      loc: this.loc(start)
    };
  };
  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var values = this.parseEnumValuesDefinition();
    if (0 === directives.length && 0 === values.length) {
      throw this.unexpected();
    }
    return {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name: name,
      directives: directives,
      values: values,
      loc: this.loc(start)
    };
  };
  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
    var start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    var name = this.parseName();
    var directives = this.parseDirectives(!0);
    var fields = this.parseInputFieldsDefinition();
    if (0 === directives.length && 0 === fields.length) {
      throw this.unexpected();
    }
    return {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name,
      directives: directives,
      fields: fields,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
    var start = this._lexer.token;
    var description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    var name = this.parseName();
    var args = this.parseArgumentDefs();
    var repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    var locations = this.parseDirectiveLocations();
    return {
      kind: Kind.DIRECTIVE_DEFINITION,
      description: description,
      name: name,
      arguments: args,
      repeatable: repeatable,
      locations: locations,
      loc: this.loc(start)
    };
  };
  _proto.parseDirectiveLocations = function parseDirectiveLocations() {
    this.expectOptionalToken(TokenKind.PIPE);
    var locations = [];
    do {
      locations.push(this.parseDirectiveLocation());
    } while (this.expectOptionalToken(TokenKind.PIPE));
    return locations;
  };
  _proto.parseDirectiveLocation = function parseDirectiveLocation() {
    var start = this._lexer.token;
    var name = this.parseName();
    if (void 0 !== DirectiveLocation[name.value]) {
      return name;
    }
    throw this.unexpected(start);
  };
  _proto.loc = function loc(startToken) {
    if (!this._options.noLocation) {
      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);
    }
  };
  _proto.peek = function peek(kind) {
    return this._lexer.token.kind === kind;
  };
  _proto.expectToken = function expectToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, "Expected ".concat(kind, ", found ").concat(getTokenDesc(token)));
  };
  _proto.expectOptionalToken = function expectOptionalToken(kind) {
    var token = this._lexer.token;
    if (token.kind === kind) {
      this._lexer.advance();
      return token;
    }
    return;
  };
  _proto.expectKeyword = function expectKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
    } else {
      throw syntaxError(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token)));
    }
  };
  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
    var token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this._lexer.advance();
      return !0;
    }
    return !1;
  };
  _proto.unexpected = function unexpected(atToken) {
    var token = atToken || this._lexer.token;
    return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token)));
  };
  _proto.any = function any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  };
  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      var nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  };
  _proto.many = function many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    var nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  };
  return Parser;
}();

function Loc(startToken, endToken, source) {
  this.start = startToken.start;
  this.end = endToken.end;
  this.startToken = startToken;
  this.endToken = endToken;
  this.source = source;
}

defineToJSON(Loc, (function() {
  return {
    start: this.start,
    end: this.end
  };
}));

function getTokenDesc(token) {
  var value = token.value;
  return value ? "".concat(token.kind, ' "').concat(value, '"') : token.kind;
}

function _ref2(o) {
  return Boolean(o.context.meta && "Devtools" === o.context.meta.source);
}

var addOperationResponseContext = function(op) {
  return _extends(_extends({}, op), {
    operation: _extends(_extends({}, op.operation), {
      context: _extends(_extends({}, op.operation.context), {
        meta: _extends(_extends({}, op.operation.context.meta), {
          networkLatency: Date.now() - op.operation.context.meta.startTime
        })
      })
    })
  });
};

var addOperationContext = function(op) {
  return _extends(_extends({}, op), {
    context: _extends(_extends({}, op.context), {
      meta: _extends(_extends({}, op.context.meta), {
        source: op.context.meta && op.context.meta.source || getDisplayName(),
        startTime: Date.now()
      })
    })
  });
};

var handleOperation = function(op) {
  var event = JSON.parse(JSON.stringify(parseStreamData(op)));
  sendToContentScript(event);
};

var messageHandlers = {
  request: function(client) {
    return function(message) {
      var isMutation = /(^|\W)+mutation\W/.test(message.query);
      var op = client.createRequestOperation(isMutation ? "mutation" : "query", {
        key: (x = JSON.stringify(message.query), function(h, x) {
          h |= 0;
          for (var i = 0, l = 0 | x.length; i < l; i++) {
            h = (h << 5) + h + x.charCodeAt(i);
          }
          return h;
        }(5381, x) >>> 0),
        query: (source = message.query, new Parser(source, options).parseDocument())
      }, {
        meta: {
          source: "Devtools"
        }
      });
      var source, options;
      var x;
      handleOperation(op);
      wonka.pipe(client.executeRequestOperation(op), wonka.tap(handleOperation), wonka.take(1), wonka.toPromise);
    };
  }
};

var parseStreamData = function(op) {
  var timestamp = Date.now();
  if ("operationName" in op) {
    return {
      type: "operation",
      data: op,
      timestamp: timestamp
    };
  }
  if (void 0 !== op.error) {
    return {
      type: "error",
      data: op,
      timestamp: timestamp
    };
  }
  return {
    type: "response",
    data: op,
    timestamp: timestamp
  };
};

var sendToContentScript = function(detail) {
  return window.dispatchEvent(new CustomEvent("urql-devtools-exchange", {
    detail: detail
  }));
};

exports.DevtoolsExchangeIncomingEventType = "urql-devtools-exchange-in";

exports.DevtoolsExchangeOutgoingEventType = "urql-devtools-exchange";

exports.devtoolsExchange = function(ref) {
  var client = ref.client;
  var forward = ref.forward;
  if ("undefined" == typeof window) {
    return function _ref(ops$) {
      return wonka.pipe(ops$, forward);
    };
  }
  window.__urql__ = {
    url: client.url
  };
  window.addEventListener("urql-devtools-exchange-in", (function(event) {
    var e = event;
    var handler = messageHandlers[e.detail.type];
    handler && handler(client)(e.detail);
  }));
  sendToContentScript({
    type: "init"
  });
  return function(ops$) {
    var sharedOps$ = wonka.pipe(ops$, wonka.map(addOperationContext), wonka.share);
    var isDevtoolsOp = _ref2;
    var appOps$ = wonka.pipe(sharedOps$, wonka.filter((function(o) {
      return !isDevtoolsOp(o);
    })), wonka.tap(handleOperation), forward, wonka.map(addOperationResponseContext), wonka.tap(handleOperation));
    var devtoolsOps$ = wonka.pipe(sharedOps$, wonka.filter((function(o) {
      return isDevtoolsOp(o);
    })), forward);
    return wonka.merge([ appOps$, devtoolsOps$ ]);
  };
};
//# sourceMappingURL=urql-devtools-exchange.js.map
