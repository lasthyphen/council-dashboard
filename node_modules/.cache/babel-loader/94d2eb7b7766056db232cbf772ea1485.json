{"ast":null,"code":"import { share, onPush, takeWhile, toPromise, take } from \"wonka\";\nimport { GraphQLError, parse, print, visit, Kind } from \"graphql\";\n\nfunction _extends() {\n  return (_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }).apply(this, arguments);\n}\n\nvar rehydrateGraphQlError = function (error) {\n  if (\"string\" == typeof error) {\n    return new GraphQLError(error);\n  } else if (\"object\" == typeof error && error.message) {\n    return new GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});\n  } else {\n    return error;\n  }\n};\n\nfunction _toString() {\n  return this.message;\n}\n\nvar CombinedError = function (Error) {\n  function CombinedError(ref) {\n    var networkError = ref.networkError;\n    var response = ref.response;\n    var normalizedGraphQLErrors = (ref.graphQLErrors || []).map(rehydrateGraphQlError);\n\n    var message = function (networkErr, graphQlErrs) {\n      var error = \"\";\n\n      if (void 0 !== networkErr) {\n        return error = \"[Network] \" + networkErr.message;\n      }\n\n      if (void 0 !== graphQlErrs) {\n        graphQlErrs.forEach(function _ref(err) {\n          error += \"[GraphQL] \" + err.message + \"\\n\";\n        });\n      }\n\n      return error.trim();\n    }(networkError, normalizedGraphQLErrors);\n\n    Error.call(this, message);\n    this.name = \"CombinedError\";\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  if (Error) {\n    CombinedError.__proto__ = Error;\n  }\n\n  (CombinedError.prototype = Object.create(Error && Error.prototype)).constructor = CombinedError;\n  CombinedError.prototype.toString = _toString;\n  return CombinedError;\n}(Error);\n\nvar phash = function (h, x) {\n  h |= 0;\n\n  for (var i = 0, l = 0 | x.length; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\nvar seen = new Set();\n\nvar stringify = function (x) {\n  if (void 0 === x) {\n    return \"\";\n  } else if (\"number\" == typeof x) {\n    return isFinite(x) ? \"\" + x : \"null\";\n  } else if (\"object\" != typeof x) {\n    return JSON.stringify(x);\n  } else if (null === x) {\n    return \"null\";\n  } else if (x.toJSON) {\n    return x.toJSON();\n  }\n\n  var out = \"\";\n\n  if (Array.isArray(x)) {\n    out = \"[\";\n\n    for (var i = 0, l = x.length; i < l; i++) {\n      if (i > 0) {\n        out += \",\";\n      }\n\n      var value = stringify(x[i]);\n      out += value.length > 0 ? value : \"null\";\n    }\n\n    return out += \"]\";\n  } else if (seen.has(x)) {\n    throw new TypeError(\"Converting circular structure to JSON\");\n  }\n\n  var keys = Object.keys(x).sort();\n  seen.add(x);\n  out = \"{\";\n\n  for (var i$1 = 0, l$1 = keys.length; i$1 < l$1; i$1++) {\n    var key = keys[i$1];\n    var value$1 = stringify(x[key]);\n\n    if (0 !== value$1.length) {\n      if (out.length > 1) {\n        out += \",\";\n      }\n\n      out += stringify(key) + \":\" + value$1;\n    }\n  }\n\n  seen.delete(x);\n  return out += \"}\";\n};\n\nvar stringifyVariables = function (x) {\n  seen.clear();\n  return stringify(x);\n};\n\nvar hashQuery = function (q) {\n  return x = q.replace(/[\\s,]+/g, \" \").trim(), phash(5381, x) >>> 0;\n  var x;\n};\n\nvar docs = Object.create(null);\n\nvar createRequest = function (q, vars) {\n  var key;\n  var query;\n\n  if (\"string\" == typeof q) {\n    key = hashQuery(q);\n    query = void 0 !== docs[key] ? docs[key] : parse(q);\n  } else if (void 0 !== q.__key) {\n    key = q.__key;\n    query = q;\n  } else {\n    key = hashQuery(print(q));\n    query = void 0 !== docs[key] ? docs[key] : q;\n  }\n\n  docs[key] = query;\n  query.__key = key;\n  return {\n    key: vars ? phash(key, stringifyVariables(vars)) >>> 0 : key,\n    query: query,\n    variables: vars || {}\n  };\n};\n\nvar addMetadata = function (source, meta) {\n  return _extends(_extends({}, source), {\n    context: _extends(_extends({}, source.context), {\n      meta: _extends(_extends({}, source.context.meta), meta)\n    })\n  });\n};\n\nvar makeResult = function (operation, result, response) {\n  return {\n    operation: operation,\n    data: result.data,\n    error: Array.isArray(result.errors) ? new CombinedError({\n      graphQLErrors: result.errors,\n      response: response\n    }) : void 0,\n    extensions: \"object\" == typeof result.extensions && null !== result.extensions ? result.extensions : void 0\n  };\n};\n\nvar makeErrorResult = function (operation, error, response) {\n  return {\n    operation: operation,\n    data: void 0,\n    error: new CombinedError({\n      networkError: error,\n      response: response\n    }),\n    extensions: void 0\n  };\n};\n\nvar collectTypes = function (obj, types) {\n  if (void 0 === types) {\n    types = [];\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function _ref(inner) {\n      collectTypes(inner, types);\n    });\n  } else if (\"object\" == typeof obj && null !== obj) {\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var val = obj[key];\n\n        if (\"__typename\" === key && \"string\" == typeof val) {\n          types.push(val);\n        } else if (\"object\" == typeof val && null !== val) {\n          collectTypes(val, types);\n        }\n      }\n    }\n  }\n\n  return types;\n};\n\nfunction _ref2(v, i, a) {\n  return a.indexOf(v) === i;\n}\n\nvar collectTypesFromResponse = function (response) {\n  return collectTypes(response).filter(_ref2);\n};\n\nfunction _ref3(s) {\n  return \"Field\" === s.kind && \"__typename\" === s.name.value;\n}\n\nvar formatNode = function (n) {\n  if (void 0 === n.selectionSet) {\n    return !1;\n  }\n\n  if (n.selectionSet.selections.some(_ref3)) {\n    return n;\n  }\n\n  return _extends(_extends({}, n), {\n    selectionSet: _extends(_extends({}, n.selectionSet), {\n      selections: n.selectionSet.selections.concat([{\n        kind: Kind.FIELD,\n        name: {\n          kind: Kind.NAME,\n          value: \"__typename\"\n        }\n      }])\n    })\n  });\n};\n\nvar formatDocument = function (astNode) {\n  return visit(astNode, {\n    Field: formatNode,\n    InlineFragment: formatNode\n  });\n};\n\nvar toSuspenseSource = function (source) {\n  return function (sink) {\n    var shared = share(source);\n    var hasResult = !1;\n    var hasSuspended = !1;\n    onPush(function () {\n      return hasResult = !0;\n    })(takeWhile(function () {\n      return !hasSuspended;\n    })(shared))(sink);\n\n    if (!hasResult) {\n      hasSuspended = !0;\n      sink(0);\n      throw toPromise(take(1)(shared));\n    }\n  };\n};\n\nfunction withPromise(source$) {\n  source$.toPromise = function () {\n    return toPromise(take(1)(source$));\n  };\n\n  return source$;\n}\n\nexport { CombinedError as C, _extends as _, addMetadata as a, makeErrorResult as b, collectTypesFromResponse as c, createRequest as d, formatDocument as f, makeResult as m, stringifyVariables as s, toSuspenseSource as t, withPromise as w };","map":null,"metadata":{},"sourceType":"module"}