{"ast":null,"code":"import _objectSpread from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{useMemo}from'react';import{useWallet}from'../providers/Wallet';import{useCourtClock}from'../providers/CourtClock';import{useCourtConfig}from'../providers/CourtConfig';import{useFirstANJActivationQuery}from'./query-hooks';import{useDashboardState}from'../components/Dashboard/DashboardStateProvider';import{isMovementOf,convertMovement,isMovementEffective,getUpdatedLockedMovement,getLatestMovementByBalance,acceptedMovementsPerBalance,getAmountNotEffectiveByBalance}from'../utils/anj-movement-utils';import{getTermStartTime}from'../utils/court-utils';import{getDraftLockAmount}from'../utils/dispute-utils';import{ANJBalance,ANJMovement}from'../types/anj-types';export function useANJBalances(){var _useDashboardState=useDashboardState(),anjBalances=_useDashboardState.anjBalances,anjMovements=_useDashboardState.anjMovements;var _ref=anjBalances||{},walletBalance=_ref.walletBalance,activeBalance=_ref.activeBalance,lockedBalance=_ref.lockedBalance,inactiveBalance=_ref.inactiveBalance,deactivationBalance=_ref.deactivationBalance;var convertedMovements=useConvertedMovements(anjMovements);var convertedWalletBalance=useBalanceWithMovements(walletBalance,convertedMovements,ANJBalance.Wallet);var convertedInactiveBalance=useBalanceWithMovements(inactiveBalance,convertedMovements,ANJBalance.Inactive);var convertedActiveBalance=useBalanceWithMovements(activeBalance,convertedMovements,ANJBalance.Active);// Use ANJ Locked distribution\nvar lockedDistribution=useJurorLockedANJDistribution();var convertedLockedBalance=useMemo(function(){return{amount:lockedBalance,distribution:lockedDistribution};},[lockedBalance,lockedDistribution]);var convertedDeactivationBalance=useMemo(function(){return{amount:deactivationBalance};},[deactivationBalance]);// Since we pass the whole object through props to components, we should memoize it\nreturn useMemo(function(){if(!anjBalances){return null;}return{walletBalance:convertedWalletBalance,inactiveBalance:convertedInactiveBalance,activeBalance:convertedActiveBalance,lockedBalance:convertedLockedBalance,deactivationBalance:convertedDeactivationBalance};},[anjBalances,convertedActiveBalance,convertedDeactivationBalance,convertedInactiveBalance,convertedLockedBalance,convertedWalletBalance]);}// Asummes movements in descending order of creation\nfunction useConvertedMovements(movements){var _useCourtClock=useCourtClock(),currentTermId=_useCourtClock.currentTermId;var courtConfig=useCourtConfig();var effectiveStates=movements?movements.map(function(mov){return isMovementEffective(mov,currentTermId);}):[];var effectiveStatesKey=effectiveStates.join('');return useMemo(function(){if(!movements){return null;}// Since Activation, Deactivations and Slashing movements are effective on next term of creation\n// but only Deactivations don't update the balance immediately, we'll use another attr (isImmediate) to differentiate these cases\nreturn movements.map(function(mov,i){var isImmediate=ANJMovement[mov.type]!==ANJMovement.Deactivation;var updatesBalanceAt=mov.createdAt;if(!isImmediate&&mov.effectiveTermId&&effectiveStates[i]){var termStartTimeMs=getTermStartTime(mov.effectiveTermId,courtConfig);updatesBalanceAt=termStartTimeMs/1000;}return _objectSpread({},mov,{isEffective:effectiveStates[i],updatesBalanceAt:updatesBalanceAt,isImmediate:isImmediate});}).sort(function(mov1,mov2){// We are resorting movements by time they update the balance at\nif(mov1.updatesBalanceAt===mov2.updatesBalanceAt){return mov2.createdAt-mov1.createdAt;}return mov2.updatesBalanceAt-mov1.updatesBalanceAt;});},[effectiveStatesKey,movements]//eslint-disable-line\n);}/**\n * Calculates total amount, total not effective amount and the latest movement for `balanceType`\n * @dev In case the balance is active or inactive, we must also calculate all non effective movements to get the effective balance at current term\n *\n * @param {BigNum} balance Total balance amount\n * @param {Array} movements Latest 24h movements\n * @param {Symbol} balanceType Type of balance (Wallet, Inactive, Active)\n * @returns {Object} Converted balance\n */function useBalanceWithMovements(balance,movements,balanceType){var _useDashboardState2=useDashboardState(),anjBalances=_useDashboardState2.anjBalances;var _ref2=anjBalances||{},lockedBalance=_ref2.lockedBalance;var acceptedMovements=acceptedMovementsPerBalance.get(balanceType);var filteredMovements=useFilteredMovements(movements,acceptedMovements);return useMemo(function(){if(!balance){return null;}// Calculate total not effective (If balanceType === wallet returns 0)\nvar amountNotEffective=getAmountNotEffectiveByBalance(movements,balanceType);// Get latest movement\nvar latestMovement=getLatestMovementByBalance(filteredMovements,balanceType);// Update latest movement if necessary\nif(balanceType===ANJBalance.Active){if(lockedBalance===null||lockedBalance===void 0?void 0:lockedBalance.gt(0))latestMovement=getUpdatedLockedMovement(lockedBalance,latestMovement);}return{amount:balance,amountNotEffective:amountNotEffective,latestMovement:convertMovement(acceptedMovements,latestMovement)};},[acceptedMovements,balance,balanceType,filteredMovements,lockedBalance,movements]);}function useFilteredMovements(movements,acceptedMovements){return useMemo(function(){if(!movements){return null;}return movements.filter(function(movement){return isMovementOf(acceptedMovements,ANJMovement[movement.type]);});},[acceptedMovements,movements]);}/**\n * @param {Object} options query options\n * @param {Boolean} options.pause Tells whether to pause query or not\n * @return {Boolean} true if account's first ANJ activation happened on current term\n */export function useJurorFirstTimeANJActivation(options){var wallet=useWallet();var _useCourtClock2=useCourtClock(),currentTermId=_useCourtClock2.currentTermId;var firstANJActivation=useFirstANJActivationQuery(wallet.account,options);if(!firstANJActivation)return false;var firstANJActivationTerm=parseInt(firstANJActivation.effectiveTermId,10);// Activation is effective on next term from when the activation was performed\nreturn firstANJActivationTerm===currentTermId+1;}export function useJurorLockedANJDistribution(){var _useCourtConfig=useCourtConfig(),maxRegularAppealRounds=_useCourtConfig.maxRegularAppealRounds,minActiveBalance=_useCourtConfig.minActiveBalance,penaltyPct=_useCourtConfig.penaltyPct;var _useDashboardState3=useDashboardState(),jurorDrafts=_useDashboardState3.jurorDrafts,anjBalances=_useDashboardState3.anjBalances;var _ref3=anjBalances||{},lockedBalance=_ref3.lockedBalance;return useMemo(function(){if(!lockedBalance||lockedBalance.eq(0)||!jurorDrafts)return null;// For final rounds the ANJ at stake is pre-slashed for all jurors when they commit their vote\nreturn jurorDrafts.filter(function(jurorDraft){return!jurorDraft.round.settledPenalties&&jurorDraft.round.number<maxRegularAppealRounds;}).reduce(function(lockDistribution,_ref4){var weight=_ref4.weight,round=_ref4.round;var dispute=round.dispute;// Since the subgraph cannot provide a way to tell how much was locked per draft we calculate it ourselves\n// See https://github.com/aragon/court-subgraph/blob/7f0fec5c8953e9dbd67e5607fb6da03f69a60f40/src/DisputeManager.ts#L57\nvar lockedAmount=getDraftLockAmount(minActiveBalance,penaltyPct,weight);var index=lockDistribution.findIndex(function(locks){return locks.disputeId===dispute.id;});if(index>=0){var elem=lockDistribution[index];// Replace with updated amount and weight\nlockDistribution.splice(index,1,_objectSpread({},elem,{amount:elem.amount.add(lockedAmount),weight:elem.weight.add(weight)}));}else{lockDistribution.push({disputeId:dispute.id,amount:lockedAmount,weight:weight});}return lockDistribution;},[]);},[jurorDrafts,lockedBalance,maxRegularAppealRounds,minActiveBalance,penaltyPct]);}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useANJ.js"],"names":["useMemo","useWallet","useCourtClock","useCourtConfig","useFirstANJActivationQuery","useDashboardState","isMovementOf","convertMovement","isMovementEffective","getUpdatedLockedMovement","getLatestMovementByBalance","acceptedMovementsPerBalance","getAmountNotEffectiveByBalance","getTermStartTime","getDraftLockAmount","ANJBalance","ANJMovement","useANJBalances","anjBalances","anjMovements","walletBalance","activeBalance","lockedBalance","inactiveBalance","deactivationBalance","convertedMovements","useConvertedMovements","convertedWalletBalance","useBalanceWithMovements","Wallet","convertedInactiveBalance","Inactive","convertedActiveBalance","Active","lockedDistribution","useJurorLockedANJDistribution","convertedLockedBalance","amount","distribution","convertedDeactivationBalance","movements","currentTermId","courtConfig","effectiveStates","map","mov","effectiveStatesKey","join","i","isImmediate","type","Deactivation","updatesBalanceAt","createdAt","effectiveTermId","termStartTimeMs","isEffective","sort","mov1","mov2","balance","balanceType","acceptedMovements","get","filteredMovements","useFilteredMovements","amountNotEffective","latestMovement","gt","filter","movement","useJurorFirstTimeANJActivation","options","wallet","firstANJActivation","account","firstANJActivationTerm","parseInt","maxRegularAppealRounds","minActiveBalance","penaltyPct","jurorDrafts","eq","jurorDraft","round","settledPenalties","number","reduce","lockDistribution","weight","dispute","lockedAmount","index","findIndex","locks","disputeId","id","elem","splice","add","push"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\n\nimport { useWallet } from '../providers/Wallet'\nimport { useCourtClock } from '../providers/CourtClock'\nimport { useCourtConfig } from '../providers/CourtConfig'\nimport { useFirstANJActivationQuery } from './query-hooks'\nimport { useDashboardState } from '../components/Dashboard/DashboardStateProvider'\n\nimport {\n  isMovementOf,\n  convertMovement,\n  isMovementEffective,\n  getUpdatedLockedMovement,\n  getLatestMovementByBalance,\n  acceptedMovementsPerBalance,\n  getAmountNotEffectiveByBalance,\n} from '../utils/anj-movement-utils'\nimport { getTermStartTime } from '../utils/court-utils'\nimport { getDraftLockAmount } from '../utils/dispute-utils'\nimport { ANJBalance, ANJMovement } from '../types/anj-types'\n\nexport function useANJBalances() {\n  const { anjBalances, anjMovements } = useDashboardState()\n\n  const {\n    walletBalance,\n    activeBalance,\n    lockedBalance,\n    inactiveBalance,\n    deactivationBalance,\n  } = anjBalances || {}\n\n  const convertedMovements = useConvertedMovements(anjMovements)\n\n  const convertedWalletBalance = useBalanceWithMovements(\n    walletBalance,\n    convertedMovements,\n    ANJBalance.Wallet\n  )\n\n  const convertedInactiveBalance = useBalanceWithMovements(\n    inactiveBalance,\n    convertedMovements,\n    ANJBalance.Inactive\n  )\n\n  const convertedActiveBalance = useBalanceWithMovements(\n    activeBalance,\n    convertedMovements,\n    ANJBalance.Active\n  )\n\n  // Use ANJ Locked distribution\n  const lockedDistribution = useJurorLockedANJDistribution()\n  const convertedLockedBalance = useMemo(() => {\n    return { amount: lockedBalance, distribution: lockedDistribution }\n  }, [lockedBalance, lockedDistribution])\n\n  const convertedDeactivationBalance = useMemo(() => {\n    return { amount: deactivationBalance }\n  }, [deactivationBalance])\n\n  // Since we pass the whole object through props to components, we should memoize it\n  return useMemo(() => {\n    if (!anjBalances) {\n      return null\n    }\n\n    return {\n      walletBalance: convertedWalletBalance,\n      inactiveBalance: convertedInactiveBalance,\n      activeBalance: convertedActiveBalance,\n      lockedBalance: convertedLockedBalance,\n      deactivationBalance: convertedDeactivationBalance,\n    }\n  }, [\n    anjBalances,\n    convertedActiveBalance,\n    convertedDeactivationBalance,\n    convertedInactiveBalance,\n    convertedLockedBalance,\n    convertedWalletBalance,\n  ])\n}\n\n// Asummes movements in descending order of creation\nfunction useConvertedMovements(movements) {\n  const { currentTermId } = useCourtClock()\n  const courtConfig = useCourtConfig()\n\n  const effectiveStates = movements\n    ? movements.map(mov => isMovementEffective(mov, currentTermId))\n    : []\n  const effectiveStatesKey = effectiveStates.join('')\n\n  return useMemo(\n    () => {\n      if (!movements) {\n        return null\n      }\n\n      // Since Activation, Deactivations and Slashing movements are effective on next term of creation\n      // but only Deactivations don't update the balance immediately, we'll use another attr (isImmediate) to differentiate these cases\n      return movements\n        .map((mov, i) => {\n          const isImmediate = ANJMovement[mov.type] !== ANJMovement.Deactivation\n\n          let updatesBalanceAt = mov.createdAt\n          if (!isImmediate && mov.effectiveTermId && effectiveStates[i]) {\n            const termStartTimeMs = getTermStartTime(\n              mov.effectiveTermId,\n              courtConfig\n            )\n            updatesBalanceAt = termStartTimeMs / 1000\n          }\n\n          return {\n            ...mov,\n            isEffective: effectiveStates[i],\n            updatesBalanceAt,\n            isImmediate,\n          }\n        })\n        .sort((mov1, mov2) => {\n          // We are resorting movements by time they update the balance at\n          if (mov1.updatesBalanceAt === mov2.updatesBalanceAt) {\n            return mov2.createdAt - mov1.createdAt\n          }\n\n          return mov2.updatesBalanceAt - mov1.updatesBalanceAt\n        })\n    },\n    [effectiveStatesKey, movements] //eslint-disable-line\n  )\n}\n\n/**\n * Calculates total amount, total not effective amount and the latest movement for `balanceType`\n * @dev In case the balance is active or inactive, we must also calculate all non effective movements to get the effective balance at current term\n *\n * @param {BigNum} balance Total balance amount\n * @param {Array} movements Latest 24h movements\n * @param {Symbol} balanceType Type of balance (Wallet, Inactive, Active)\n * @returns {Object} Converted balance\n */\nfunction useBalanceWithMovements(balance, movements, balanceType) {\n  const { anjBalances } = useDashboardState()\n  const { lockedBalance } = anjBalances || {}\n\n  const acceptedMovements = acceptedMovementsPerBalance.get(balanceType)\n  const filteredMovements = useFilteredMovements(movements, acceptedMovements)\n\n  return useMemo(() => {\n    if (!balance) {\n      return null\n    }\n\n    // Calculate total not effective (If balanceType === wallet returns 0)\n    const amountNotEffective = getAmountNotEffectiveByBalance(\n      movements,\n      balanceType\n    )\n\n    // Get latest movement\n    let latestMovement = getLatestMovementByBalance(\n      filteredMovements,\n      balanceType\n    )\n\n    // Update latest movement if necessary\n    if (balanceType === ANJBalance.Active) {\n      if (lockedBalance?.gt(0))\n        latestMovement = getUpdatedLockedMovement(lockedBalance, latestMovement)\n    }\n\n    return {\n      amount: balance,\n      amountNotEffective,\n      latestMovement: convertMovement(acceptedMovements, latestMovement),\n    }\n  }, [\n    acceptedMovements,\n    balance,\n    balanceType,\n    filteredMovements,\n    lockedBalance,\n    movements,\n  ])\n}\n\nfunction useFilteredMovements(movements, acceptedMovements) {\n  return useMemo(() => {\n    if (!movements) {\n      return null\n    }\n    return movements.filter(movement => {\n      return isMovementOf(acceptedMovements, ANJMovement[movement.type])\n    })\n  }, [acceptedMovements, movements])\n}\n\n/**\n * @param {Object} options query options\n * @param {Boolean} options.pause Tells whether to pause query or not\n * @return {Boolean} true if account's first ANJ activation happened on current term\n */\nexport function useJurorFirstTimeANJActivation(options) {\n  const wallet = useWallet()\n  const { currentTermId } = useCourtClock()\n  const firstANJActivation = useFirstANJActivationQuery(wallet.account, options)\n\n  if (!firstANJActivation) return false\n\n  const firstANJActivationTerm = parseInt(\n    firstANJActivation.effectiveTermId,\n    10\n  )\n\n  // Activation is effective on next term from when the activation was performed\n  return firstANJActivationTerm === currentTermId + 1\n}\n\nexport function useJurorLockedANJDistribution() {\n  const {\n    maxRegularAppealRounds,\n    minActiveBalance,\n    penaltyPct,\n  } = useCourtConfig()\n  const { jurorDrafts, anjBalances } = useDashboardState()\n  const { lockedBalance } = anjBalances || {}\n\n  return useMemo(() => {\n    if (!lockedBalance || lockedBalance.eq(0) || !jurorDrafts) return null\n\n    // For final rounds the ANJ at stake is pre-slashed for all jurors when they commit their vote\n    return jurorDrafts\n      .filter(\n        jurorDraft =>\n          !jurorDraft.round.settledPenalties &&\n          jurorDraft.round.number < maxRegularAppealRounds\n      )\n      .reduce((lockDistribution, { weight, round }) => {\n        const { dispute } = round\n\n        // Since the subgraph cannot provide a way to tell how much was locked per draft we calculate it ourselves\n        // See https://github.com/aragon/court-subgraph/blob/7f0fec5c8953e9dbd67e5607fb6da03f69a60f40/src/DisputeManager.ts#L57\n        const lockedAmount = getDraftLockAmount(\n          minActiveBalance,\n          penaltyPct,\n          weight\n        )\n\n        const index = lockDistribution.findIndex(\n          locks => locks.disputeId === dispute.id\n        )\n\n        if (index >= 0) {\n          const elem = lockDistribution[index]\n\n          // Replace with updated amount and weight\n          lockDistribution.splice(index, 1, {\n            ...elem,\n            amount: elem.amount.add(lockedAmount),\n            weight: elem.weight.add(weight),\n          })\n        } else {\n          lockDistribution.push({\n            disputeId: dispute.id,\n            amount: lockedAmount,\n            weight,\n          })\n        }\n\n        return lockDistribution\n      }, [])\n  }, [\n    jurorDrafts,\n    lockedBalance,\n    maxRegularAppealRounds,\n    minActiveBalance,\n    penaltyPct,\n  ])\n}\n"]},"metadata":{},"sourceType":"module"}