{"ast":null,"code":"import { _ as _extends, d as createRequest } from \"./index-9bb95fa6.js\";\nexport { C as CombinedError, d as createRequest, f as formatDocument, b as makeErrorResult, m as makeResult, s as stringifyVariables } from \"./index-9bb95fa6.js\";\nimport { toPromise, scan, switchMap, fromValue, concat, map } from \"wonka\";\nimport { createClient } from \"./core.js\";\nexport { Client, cacheExchange, composeExchanges, createClient, debugExchange, dedupExchange, defaultExchanges, fallbackExchangeIO, fetchExchange, ssrExchange, subscriptionExchange } from \"./core.js\";\nimport { createContext, useContext, useState, useCallback, useMemo, useRef } from \"react\";\nimport { useOperator } from \"react-wonka\";\nvar defaultClient = createClient({\n  url: \"/graphql\"\n});\nvar Context = createContext(defaultClient);\nvar Provider = Context.Provider;\nvar Consumer = Context.Consumer;\nvar hasWarnedAboutDefault = !1;\n\nvar useClient = function () {\n  var client = useContext(Context);\n\n  if (\"production\" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {\n    hasWarnedAboutDefault = !0;\n    console.warn(\"Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\\nIf that's not what you want, please create a client and add a Provider.\");\n  }\n\n  return client;\n};\n\nvar initialState = {\n  fetching: !1,\n  stale: !1,\n  error: void 0,\n  data: void 0,\n  extensions: void 0\n};\n\nvar useMutation = function (query) {\n  var client = useClient();\n  var ref = useState(initialState);\n  var setState = ref[1];\n\n  function _ref(result) {\n    setState({\n      fetching: !1,\n      stale: !!result.stale,\n      data: result.data,\n      error: result.error,\n      extensions: result.extensions\n    });\n    return result;\n  }\n\n  return [ref[0], useCallback(function (variables, context) {\n    setState(_extends(_extends({}, initialState), {\n      fetching: !0\n    }));\n    var request = createRequest(query, variables);\n    return toPromise(client.executeMutation(request, context || {})).then(_ref);\n  }, [client, query, setState])];\n};\n\nvar useRequest = function (query, variables) {\n  var prev = useRef(void 0);\n  return useMemo(function () {\n    var request = createRequest(query, variables);\n\n    if (void 0 !== prev.current && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n\nfunction _ref(result, partial) {\n  return _extends(_extends(_extends({}, result), {\n    stale: !1\n  }), partial);\n}\n\nfunction _ref2(ref) {\n  return {\n    fetching: !1,\n    stale: !!ref.stale,\n    data: ref.data,\n    error: ref.error,\n    extensions: ref.extensions\n  };\n}\n\nfunction _ref3(query$) {\n  if (!query$) {\n    return fromValue({\n      fetching: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0\n  }), map(_ref2)(query$), fromValue({\n    fetching: !1\n  })]);\n}\n\nfunction _ref4(query$$) {\n  return scan(_ref, initialState)(switchMap(_ref3)(query$$));\n}\n\nvar useQuery = function (args) {\n  var client = useClient();\n  var request = useRequest(args.query, args.variables);\n  var makeQuery$ = useCallback(function (opts) {\n    return client.executeQuery(request, _extends(_extends({\n      requestPolicy: args.requestPolicy,\n      pollInterval: args.pollInterval\n    }, args.context), opts));\n  }, [client, request, args.requestPolicy, args.pollInterval, args.context]);\n  var ref = useOperator(_ref4, useMemo(function () {\n    return args.pause ? null : makeQuery$();\n  }, [args.pause, makeQuery$]), initialState);\n  var update = ref[1];\n  return [ref[0], useCallback(function (opts) {\n    return update(makeQuery$(opts));\n  }, [update, makeQuery$])];\n};\n\nfunction _ref2$1(ref) {\n  return {\n    fetching: !0,\n    stale: !!ref.stale,\n    data: ref.data,\n    error: ref.error,\n    extensions: ref.extensions\n  };\n}\n\nfunction _ref3$1(subscription$) {\n  if (!subscription$) {\n    return fromValue({\n      fetching: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0\n  }), map(_ref2$1)(subscription$), fromValue({\n    fetching: !1\n  })]);\n}\n\nvar useSubscription = function (args, handler) {\n  var client = useClient();\n  var handlerRef = useRef(handler);\n  handlerRef.current = handler;\n  var request = useRequest(args.query, args.variables);\n  var makeSubscription$ = useCallback(function (opts) {\n    return client.executeSubscription(request, _extends(_extends({}, args.context), opts));\n  }, [client, request, args.context]);\n\n  function _ref(result, partial) {\n    var handler = handlerRef.current;\n    var data = void 0 !== partial.data ? \"function\" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;\n    return _extends(_extends(_extends(_extends({}, result), {\n      stale: !1\n    }), partial), {\n      data: data\n    });\n  }\n\n  var ref = useOperator(function (subscription$$) {\n    return scan(_ref, initialState)(switchMap(_ref3$1)(subscription$$));\n  }, useMemo(function () {\n    return args.pause ? null : makeSubscription$();\n  }, [args.pause, makeSubscription$]), initialState);\n  var update = ref[1];\n  return [ref[0], useCallback(function (opts) {\n    return update(makeSubscription$(opts));\n  }, [update, makeSubscription$])];\n};\n\nfunction Mutation(props) {\n  var ref = useMutation(props.query);\n  var executeMutation = ref[1];\n  return props.children(_extends(_extends({}, ref[0]), {\n    executeMutation: executeMutation\n  }));\n}\n\nfunction Query(props) {\n  var ref = useQuery(props);\n  var executeQuery = ref[1];\n  return props.children(_extends(_extends({}, ref[0]), {\n    executeQuery: executeQuery\n  }));\n}\n\nfunction Subscription(props) {\n  var ref = useSubscription(props, props.handler);\n  var executeSubscription = ref[1];\n  return props.children(_extends(_extends({}, ref[0]), {\n    executeSubscription: executeSubscription\n  }));\n}\n\nexport { Consumer, Context, Mutation, Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };","map":null,"metadata":{},"sourceType":"module"}