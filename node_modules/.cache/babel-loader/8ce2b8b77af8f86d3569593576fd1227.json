{"ast":null,"code":"import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\n\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\n\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\n\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\n\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\n\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModal = QRCodeModal;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.rpcUrl = \"\";\n\n    this.enable = async () => {\n      const wc = await this.getWalletConnector();\n\n      if (wc) {\n        this.start();\n        this.subscribeWalletConnector();\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    };\n\n    this.request = async payload => {\n      return this.send(payload);\n    };\n\n    this.send = async (payload, callback) => {\n      if (typeof payload === \"string\") {\n        const method = payload;\n        let params = callback;\n\n        if (method === \"personal_sign\") {\n          params = parsePersonalSign(params);\n        }\n\n        return this.sendAsyncPromise(method, params);\n      }\n\n      payload = Object.assign({\n        id: payloadId(),\n        jsonrpc: \"2.0\"\n      }, payload);\n\n      if (payload.method === \"personal_sign\") {\n        payload.params = parsePersonalSign(payload.params);\n      }\n\n      if (callback) {\n        this.sendAsync(payload, callback);\n        return;\n      }\n\n      return this.sendAsyncPromise(payload.method, payload.params);\n    };\n\n    this.onConnect = callback => {\n      this.connectCallbacks.push(callback);\n    };\n\n    this.triggerConnect = result => {\n      if (this.connectCallbacks && this.connectCallbacks.length) {\n        this.connectCallbacks.forEach(callback => callback(result));\n      }\n    };\n\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new WalletConnect({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    });\n    this.rpc = opts.rpc || null;\n\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n    this.initialize();\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get connector() {\n    return this.wc;\n  }\n\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n\n  async disconnect() {\n    this.close();\n  }\n\n  async close() {\n    const wc = await this.getWalletConnector({\n      disableSessionCreation: true\n    });\n    await wc.killSession();\n    await this.onDisconnect();\n  }\n\n  async handleRequest(payload) {\n    try {\n      let response;\n      let result = null;\n      const wc = await this.getWalletConnector();\n\n      switch (payload.method) {\n        case \"wc_killSession\":\n          await this.close();\n          result = null;\n          break;\n\n        case \"eth_accounts\":\n          result = wc.accounts;\n          break;\n\n        case \"eth_coinbase\":\n          result = wc.accounts[0];\n          break;\n\n        case \"eth_chainId\":\n          result = wc.chainId;\n          break;\n\n        case \"net_version\":\n          result = wc.chainId;\n          break;\n\n        case \"eth_uninstallFilter\":\n          this.sendAsync(payload, _ => _);\n          result = true;\n          break;\n\n        default:\n          response = await this.handleOtherRequests(payload);\n      }\n\n      if (response) {\n        return response;\n      }\n\n      return this.formatResponse(payload, result);\n    } catch (error) {\n      this.emit(\"error\", error);\n      throw error;\n    }\n  }\n\n  async handleOtherRequests(payload) {\n    if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n      return this.handleReadRequests(payload);\n    }\n\n    const wc = await this.getWalletConnector();\n    const result = await wc.sendCustomRequest(payload);\n    return this.formatResponse(payload, result);\n  }\n\n  async handleReadRequests(payload) {\n    if (!this.http) {\n      const error = new Error(\"HTTP Connection not available\");\n      this.emit(\"error\", error);\n      throw error;\n    }\n\n    return this.http.send(payload);\n  }\n\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n\n  getWalletConnector(opts = {}) {\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession({\n          chainId: this.chainId\n        }).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n\n            this.isConnecting = false;\n            this.connected = true;\n\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n\n        resolve(wc);\n      }\n    });\n  }\n\n  async subscribeWalletConnector() {\n    const wc = await this.getWalletConnector();\n    wc.on(\"disconnect\", error => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n\n      this.onDisconnect();\n    });\n    wc.on(\"session_update\", (error, payload) => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n\n      this.updateState(payload.params[0]);\n    });\n  }\n\n  async onDisconnect() {\n    await this.stop();\n    this.emit(\"close\", 1000, \"Connection closed\");\n    this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n    this.connected = false;\n  }\n\n  async updateState(sessionParams) {\n    const {\n      accounts,\n      chainId,\n      networkId,\n      rpcUrl\n    } = sessionParams;\n\n    if (!this.accounts || accounts && this.accounts !== accounts) {\n      this.accounts = accounts;\n      this.emit(\"accountsChanged\", accounts);\n    }\n\n    if (!this.chainId || chainId && this.chainId !== chainId) {\n      this.chainId = chainId;\n      this.emit(\"chainChanged\", chainId);\n    }\n\n    if (!this.networkId || networkId && this.networkId !== networkId) {\n      this.networkId = networkId;\n      this.emit(\"networkChanged\", networkId);\n    }\n\n    this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n  }\n\n  updateRpcUrl(chainId, rpcUrl = \"\") {\n    const rpc = {\n      infuraId: this.infuraId,\n      custom: this.rpc || undefined\n    };\n    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new HttpConnection(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response.result);\n      });\n    });\n  }\n\n  initialize() {\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n    this.addProvider({\n      handleRequest: async (payload, next, end) => {\n        try {\n          const {\n            error,\n            result\n          } = await this.handleRequest(payload);\n          end(error, result);\n        } catch (error) {\n          end(error);\n        }\n      },\n      setEngine: _ => _\n    });\n  }\n\n  configWallet() {\n    return {\n      getAccounts: async cb => {\n        try {\n          const wc = await this.getWalletConnector();\n          const accounts = wc.accounts;\n\n          if (accounts && accounts.length) {\n            cb(null, accounts);\n          } else {\n            cb(new Error(\"Failed to get accounts\"));\n          }\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signMessage([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processPersonalMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processSignTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.sendTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTypedMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }\n    };\n  }\n\n}\n\nexport default WalletConnectProvider;","map":null,"metadata":{},"sourceType":"module"}