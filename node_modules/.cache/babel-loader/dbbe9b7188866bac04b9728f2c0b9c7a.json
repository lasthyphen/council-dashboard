{"ast":null,"code":"import { ethers } from 'ethers';\nimport { forwarderAbi } from './abis';\nexport var FORWARD_SIG = '0xd948d468'; // function forward(bytes)\n\n/**\n * Tells if the given calldata (as a bytes string) is a valid invocation of\n * `forward(bytes)`.\n *\n * It will return true only if the given calldata starts with the forward\n * function signature and follows with at least an empty bytes array properly\n * ABI encoded following the convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n */\n\nexport function isValidForwardCall(calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, ''); // First 4 bytes represent the function selector\n\n  var selector = calldata.substring(0, 8); // Drop selector and grab the argument data\n\n  var evmscriptData = calldata.substring(8); // Since arrays of bytes are encoded following the [offset][length][data]\n  // format, we expect it to have at least two words length (empty data scenario)\n\n  return \"0x\".concat(selector) === FORWARD_SIG && evmscriptData.length >= 128;\n}\n/**\n * Parse the evmscript of a forward call following the byte ABI encoding\n * convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n * @returns {string} Array of bytes representing the forwarded evmscript\n */\n\nexport function parseForwardCall(calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, ''); // Drop function selector and grab the argument data (of type bytes)\n\n  var evmscriptData = calldata.substring(8); // Parse first word of the bytes array to get data offset\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n\n  var offset = parseInt(\"0x\".concat(evmscriptData.substring(0, 64)), 16) * 2; // The first word in the data is its length (uint256); actual data starts after\n\n  var startIndex = offset + 64; // Parse length of the data stored\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n\n  var dataLength = parseInt(\"0x\".concat(evmscriptData.substring(offset, startIndex)), 16) * 2; // Grab the data stored in the bytes array\n\n  return \"0x\".concat(evmscriptData.substring(startIndex, startIndex + dataLength));\n}\n/**\n * Whether the `sender` can use the `forwarder` to invoke `script`.\n */\n\nexport function canForward(forwarderAddress, sender, script, provider) {\n  // Check if a token approval pretransaction is needed due to the forwarder requiring a fee\n  var forwarder = new ethers.Contract(forwarderAddress, forwarderAbi, provider);\n  return forwarder.canForward(sender, script).catch(function () {\n    return false;\n  });\n}","map":null,"metadata":{},"sourceType":"module"}