{"ast":null,"code":"import _regeneratorRuntime from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _objectSpread from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{useEffect,useMemo,useState}from'react';import resolvePathname from'resolve-pathname';import{IPFS_ENDPOINT}from'../endpoints';import{useCourtClock}from'../providers/CourtClock';import{useCourtConfig}from'../providers/CourtConfig';import{useSingleDisputeSubscription,useDisputesSubscription}from'./subscription-hooks';import{getPhaseAndTransition}from'../utils/dispute-utils';import{ipfsGet,getIpfsCidFromUri}from'../lib/ipfs-utils';import{convertToString,Status}from'../types/dispute-status-types';var IPFS_ERROR_MSG='Error loading content from ipfs';export default function useDisputes(){var courtConfig=useCourtConfig();var _useCourtClock=useCourtClock(),currentTermId=_useCourtClock.currentTermId;var _useDisputesSubscript=useDisputesSubscription(),disputes=_useDisputesSubscript.disputes,fetching=_useDisputesSubscript.fetching,error=_useDisputesSubscript.error;var disputesPhases=useMemo(function(){if(!disputes){return null;}return disputes.map(function(d){return getPhaseAndTransition(d,currentTermId,courtConfig);});},[courtConfig,currentTermId,disputes]);var disputesPhasesKey=disputesPhases?disputesPhases.map(function(v){return convertToString(Object.values(v)[0]);}).join(''):null;return useMemo(function(){if(error){return{error:error};}if(fetching){return{fetching:fetching};}return{disputes:disputes.map(function(dispute,i){return _objectSpread({},dispute,{},disputesPhases[i]);})};},[disputesPhases,disputes,disputesPhasesKey,error]);// eslint-disable-line react-hooks/exhaustive-deps\n}/**\n * Hook that processes a single dispute data\n * @param {String} disputeId Id of the dispute\n * @returns {Array} Array conformed by the dispute processed data, fetching indicator and an error object from the graph or an ipfs error in that order\n * (the error also indicates if the error is from the graph since we need to handle in a different way\n * in the dispute detail, the timeline can not be displayed if is a graph error but can if the error is from ipfs)\n */export function useDispute(disputeId){var courtConfig=useCourtConfig();var _useCourtClock2=useCourtClock(),currentTermId=_useCourtClock2.currentTermId;var _useSingleDisputeSubs=useSingleDisputeSubscription(disputeId),dispute=_useSingleDisputeSubs.dispute,graphFetching=_useSingleDisputeSubs.fetching,graphError=_useSingleDisputeSubs.error;var processedDispute=useProcessedDispute(dispute);var disputePhase=getPhaseAndTransition(dispute,currentTermId,courtConfig);var disputePhaseKey=disputePhase?convertToString(Object.values(disputePhase)[0]):'';var graphErrorMessage=(graphError===null||graphError===void 0?void 0:graphError.message)||'';var disputeErrorMessage=(processedDispute===null||processedDispute===void 0?void 0:processedDispute.error)||graphErrorMessage;return useMemo(function(){var fetching=graphFetching||dispute&&!processedDispute;return[dispute&&processedDispute?_objectSpread({},processedDispute,{},disputePhase):null,fetching,disputeErrorMessage?{message:disputeErrorMessage,fromGraph:Boolean(graphErrorMessage)}:null];}/* eslint-disable react-hooks/exhaustive-deps */,[disputeErrorMessage,disputePhaseKey,graphErrorMessage,graphFetching,processedDispute]/* eslint-enable react-hooks/exhaustive-deps */);}function useProcessedDispute(dispute){var _useState=useState(null),_useState2=_slicedToArray(_useState,2),processedDispute=_useState2[0],setProcessedDispute=_useState2[1];useEffect(function(){var cancelled=false;var processDisputeData=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var disputeData;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(dispute.status===Status.Voided)){_context.next=2;break;}return _context.abrupt(\"return\",dispute);case 2:_context.next=4;return getDisputeData(dispute);case 4:disputeData=_context.sent;return _context.abrupt(\"return\",_objectSpread({},dispute,{},disputeData,{error:disputeData?null:IPFS_ERROR_MSG}));case 6:case\"end\":return _context.stop();}}},_callee);}));return function processDisputeData(){return _ref.apply(this,arguments);};}();var processDispute=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){var processedDispute;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(dispute){_context2.next=2;break;}return _context2.abrupt(\"return\");case 2:_context2.next=4;return processDisputeData();case 4:processedDispute=_context2.sent;if(!cancelled){setProcessedDispute(processedDispute);}case 6:case\"end\":return _context2.stop();}}},_callee2);}));return function processDispute(){return _ref2.apply(this,arguments);};}();processDispute();return function(){cancelled=true;};},[dispute]);return processedDispute;}function getDisputeData(_x){return _getDisputeData.apply(this,arguments);}function _getDisputeData(){_getDisputeData=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(dispute){return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(!dispute.disputable){_context3.next=2;break;}return _context3.abrupt(\"return\",processDisputableData(dispute));case 2:return _context3.abrupt(\"return\",processRawDisputeData(dispute));case 3:case\"end\":return _context3.stop();}}},_callee3);}));return _getDisputeData.apply(this,arguments);}function processDisputableData(_x2){return _processDisputableData.apply(this,arguments);}/**\n * Processes metadata for raw disputes. `metadataUri` contains the IPFS CID which will be fetched and parsed.\n * @param {*} dispute Dispute from which data will be processed.\n * @returns {Object | null} Dispute processed data.\n */function _processDisputableData(){_processDisputableData=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dispute){var _dispute$disputable,agreement,defendant,plaintiff,organization,title,agreementIpfsCid;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_dispute$disputable=dispute.disputable,agreement=_dispute$disputable.agreement,defendant=_dispute$disputable.defendant,plaintiff=_dispute$disputable.plaintiff,organization=_dispute$disputable.organization,title=_dispute$disputable.title;agreementIpfsCid=getIpfsCidFromUri(agreement);return _context4.abrupt(\"return\",{agreementText:title,agreementUrl:\"\".concat(IPFS_ENDPOINT,\"/\").concat(agreementIpfsCid),defendant:defendant,description:title,organization:organization,plaintiff:plaintiff});case 3:case\"end\":return _context4.stop();}}},_callee4);}));return _processDisputableData.apply(this,arguments);}function processRawDisputeData(_x3){return _processRawDisputeData.apply(this,arguments);}function _processRawDisputeData(){_processRawDisputeData=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(dispute){var disputeDescription,metadataUri,ipfsPath,_ref3,data,error,parsedDisputeData,agreementText,agreementUrl,_parsedDisputeData$ag,agreementTitle,_parsedDisputeData$de,defendant,_parsedDisputeData$de2,description,_parsedDisputeData$di,disputedActionRadspec,_parsedDisputeData$di2,disputedActionText,_parsedDisputeData$di3,disputedActionURL,_parsedDisputeData$or,organization,_parsedDisputeData$pl,plaintiff;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:disputeDescription=dispute.description,metadataUri=dispute.metadataUri;if(!metadataUri){_context5.next=21;break;}ipfsPath=getIpfsCidFromUri(metadataUri);if(!ipfsPath){_context5.next=21;break;}_context5.next=6;return ipfsGet(ipfsPath);case 6:_ref3=_context5.sent;data=_ref3.data;error=_ref3.error;if(error){_context5.next=21;break;}_context5.prev=10;// Parse IPFS content\nparsedDisputeData=JSON.parse(data);agreementText=parsedDisputeData.agreementText.replace(/^.\\//,'');// Note that in this case, we expect the agreement's location to be relative to the\n// metadata URI. For example, if the metadataUri is `<cid>/metadata.json`, the agreement's\n// location would be `<cid>/<agreement>`\nagreementUrl=agreementText?resolvePathname(agreementText,\"\".concat(IPFS_ENDPOINT,\"/\").concat(ipfsPath)):'';_parsedDisputeData$ag=parsedDisputeData.agreementTitle,agreementTitle=_parsedDisputeData$ag===void 0?'':_parsedDisputeData$ag,_parsedDisputeData$de=parsedDisputeData.defendant,defendant=_parsedDisputeData$de===void 0?'':_parsedDisputeData$de,_parsedDisputeData$de2=parsedDisputeData.description,description=_parsedDisputeData$de2===void 0?disputeDescription:_parsedDisputeData$de2,_parsedDisputeData$di=parsedDisputeData.disputedActionRadspec,disputedActionRadspec=_parsedDisputeData$di===void 0?'':_parsedDisputeData$di,_parsedDisputeData$di2=parsedDisputeData.disputedActionText,disputedActionText=_parsedDisputeData$di2===void 0?'':_parsedDisputeData$di2,_parsedDisputeData$di3=parsedDisputeData.disputedActionURL,disputedActionURL=_parsedDisputeData$di3===void 0?'':_parsedDisputeData$di3,_parsedDisputeData$or=parsedDisputeData.organization,organization=_parsedDisputeData$or===void 0?'':_parsedDisputeData$or,_parsedDisputeData$pl=parsedDisputeData.plaintiff,plaintiff=_parsedDisputeData$pl===void 0?'':_parsedDisputeData$pl;return _context5.abrupt(\"return\",{agreementText:agreementTitle||agreementText||'',agreementUrl:agreementUrl,defendant:defendant,description:description,disputedActionRadspec:disputedActionRadspec,disputedActionText:disputedActionText,disputedActionURL:disputedActionURL,organization:organization,plaintiff:plaintiff});case 18:_context5.prev=18;_context5.t0=_context5[\"catch\"](10);return _context5.abrupt(\"return\",{description:data});case 21:return _context5.abrupt(\"return\",null);case 22:case\"end\":return _context5.stop();}}},_callee5,null,[[10,18]]);}));return _processRawDisputeData.apply(this,arguments);}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useDisputes.js"],"names":["useEffect","useMemo","useState","resolvePathname","IPFS_ENDPOINT","useCourtClock","useCourtConfig","useSingleDisputeSubscription","useDisputesSubscription","getPhaseAndTransition","ipfsGet","getIpfsCidFromUri","convertToString","Status","IPFS_ERROR_MSG","useDisputes","courtConfig","currentTermId","disputes","fetching","error","disputesPhases","map","d","disputesPhasesKey","v","Object","values","join","dispute","i","useDispute","disputeId","graphFetching","graphError","processedDispute","useProcessedDispute","disputePhase","disputePhaseKey","graphErrorMessage","message","disputeErrorMessage","fromGraph","Boolean","setProcessedDispute","cancelled","processDisputeData","status","Voided","getDisputeData","disputeData","processDispute","disputable","processDisputableData","processRawDisputeData","agreement","defendant","plaintiff","organization","title","agreementIpfsCid","agreementText","agreementUrl","description","disputeDescription","metadataUri","ipfsPath","data","parsedDisputeData","JSON","parse","replace","agreementTitle","disputedActionRadspec","disputedActionText","disputedActionURL"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useState } from 'react'\nimport resolvePathname from 'resolve-pathname'\nimport { IPFS_ENDPOINT } from '../endpoints'\nimport { useCourtClock } from '../providers/CourtClock'\nimport { useCourtConfig } from '../providers/CourtConfig'\nimport {\n  useSingleDisputeSubscription,\n  useDisputesSubscription,\n} from './subscription-hooks'\nimport { getPhaseAndTransition } from '../utils/dispute-utils'\nimport { ipfsGet, getIpfsCidFromUri } from '../lib/ipfs-utils'\nimport { convertToString, Status } from '../types/dispute-status-types'\n\nconst IPFS_ERROR_MSG = 'Error loading content from ipfs'\n\nexport default function useDisputes() {\n  const courtConfig = useCourtConfig()\n  const { currentTermId } = useCourtClock()\n  const { disputes, fetching, error } = useDisputesSubscription()\n\n  const disputesPhases = useMemo(() => {\n    if (!disputes) {\n      return null\n    }\n\n    return disputes.map(d =>\n      getPhaseAndTransition(d, currentTermId, courtConfig)\n    )\n  }, [courtConfig, currentTermId, disputes])\n\n  const disputesPhasesKey = disputesPhases\n    ? disputesPhases.map(v => convertToString(Object.values(v)[0])).join('')\n    : null\n\n  return useMemo(() => {\n    if (error) {\n      return { error }\n    }\n\n    if (fetching) {\n      return { fetching }\n    }\n\n    return {\n      disputes: disputes.map((dispute, i) => {\n        return {\n          ...dispute,\n          ...disputesPhases[i],\n        }\n      }),\n    }\n  }, [disputesPhases, disputes, disputesPhasesKey, error]) // eslint-disable-line react-hooks/exhaustive-deps\n}\n\n/**\n * Hook that processes a single dispute data\n * @param {String} disputeId Id of the dispute\n * @returns {Array} Array conformed by the dispute processed data, fetching indicator and an error object from the graph or an ipfs error in that order\n * (the error also indicates if the error is from the graph since we need to handle in a different way\n * in the dispute detail, the timeline can not be displayed if is a graph error but can if the error is from ipfs)\n */\nexport function useDispute(disputeId) {\n  const courtConfig = useCourtConfig()\n  const { currentTermId } = useCourtClock()\n  const {\n    dispute,\n    fetching: graphFetching,\n    error: graphError,\n  } = useSingleDisputeSubscription(disputeId)\n\n  const processedDispute = useProcessedDispute(dispute)\n  const disputePhase = getPhaseAndTransition(\n    dispute,\n    currentTermId,\n    courtConfig\n  )\n  const disputePhaseKey = disputePhase\n    ? convertToString(Object.values(disputePhase)[0])\n    : ''\n\n  const graphErrorMessage = graphError?.message || ''\n  const disputeErrorMessage = processedDispute?.error || graphErrorMessage\n\n  return useMemo(\n    () => {\n      const fetching = graphFetching || (dispute && !processedDispute)\n\n      return [\n        dispute && processedDispute\n          ? {\n              ...processedDispute,\n              ...disputePhase,\n            }\n          : null,\n        fetching,\n        disputeErrorMessage\n          ? {\n              message: disputeErrorMessage,\n              fromGraph: Boolean(graphErrorMessage),\n            }\n          : null,\n      ]\n    } /* eslint-disable react-hooks/exhaustive-deps */,\n    [\n      disputeErrorMessage,\n      disputePhaseKey,\n      graphErrorMessage,\n      graphFetching,\n      processedDispute,\n    ]\n    /* eslint-enable react-hooks/exhaustive-deps */\n  )\n}\n\nfunction useProcessedDispute(dispute) {\n  const [processedDispute, setProcessedDispute] = useState(null)\n\n  useEffect(() => {\n    let cancelled = false\n\n    const processDisputeData = async () => {\n      if (dispute.status === Status.Voided) {\n        return dispute\n      }\n\n      const disputeData = await getDisputeData(dispute)\n\n      return {\n        ...dispute,\n        ...disputeData,\n        error: disputeData ? null : IPFS_ERROR_MSG,\n      }\n    }\n\n    const processDispute = async () => {\n      if (!dispute) {\n        return\n      }\n\n      const processedDispute = await processDisputeData()\n      if (!cancelled) {\n        setProcessedDispute(processedDispute)\n      }\n    }\n\n    processDispute()\n\n    return () => {\n      cancelled = true\n    }\n  }, [dispute])\n\n  return processedDispute\n}\n\nasync function getDisputeData(dispute) {\n  // Dispute is disputable\n  if (dispute.disputable) {\n    return processDisputableData(dispute)\n  }\n\n  // Dispute is raw dispute\n  return processRawDisputeData(dispute)\n}\n\nasync function processDisputableData(dispute) {\n  const {\n    agreement,\n    defendant,\n    plaintiff,\n    organization,\n    title,\n  } = dispute.disputable\n\n  const agreementIpfsCid = getIpfsCidFromUri(agreement)\n\n  return {\n    agreementText: title,\n    agreementUrl: `${IPFS_ENDPOINT}/${agreementIpfsCid}`,\n    defendant,\n    description: title,\n    organization,\n    plaintiff,\n  }\n}\n\n/**\n * Processes metadata for raw disputes. `metadataUri` contains the IPFS CID which will be fetched and parsed.\n * @param {*} dispute Dispute from which data will be processed.\n * @returns {Object | null} Dispute processed data.\n */\nasync function processRawDisputeData(dispute) {\n  const { description: disputeDescription, metadataUri } = dispute\n\n  if (metadataUri) {\n    const ipfsPath = getIpfsCidFromUri(metadataUri)\n\n    if (ipfsPath) {\n      // Fetch IPFS content\n      const { data, error } = await ipfsGet(ipfsPath)\n      if (!error) {\n        try {\n          // Parse IPFS content\n          const parsedDisputeData = JSON.parse(data)\n          const agreementText = parsedDisputeData.agreementText.replace(\n            /^.\\//,\n            ''\n          )\n          // Note that in this case, we expect the agreement's location to be relative to the\n          // metadata URI. For example, if the metadataUri is `<cid>/metadata.json`, the agreement's\n          // location would be `<cid>/<agreement>`\n          const agreementUrl = agreementText\n            ? resolvePathname(agreementText, `${IPFS_ENDPOINT}/${ipfsPath}`)\n            : ''\n\n          const {\n            agreementTitle = '',\n            defendant = '',\n            description = disputeDescription,\n            disputedActionRadspec = '',\n            disputedActionText = '',\n            disputedActionURL = '',\n            organization = '',\n            plaintiff = '',\n          } = parsedDisputeData\n\n          return {\n            agreementText: agreementTitle || agreementText || '',\n            agreementUrl,\n            defendant,\n            description,\n            disputedActionRadspec,\n            disputedActionText,\n            disputedActionURL,\n            organization,\n            plaintiff,\n          }\n        } catch (err) {\n          return {\n            description: data,\n          }\n        }\n      }\n    }\n  }\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}