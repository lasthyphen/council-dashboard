{"ast":null,"code":"import _regeneratorRuntime from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _toArray from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _slicedToArray from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { ethers } from 'ethers';\nimport { addressesEqual, includesAddress, ANY_ENTITY } from '../address';\nimport { isFullMethodSignature } from '../app';\nimport { encodeCallScript } from '../callScript';\nimport { canForward } from '../forwarding';\nimport { createDirectTransactionForApp, createForwarderTransactionBuilder, buildForwardingFeePretransaction } from '../transactions';\n\nfunction validateMethod(destination, methodSignature, destinationApp) {\n  var methods = destinationApp.intents;\n\n  if (!methods) {\n    throw new Error(\"No functions specified in artifact for \".concat(destination));\n  } // Find the relevant method information\n\n\n  var method = methods.find(function (method) {\n    return isFullMethodSignature(methodSignature) ? method.sig === methodSignature : // If the full signature isn't given, just select the first overload declared\n    method.sig.split('(')[0] === methodSignature;\n  });\n\n  if (!method) {\n    throw new Error(\"No method named \".concat(methodSignature, \" on \").concat(destination));\n  }\n\n  return method;\n}\n/**\n * Calculate the forwarding path for a transaction to `destination`\n * that invokes `directTransaction`.\n *\n */\n\n\nfunction calculateForwardingPath(_x, _x2, _x3, _x4, _x5) {\n  return _calculateForwardingPath.apply(this, arguments);\n}\n/**\n * Calculate the transaction path for a transaction to `destination`\n * that invokes `methodSignature` with `params`.\n *\n */\n\n\nfunction _calculateForwardingPath() {\n  _calculateForwardingPath = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(sender, directTransaction, forwardersWithPermission, forwarders, provider) {\n    var createForwarderTransaction, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, forwarder, script, transaction, forwardingFeePretransaction, filterForwarders, queue, _loop, _ret;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(forwardersWithPermission.length === 0)) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", {\n              path: []\n            });\n\n          case 2:\n            createForwarderTransaction = createForwarderTransactionBuilder(sender, directTransaction); // Check if one of the forwarders that has permission to perform an action\n            // with `sig` on `address` can forward for us directly\n\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _iteratorError = undefined;\n            _context2.prev = 6;\n            _iterator = forwardersWithPermission[Symbol.iterator]();\n\n          case 8:\n            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n              _context2.next = 28;\n              break;\n            }\n\n            forwarder = _step.value;\n            script = encodeCallScript([directTransaction]);\n            _context2.next = 13;\n            return canForward(forwarder, sender, script, provider);\n\n          case 13:\n            if (!_context2.sent) {\n              _context2.next = 25;\n              break;\n            }\n\n            transaction = createForwarderTransaction(forwarder, script);\n            _context2.prev = 15;\n            _context2.next = 18;\n            return buildForwardingFeePretransaction(transaction, provider);\n\n          case 18:\n            forwardingFeePretransaction = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              forwardingFeePretransaction: forwardingFeePretransaction,\n              path: [transaction, directTransaction]\n            });\n\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](15);\n            return _context2.abrupt(\"return\", {\n              path: []\n            });\n\n          case 25:\n            _iteratorNormalCompletion = true;\n            _context2.next = 8;\n            break;\n\n          case 28:\n            _context2.next = 34;\n            break;\n\n          case 30:\n            _context2.prev = 30;\n            _context2.t1 = _context2[\"catch\"](6);\n            _didIteratorError = true;\n            _iteratorError = _context2.t1;\n\n          case 34:\n            _context2.prev = 34;\n            _context2.prev = 35;\n\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n\n          case 37:\n            _context2.prev = 37;\n\n            if (!_didIteratorError) {\n              _context2.next = 40;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 40:\n            return _context2.finish(37);\n\n          case 41:\n            return _context2.finish(34);\n\n          case 42:\n            // Get a list of all forwarders (excluding the forwarders with direct permission)\n            filterForwarders = forwarders.filter(function (forwarder) {\n              return !includesAddress(forwardersWithPermission, forwarder);\n            }); // Set up the path finding queue\n            // The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>\n            // In other words: it is an array of tuples, where the first index of the tuple\n            // is the current path and the second index of the tuple is the\n            // queue (a list of unexplored forwarder addresses) for that path\n\n            queue = forwardersWithPermission.map(function (forwarderWithPermission) {\n              // TODO: Fix types (type queue = [DirectTransaction[], string[]][])\n              return [[createForwarderTransaction(forwarderWithPermission, encodeCallScript([directTransaction])), directTransaction], filterForwarders];\n            }); // Find the shortest path via a breadth-first search of forwarder paths.\n            // We do a breadth-first instead of depth-first search because:\n            //   - We assume that most forwarding paths will be quite short, so it should be faster\n            //     to check in \"stages\" rather than exhaust single paths\n            //   - We don't currently protect against cycles in the path, and so exhausting single\n            //     paths can be wasteful if they result in dead ends\n            // TODO: We should find and return multiple paths\n\n            _loop =\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _loop() {\n              var _queue$shift, _queue$shift2, path, _queue$shift2$, forwarder, nextQueue, previousForwarder, script, _transaction, _forwardingFeePretransaction;\n\n              return _regeneratorRuntime.wrap(function _loop$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      _queue$shift = queue.shift(), _queue$shift2 = _slicedToArray(_queue$shift, 2), path = _queue$shift2[0], _queue$shift2$ = _toArray(_queue$shift2[1]), forwarder = _queue$shift2$[0], nextQueue = _queue$shift2$.slice(1); // Skip if no forwarder or the path is longer than 5\n\n                      if (!(!forwarder || path.length > 5)) {\n                        _context.next = 3;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", \"continue\");\n\n                    case 3:\n                      // Get the previous forwarder address\n                      previousForwarder = path[0].to; // Encode the previous transaction into an EVM callscript\n\n                      script = encodeCallScript([path[0]]);\n                      _context.next = 7;\n                      return canForward(previousForwarder, forwarder, script, provider);\n\n                    case 7:\n                      if (!_context.sent) {\n                        _context.next = 25;\n                        break;\n                      }\n\n                      _context.next = 10;\n                      return canForward(forwarder, sender, script, provider);\n\n                    case 10:\n                      if (!_context.sent) {\n                        _context.next = 24;\n                        break;\n                      }\n\n                      // The previous forwarder can forward a transaction for this forwarder,\n                      // and this forwarder can forward for our address, so we have found a path\n                      _transaction = createForwarderTransaction(forwarder, script); // Only apply pretransactions to the first transaction in the path\n                      // as it's the only one that will be executed by the user\n\n                      _context.prev = 12;\n                      _context.next = 15;\n                      return buildForwardingFeePretransaction(_transaction, provider);\n\n                    case 15:\n                      _forwardingFeePretransaction = _context.sent;\n                      return _context.abrupt(\"return\", {\n                        v: {\n                          forwardingFeePretransaction: _forwardingFeePretransaction,\n                          path: [_transaction].concat(_toConsumableArray(path))\n                        }\n                      });\n\n                    case 19:\n                      _context.prev = 19;\n                      _context.t0 = _context[\"catch\"](12);\n                      return _context.abrupt(\"return\", {\n                        v: {\n                          path: []\n                        }\n                      });\n\n                    case 22:\n                      _context.next = 25;\n                      break;\n\n                    case 24:\n                      // The previous forwarder can forward a transaction for this forwarder,\n                      // but this forwarder can not forward for our address, so we add it as a\n                      // possible path in the queue for later exploration.\n                      queue.push([[createForwarderTransaction(forwarder, script)].concat(_toConsumableArray(path)), // Avoid including the current forwarder as a candidate for the next step\n                      // in the path. Note that this is naive and may result in repeating cycles,\n                      // but the maximum path length would prevent against infinite loops\n                      forwarders.filter(function (nextForwarder) {\n                        return nextForwarder !== forwarder;\n                      })]);\n\n                    case 25:\n                      // We add the current path on the back of the queue again, but we shorten\n                      // the list of possible forwarders.\n                      queue.push([path, nextQueue]);\n\n                    case 26:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _loop, null, [[12, 19]]);\n            });\n\n          case 45:\n            return _context2.delegateYield(_loop(), \"t2\", 46);\n\n          case 46:\n            _ret = _context2.t2;\n            _context2.t3 = _ret;\n            _context2.next = _context2.t3 === \"continue\" ? 50 : 51;\n            break;\n\n          case 50:\n            return _context2.abrupt(\"continue\", 53);\n\n          case 51:\n            if (!(typeof _ret === \"object\")) {\n              _context2.next = 53;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", _ret.v);\n\n          case 53:\n            if (queue.length) {\n              _context2.next = 45;\n              break;\n            }\n\n          case 54:\n            return _context2.abrupt(\"return\", {\n              path: []\n            });\n\n          case 55:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee, null, [[6, 30, 34, 42], [15, 22], [35,, 37, 41]]);\n  }));\n  return _calculateForwardingPath.apply(this, arguments);\n}\n\nexport function calculateTransactionPath(_x6, _x7, _x8, _x9, _x10, _x11, _x12) {\n  return _calculateTransactionPath.apply(this, arguments);\n}\n\nfunction _calculateTransactionPath() {\n  _calculateTransactionPath = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(sender, destination, methodSignature, params, apps, provider, finalForwarder //Address of the final forwarder that can perfom the action. Needed for actions that aren't in the ACL but whose execution depends on other factors\n  ) {\n    var _a, destinationApp, method, finalForwarderProvided, directTransaction, forwarders, forwardersWithPermission, role, allowedEntities;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // Get the destination app\n            destinationApp = apps.find(function (app) {\n              return app.address == destination;\n            });\n\n            if (destinationApp) {\n              _context3.next = 3;\n              break;\n            }\n\n            throw new Error(\"Transaction path destination (\".concat(destination, \") is not an installed app\"));\n\n          case 3:\n            // Make sure the method signature is correct\n            method = validateMethod(destination, methodSignature, destinationApp);\n            finalForwarderProvided = finalForwarder ? ethers.utils.isAddress(finalForwarder) : false;\n            _context3.next = 7;\n            return createDirectTransactionForApp(sender, destinationApp, method.sig, params);\n\n          case 7:\n            directTransaction = _context3.sent;\n\n            if (!(method.roles.length === 0 && !finalForwarderProvided || finalForwarder && addressesEqual(finalForwarder, sender))) {\n              _context3.next = 16;\n              break;\n            }\n\n            _context3.prev = 9;\n            return _context3.abrupt(\"return\", {\n              path: [directTransaction]\n            });\n\n          case 13:\n            _context3.prev = 13;\n            _context3.t0 = _context3[\"catch\"](9);\n            return _context3.abrupt(\"return\", {\n              path: []\n            });\n\n          case 16:\n            // Failing this, attempt transaction pathing algorithm with forwarders\n            forwarders = apps.filter(function (app) {\n              return app.isForwarder === true;\n            }).map(function (app) {\n              return app.address;\n            });\n            forwardersWithPermission = [];\n\n            if (!finalForwarderProvided) {\n              _context3.next = 25;\n              break;\n            }\n\n            if (!finalForwarder) {\n              _context3.next = 23;\n              break;\n            }\n\n            if (includesAddress(forwarders, finalForwarder)) {\n              _context3.next = 22;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", {\n              path: []\n            });\n\n          case 22:\n            // Only attempt to find path with declared final forwarder; assume the final forwarder\n            // is able to invoke the action\n            forwardersWithPermission = [finalForwarder];\n\n          case 23:\n            _context3.next = 40;\n            break;\n\n          case 25:\n            _context3.next = 27;\n            return destinationApp.roles();\n\n          case 27:\n            _context3.t1 = function (role) {\n              return role.name === method.roles[0];\n            };\n\n            role = _context3.sent.find(_context3.t1);\n            allowedEntities = ((_a = role === null || role === void 0 ? void 0 : role.permissions) === null || _a === void 0 ? void 0 : _a.map(function (permission) {\n              return permission.granteeAddress;\n            })) || []; // No one has access, so of course we don't as well\n\n            if (!(allowedEntities.length === 0)) {\n              _context3.next = 32;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", {\n              path: []\n            });\n\n          case 32:\n            if (!(includesAddress(allowedEntities, sender) || includesAddress(allowedEntities, ANY_ENTITY))) {\n              _context3.next = 39;\n              break;\n            }\n\n            _context3.prev = 33;\n            return _context3.abrupt(\"return\", {\n              path: [directTransaction]\n            });\n\n          case 37:\n            _context3.prev = 37;\n            _context3.t2 = _context3[\"catch\"](33);\n\n          case 39:\n            // Find forwarders with permission to perform the action\n            forwardersWithPermission = forwarders.filter(function (forwarder) {\n              return includesAddress(allowedEntities, forwarder);\n            });\n\n          case 40:\n            return _context3.abrupt(\"return\", calculateForwardingPath(sender, directTransaction, forwardersWithPermission, forwarders, provider));\n\n          case 41:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2, null, [[9, 13], [33, 37]]);\n  }));\n  return _calculateTransactionPath.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}