{"ast":null,"code":"import { useMemo } from 'react';\nimport { useCourtClock } from '../providers/CourtClock';\nimport { useCourtConfig } from '../providers/CourtConfig';\nimport { useTasksSubscription } from './subscription-hooks';\nimport { getTermEndTime } from '../utils/court-utils';\nimport { getAdjudicationPhase } from '../utils/dispute-utils';\nimport { convertToString, getTaskActionString, Phase as DisputePhase } from '../types/dispute-status-types';\nimport { getVoidedDisputesByCourt } from '../flagged-disputes/voided-disputes';\nexport default function useTasks() {\n  const courtConfig = useCourtConfig();\n  const {\n    currentTermId\n  } = useCourtClock();\n  const {\n    tasks,\n    fetching,\n    error\n  } = useTasksSubscription();\n  const openTasks = useOpenTasks(tasks, currentTermId, courtConfig);\n  return {\n    openTasks,\n    fetching,\n    error\n  };\n}\n\nfunction useOpenTasks(tasks, currentTermId, courtConfig) {\n  const voidedDisputes = getVoidedDisputesByCourt();\n  const convertedTasks = useMemo(() => {\n    if (!tasks) {\n      return null;\n    }\n\n    return tasks.map(task => ({ ...task,\n      ...getAdjudicationPhase(task.dispute, task, currentTermId, courtConfig)\n    }));\n  }, [courtConfig, currentTermId, tasks]);\n  const convertedTasksPhasesKey = convertedTasks ? convertedTasks.map(phase => convertToString(phase.phase)).join('') : null;\n  const incompleteTasks = useMemo(() => {\n    if (!convertedTasks) {\n      return null;\n    }\n\n    return convertedTasks.filter(task => !voidedDisputes.has(task.dispute.id) && task.phase !== DisputePhase.Ended);\n  }, [convertedTasksPhasesKey, voidedDisputes]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return useMemo(() => {\n    if (!convertedTasks) {\n      return [];\n    }\n\n    const openTasks = [];\n\n    for (let i = 0; i < incompleteTasks.length; i++) {\n      const currentPhase = incompleteTasks[i].phase;\n      const nextTransition = getTermEndTime(incompleteTasks[i].phaseEndTerm, courtConfig);\n\n      if (currentPhase !== DisputePhase.AppealRuling && currentPhase !== DisputePhase.ConfirmAppeal) {\n        for (let j = 0; j < incompleteTasks[i].jurors.length; j++) {\n          if (isVotingTaskOpen(incompleteTasks[i].jurors[j], currentPhase)) {\n            openTasks.push({\n              number: incompleteTasks[i].number,\n              state: incompleteTasks[i].state,\n              createdAt: incompleteTasks[i].createdAt,\n              juror: incompleteTasks[i].jurors[j].juror.id,\n              disputeId: incompleteTasks[i].dispute.id,\n              commitment: incompleteTasks[i].jurors[j].commitment,\n              outcome: incompleteTasks[i].jurors[j].outcome,\n              phase: getTaskActionString(currentPhase),\n              phaseType: currentPhase,\n              dueDate: nextTransition\n            });\n          }\n        }\n      } else {\n        if (isAppealTaskOpen(incompleteTasks[i], currentPhase)) {\n          // We are in appeal or confirm and only need to generate a single task\n          // (rather than one per juror) if the task is still open\n          openTasks.push({\n            number: incompleteTasks[i].number,\n            state: incompleteTasks[i].state,\n            createdAt: incompleteTasks[i].createdAt,\n            juror: 'Anyone',\n            disputeId: incompleteTasks[i].dispute.id,\n            phase: getTaskActionString(currentPhase),\n            phaseType: currentPhase,\n            dueDate: nextTransition\n          });\n        }\n      }\n    }\n\n    return openTasks; // Since we are using our own generated cache key we don't need to add the convertedTasks to the dependency list.\n  }, [convertedTasksPhasesKey, incompleteTasks]); // eslint-disable-line react-hooks/exhaustive-deps\n}\n\nfunction isAppealTaskOpen(round, currentPhase) {\n  if (currentPhase === DisputePhase.AppealRuling) {\n    return !round.appeal;\n  }\n\n  if (currentPhase === DisputePhase.ConfirmAppeal) {\n    var _round$appeal;\n\n    if (round === null || round === void 0 ? void 0 : (_round$appeal = round.appeal) === null || _round$appeal === void 0 ? void 0 : _round$appeal.opposedRuling) {\n      return Number(round.appeal.opposedRuling) === 0;\n    }\n\n    return true;\n  }\n}\n\nfunction isVotingTaskOpen(draft, currentPhase) {\n  if (currentPhase === DisputePhase.VotingPeriod) {\n    return !draft.commitment;\n  }\n\n  if (currentPhase === DisputePhase.RevealVote) {\n    if (draft.outcome || !draft.commitment) {\n      return false;\n    }\n\n    return true;\n  }\n}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useTasks.js"],"names":["useMemo","useCourtClock","useCourtConfig","useTasksSubscription","getTermEndTime","getAdjudicationPhase","convertToString","getTaskActionString","Phase","DisputePhase","getVoidedDisputesByCourt","useTasks","courtConfig","currentTermId","tasks","fetching","error","openTasks","useOpenTasks","voidedDisputes","convertedTasks","map","task","dispute","convertedTasksPhasesKey","phase","join","incompleteTasks","filter","has","id","Ended","i","length","currentPhase","nextTransition","phaseEndTerm","AppealRuling","ConfirmAppeal","j","jurors","isVotingTaskOpen","push","number","state","createdAt","juror","disputeId","commitment","outcome","phaseType","dueDate","isAppealTaskOpen","round","appeal","opposedRuling","Number","draft","VotingPeriod","RevealVote"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\nimport { useCourtClock } from '../providers/CourtClock'\nimport { useCourtConfig } from '../providers/CourtConfig'\nimport { useTasksSubscription } from './subscription-hooks'\n\nimport { getTermEndTime } from '../utils/court-utils'\nimport { getAdjudicationPhase } from '../utils/dispute-utils'\nimport {\n  convertToString,\n  getTaskActionString,\n  Phase as DisputePhase,\n} from '../types/dispute-status-types'\nimport { getVoidedDisputesByCourt } from '../flagged-disputes/voided-disputes'\n\nexport default function useTasks() {\n  const courtConfig = useCourtConfig()\n  const { currentTermId } = useCourtClock()\n  const { tasks, fetching, error } = useTasksSubscription()\n\n  const openTasks = useOpenTasks(tasks, currentTermId, courtConfig)\n\n  return { openTasks, fetching, error }\n}\n\nfunction useOpenTasks(tasks, currentTermId, courtConfig) {\n  const voidedDisputes = getVoidedDisputesByCourt()\n  const convertedTasks = useMemo(() => {\n    if (!tasks) {\n      return null\n    }\n    return tasks.map(task => ({\n      ...task,\n      ...getAdjudicationPhase(task.dispute, task, currentTermId, courtConfig),\n    }))\n  }, [courtConfig, currentTermId, tasks])\n\n  const convertedTasksPhasesKey = convertedTasks\n    ? convertedTasks.map(phase => convertToString(phase.phase)).join('')\n    : null\n\n  const incompleteTasks = useMemo(() => {\n    if (!convertedTasks) {\n      return null\n    }\n    return convertedTasks.filter(\n      task =>\n        !voidedDisputes.has(task.dispute.id) &&\n        task.phase !== DisputePhase.Ended\n    )\n  }, [convertedTasksPhasesKey, voidedDisputes]) // eslint-disable-line react-hooks/exhaustive-deps\n\n  return useMemo(() => {\n    if (!convertedTasks) {\n      return []\n    }\n    const openTasks = []\n\n    for (let i = 0; i < incompleteTasks.length; i++) {\n      const currentPhase = incompleteTasks[i].phase\n      const nextTransition = getTermEndTime(\n        incompleteTasks[i].phaseEndTerm,\n        courtConfig\n      )\n\n      if (\n        currentPhase !== DisputePhase.AppealRuling &&\n        currentPhase !== DisputePhase.ConfirmAppeal\n      ) {\n        for (let j = 0; j < incompleteTasks[i].jurors.length; j++) {\n          if (isVotingTaskOpen(incompleteTasks[i].jurors[j], currentPhase)) {\n            openTasks.push({\n              number: incompleteTasks[i].number,\n              state: incompleteTasks[i].state,\n              createdAt: incompleteTasks[i].createdAt,\n              juror: incompleteTasks[i].jurors[j].juror.id,\n              disputeId: incompleteTasks[i].dispute.id,\n              commitment: incompleteTasks[i].jurors[j].commitment,\n              outcome: incompleteTasks[i].jurors[j].outcome,\n              phase: getTaskActionString(currentPhase),\n              phaseType: currentPhase,\n              dueDate: nextTransition,\n            })\n          }\n        }\n      } else {\n        if (isAppealTaskOpen(incompleteTasks[i], currentPhase)) {\n          // We are in appeal or confirm and only need to generate a single task\n          // (rather than one per juror) if the task is still open\n          openTasks.push({\n            number: incompleteTasks[i].number,\n            state: incompleteTasks[i].state,\n            createdAt: incompleteTasks[i].createdAt,\n            juror: 'Anyone',\n            disputeId: incompleteTasks[i].dispute.id,\n            phase: getTaskActionString(currentPhase),\n            phaseType: currentPhase,\n            dueDate: nextTransition,\n          })\n        }\n      }\n    }\n    return openTasks\n    // Since we are using our own generated cache key we don't need to add the convertedTasks to the dependency list.\n  }, [convertedTasksPhasesKey, incompleteTasks]) // eslint-disable-line react-hooks/exhaustive-deps\n}\n\nfunction isAppealTaskOpen(round, currentPhase) {\n  if (currentPhase === DisputePhase.AppealRuling) {\n    return !round.appeal\n  }\n  if (currentPhase === DisputePhase.ConfirmAppeal) {\n    if (round?.appeal?.opposedRuling) {\n      return Number(round.appeal.opposedRuling) === 0\n    }\n\n    return true\n  }\n}\n\nfunction isVotingTaskOpen(draft, currentPhase) {\n  if (currentPhase === DisputePhase.VotingPeriod) {\n    return !draft.commitment\n  }\n  if (currentPhase === DisputePhase.RevealVote) {\n    if (draft.outcome || !draft.commitment) {\n      return false\n    }\n    return true\n  }\n}\n"]},"metadata":{},"sourceType":"module"}