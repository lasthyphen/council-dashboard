{"ast":null,"code":"import _toConsumableArray from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _regeneratorRuntime from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useCallback,useEffect,useRef,useState}from'react';import{ipfsGet,getIpfsCidFromUri}from'../lib/ipfs-utils';import{ERROR_TYPES}from'../types/evidences-status-types';export default function useEvidences(dispute,rawEvidences){// Contains valid evidences + errored evidences\nvar _useState=useState([]),_useState2=_slicedToArray(_useState,2),evidences=_useState2[0],setEvidences=_useState2[1];var _useState3=useState(true),_useState4=_slicedToArray(_useState3,2),fetchingEvidences=_useState4[0],setFetchingEvidences=_useState4[1];// Contains valid evidences only\nvar evidencesCache=useRef(new Map());// Fetch an evidence data from IPFS if needed, prepares the evidence object,\n// and cache it if valid. If invalid, returns an errored evidence object.\nvar fetchEvidence=useCallback(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(rawEvidence){var id,uriOrData,submitter,createdAt,baseEvidence,cid,_ref2,data,error,evidenceProcessed;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:id=rawEvidence.id,uriOrData=rawEvidence.data,submitter=rawEvidence.submitter,createdAt=rawEvidence.createdAt;if(!evidencesCache.current.has(id)){_context.next=3;break;}return _context.abrupt(\"return\",evidencesCache.current.get(id));case 3:baseEvidence={id:id,rawMetadata:uriOrData,metadata:null,defendant:'',agreementText:'',submitter:submitter,createdAt:createdAt,error:false};cid=getIpfsCidFromUri(uriOrData);// Not an IPFS URI\nif(cid){_context.next=8;break;}evidencesCache.current.set(id,_objectSpread({},baseEvidence,{metadata:uriOrData}));return _context.abrupt(\"return\",evidencesCache.current.get(id));case 8:_context.next=10;return ipfsGet(cid);case 10:_ref2=_context.sent;data=_ref2.data;error=_ref2.error;if(!error){_context.next=15;break;}return _context.abrupt(\"return\",_objectSpread({},baseEvidence,{error:ERROR_TYPES.ERROR_FETCHING_IPFS}));case 15:evidenceProcessed=_objectSpread({},baseEvidence,{metadata:data});evidencesCache.current.set(id,evidenceProcessed);return _context.abrupt(\"return\",evidenceProcessed);case 18:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}(),[]);useEffect(function(){var cancelled=false;var updateEvidences=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(){return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return Promise.all(rawEvidences.map(/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(rawEvidence){var _dispute$disputable;var evidence;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return fetchEvidence(rawEvidence);case 2:evidence=_context2.sent;if(!(cancelled||// First evidence submitted by defendant is treated as the dispute description\nevidence.rawMetadata===((_dispute$disputable=dispute.disputable)===null||_dispute$disputable===void 0?void 0:_dispute$disputable.actionContext))){_context2.next=5;break;}return _context2.abrupt(\"return\");case 5:setEvidences(function(){// already there\nif(evidences.findIndex(function(_evidence){return _evidence.id===evidence.id;})>-1){return evidences;}return[].concat(_toConsumableArray(evidences),[evidence]).sort(function(evidenceA,evidenceB){return evidenceA.createdAt-evidenceB.createdAt;});});case 6:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref4.apply(this,arguments);};}()));case 2:setFetchingEvidences(false);case 3:case\"end\":return _context3.stop();}}},_callee3);}));return function updateEvidences(){return _ref3.apply(this,arguments);};}();updateEvidences();return function(){cancelled=true;};},[dispute.disputable,evidences,fetchEvidence,rawEvidences]);return[evidences,fetchingEvidences];}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useEvidences.js"],"names":["useCallback","useEffect","useRef","useState","ipfsGet","getIpfsCidFromUri","ERROR_TYPES","useEvidences","dispute","rawEvidences","evidences","setEvidences","fetchingEvidences","setFetchingEvidences","evidencesCache","Map","fetchEvidence","rawEvidence","id","uriOrData","data","submitter","createdAt","current","has","get","baseEvidence","rawMetadata","metadata","defendant","agreementText","error","cid","set","ERROR_FETCHING_IPFS","evidenceProcessed","cancelled","updateEvidences","Promise","all","map","evidence","disputable","actionContext","findIndex","_evidence","sort","evidenceA","evidenceB"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react'\nimport { ipfsGet, getIpfsCidFromUri } from '../lib/ipfs-utils'\nimport { ERROR_TYPES } from '../types/evidences-status-types'\n\nexport default function useEvidences(dispute, rawEvidences) {\n  // Contains valid evidences + errored evidences\n  const [evidences, setEvidences] = useState([])\n  const [fetchingEvidences, setFetchingEvidences] = useState(true)\n\n  // Contains valid evidences only\n  const evidencesCache = useRef(new Map())\n\n  // Fetch an evidence data from IPFS if needed, prepares the evidence object,\n  // and cache it if valid. If invalid, returns an errored evidence object.\n  const fetchEvidence = useCallback(async rawEvidence => {\n    const { id, data: uriOrData, submitter, createdAt } = rawEvidence\n\n    if (evidencesCache.current.has(id)) {\n      return evidencesCache.current.get(id)\n    }\n\n    const baseEvidence = {\n      id,\n      rawMetadata: uriOrData,\n      metadata: null,\n      defendant: '',\n      agreementText: '',\n      submitter,\n      createdAt,\n      error: false,\n    }\n\n    const cid = getIpfsCidFromUri(uriOrData)\n\n    // Not an IPFS URI\n    if (!cid) {\n      evidencesCache.current.set(id, { ...baseEvidence, metadata: uriOrData })\n      return evidencesCache.current.get(id)\n    }\n\n    const { data, error } = await ipfsGet(cid)\n\n    if (error) {\n      return { ...baseEvidence, error: ERROR_TYPES.ERROR_FETCHING_IPFS }\n    }\n\n    const evidenceProcessed = {\n      ...baseEvidence,\n      metadata: data,\n    }\n    evidencesCache.current.set(id, evidenceProcessed)\n\n    return evidenceProcessed\n  }, [])\n\n  useEffect(() => {\n    let cancelled = false\n\n    const updateEvidences = async () => {\n      await Promise.all(\n        rawEvidences.map(async rawEvidence => {\n          const evidence = await fetchEvidence(rawEvidence)\n          if (\n            cancelled ||\n            // First evidence submitted by defendant is treated as the dispute description\n            evidence.rawMetadata === dispute.disputable?.actionContext\n          ) {\n            return\n          }\n          setEvidences(() => {\n            // already there\n            if (\n              evidences.findIndex(_evidence => _evidence.id === evidence.id) >\n              -1\n            ) {\n              return evidences\n            }\n\n            return [...evidences, evidence].sort(\n              (evidenceA, evidenceB) =>\n                evidenceA.createdAt - evidenceB.createdAt\n            )\n          })\n        })\n      )\n      setFetchingEvidences(false)\n    }\n\n    updateEvidences()\n\n    return () => {\n      cancelled = true\n    }\n  }, [dispute.disputable, evidences, fetchEvidence, rawEvidences])\n\n  return [evidences, fetchingEvidences]\n}\n"]},"metadata":{},"sourceType":"module"}