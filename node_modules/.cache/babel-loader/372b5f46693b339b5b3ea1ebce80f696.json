{"ast":null,"code":"import { ethers } from 'ethers';\nimport { addressesEqual, includesAddress, ANY_ENTITY } from '../address';\nimport { isFullMethodSignature } from '../app';\nimport { encodeCallScript } from '../callScript';\nimport { canForward } from '../forwarding';\nimport { createDirectTransactionForApp, createForwarderTransactionBuilder, buildForwardingFeePretransaction } from '../transactions';\n\nfunction validateMethod(destination, methodSignature, destinationApp) {\n  const methods = destinationApp.intents;\n\n  if (!methods) {\n    throw new Error(`No functions specified in artifact for ${destination}`);\n  } // Find the relevant method information\n\n\n  const method = methods.find(method => isFullMethodSignature(methodSignature) ? method.sig === methodSignature : // If the full signature isn't given, just select the first overload declared\n  method.sig.split('(')[0] === methodSignature);\n\n  if (!method) {\n    throw new Error(`No method named ${methodSignature} on ${destination}`);\n  }\n\n  return method;\n}\n/**\n * Calculate the forwarding path for a transaction to `destination`\n * that invokes `directTransaction`.\n *\n */\n\n\nasync function calculateForwardingPath(sender, directTransaction, forwardersWithPermission, forwarders, provider) {\n  // No forwarders can perform the requested action\n  if (forwardersWithPermission.length === 0) {\n    return {\n      path: []\n    };\n  }\n\n  const createForwarderTransaction = createForwarderTransactionBuilder(sender, directTransaction); // Check if one of the forwarders that has permission to perform an action\n  // with `sig` on `address` can forward for us directly\n\n  for (const forwarder of forwardersWithPermission) {\n    const script = encodeCallScript([directTransaction]);\n\n    if (await canForward(forwarder, sender, script, provider)) {\n      const transaction = createForwarderTransaction(forwarder, script);\n\n      try {\n        const forwardingFeePretransaction = await buildForwardingFeePretransaction(transaction, provider); // If that happens, we give up as we should've been able to perform the action with this\n        // forwarder\n\n        return {\n          forwardingFeePretransaction,\n          path: [transaction, directTransaction]\n        };\n      } catch (err) {\n        return {\n          path: []\n        };\n      }\n    }\n  } // Get a list of all forwarders (excluding the forwarders with direct permission)\n\n\n  const filterForwarders = forwarders.filter(forwarder => !includesAddress(forwardersWithPermission, forwarder)); // Set up the path finding queue\n  // The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>\n  // In other words: it is an array of tuples, where the first index of the tuple\n  // is the current path and the second index of the tuple is the\n  // queue (a list of unexplored forwarder addresses) for that path\n\n  const queue = forwardersWithPermission.map(forwarderWithPermission => {\n    // TODO: Fix types (type queue = [DirectTransaction[], string[]][])\n    return [[createForwarderTransaction(forwarderWithPermission, encodeCallScript([directTransaction])), directTransaction], filterForwarders];\n  }); // Find the shortest path via a breadth-first search of forwarder paths.\n  // We do a breadth-first instead of depth-first search because:\n  //   - We assume that most forwarding paths will be quite short, so it should be faster\n  //     to check in \"stages\" rather than exhaust single paths\n  //   - We don't currently protect against cycles in the path, and so exhausting single\n  //     paths can be wasteful if they result in dead ends\n  // TODO: We should find and return multiple paths\n\n  do {\n    const [path, [forwarder, ...nextQueue]] = queue.shift(); // Skip if no forwarder or the path is longer than 5\n\n    if (!forwarder || path.length > 5) continue; // Get the previous forwarder address\n\n    const previousForwarder = path[0].to; // Encode the previous transaction into an EVM callscript\n\n    const script = encodeCallScript([path[0]]);\n\n    if (await canForward(previousForwarder, forwarder, script, provider)) {\n      if (await canForward(forwarder, sender, script, provider)) {\n        // The previous forwarder can forward a transaction for this forwarder,\n        // and this forwarder can forward for our address, so we have found a path\n        const transaction = createForwarderTransaction(forwarder, script); // Only apply pretransactions to the first transaction in the path\n        // as it's the only one that will be executed by the user\n\n        try {\n          const forwardingFeePretransaction = await buildForwardingFeePretransaction(transaction, provider); // If that happens, we give up as we should've been able to perform the action with this\n          // forwarding path\n\n          return {\n            forwardingFeePretransaction,\n            path: [transaction, ...path]\n          };\n        } catch (err) {\n          return {\n            path: []\n          };\n        }\n      } else {\n        // The previous forwarder can forward a transaction for this forwarder,\n        // but this forwarder can not forward for our address, so we add it as a\n        // possible path in the queue for later exploration.\n        queue.push([[createForwarderTransaction(forwarder, script), ...path], // Avoid including the current forwarder as a candidate for the next step\n        // in the path. Note that this is naive and may result in repeating cycles,\n        // but the maximum path length would prevent against infinite loops\n        forwarders.filter(nextForwarder => nextForwarder !== forwarder)]);\n      }\n    } // We add the current path on the back of the queue again, but we shorten\n    // the list of possible forwarders.\n\n\n    queue.push([path, nextQueue]);\n  } while (queue.length);\n\n  return {\n    path: []\n  };\n}\n/**\n * Calculate the transaction path for a transaction to `destination`\n * that invokes `methodSignature` with `params`.\n *\n */\n\n\nexport async function calculateTransactionPath(sender, destination, methodSignature, params, apps, provider, finalForwarder //Address of the final forwarder that can perfom the action. Needed for actions that aren't in the ACL but whose execution depends on other factors\n) {\n  var _a; // Get the destination app\n\n\n  const destinationApp = apps.find(app => app.address == destination);\n\n  if (!destinationApp) {\n    throw new Error(`Transaction path destination (${destination}) is not an installed app`);\n  } // Make sure the method signature is correct\n\n\n  const method = validateMethod(destination, methodSignature, destinationApp);\n  const finalForwarderProvided = finalForwarder ? ethers.utils.isAddress(finalForwarder) : false;\n  const directTransaction = await createDirectTransactionForApp(sender, destinationApp, method.sig, params); // We can already assume the user is able to directly invoke the action if:\n  //   - The method has no ACL requirements and no final forwarder was given, or\n  //   - The final forwarder matches the sender\n\n  if (method.roles.length === 0 && !finalForwarderProvided || finalForwarder && addressesEqual(finalForwarder, sender)) {\n    try {\n      return {\n        path: [directTransaction]\n      };\n    } catch (_) {\n      // If the direct transaction fails, we give up as we should have been able to\n      // perform the action directly\n      return {\n        path: []\n      };\n    }\n  } // Failing this, attempt transaction pathing algorithm with forwarders\n\n\n  const forwarders = apps.filter(app => app.isForwarder === true).map(app => app.address);\n  let forwardersWithPermission = [];\n\n  if (finalForwarderProvided) {\n    if (finalForwarder) {\n      if (!includesAddress(forwarders, finalForwarder)) {\n        // Final forwarder was given, but did not match any available forwarders, so no path\n        // could be found\n        return {\n          path: []\n        };\n      } // Only attempt to find path with declared final forwarder; assume the final forwarder\n      // is able to invoke the action\n\n\n      forwardersWithPermission = [finalForwarder];\n    }\n  } else {\n    // Find entities with the required permissions\n    const role = (await destinationApp.roles()).find(role => role.name === method.roles[0]);\n    const allowedEntities = ((_a = role === null || role === void 0 ? void 0 : role.permissions) === null || _a === void 0 ? void 0 : _a.map(permission => permission.granteeAddress)) || []; // No one has access, so of course we don't as well\n\n    if (allowedEntities.length === 0) {\n      return {\n        path: []\n      };\n    } // User may have permission; attempt direct transaction\n\n\n    if (includesAddress(allowedEntities, sender) || includesAddress(allowedEntities, ANY_ENTITY)) {\n      try {\n        return {\n          path: [directTransaction]\n        };\n      } catch (_) {// Don't immediately fail as the permission could have parameters applied that\n        // disallows the user from the current action and forces us to use the full\n        // pathing algorithm\n      }\n    } // Find forwarders with permission to perform the action\n\n\n    forwardersWithPermission = forwarders.filter(forwarder => includesAddress(allowedEntities, forwarder));\n  }\n\n  return calculateForwardingPath(sender, directTransaction, forwardersWithPermission, forwarders, provider);\n}","map":null,"metadata":{},"sourceType":"module"}