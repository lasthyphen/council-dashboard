{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkProvider = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst util_1 = require(\"../util\");\n\nconst eth_eip712_util_1 = __importDefault(require(\"../vendor-js/eth-eip712-util\"));\n\nconst FilterPolyfill_1 = require(\"./FilterPolyfill\");\n\nconst JSONRPC_1 = require(\"./JSONRPC\");\n\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\n\nconst SubscriptionManager_1 = require(\"./SubscriptionManager\");\n\nconst EthereumChain_1 = require(\"../EthereumChain\");\n\nconst LOCAL_STORAGE_ADDRESSES_KEY = \"Addresses\";\nconst DEFAULT_CHAIN_ID_KEY = \"DefaultChainId\"; // Indicates chain has been switched by switchEthereumChain or addEthereumChain request\n\nconst HAS_CHAIN_BEEN_SWITCHED_KEY = \"HasChainBeenSwitched\";\n\nclass WalletLinkProvider extends safe_event_emitter_1.default {\n  constructor(options) {\n    super();\n    this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);\n    this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);\n    this._relay = null;\n    this._addresses = [];\n    this.hasMadeFirstChainChangedEmission = false; // true if mobile client has sent message to override jsonRpcUrl+chainId\n\n    this.isChainOverridden = false;\n    this._send = this.send;\n    this._sendAsync = this.sendAsync;\n    this.setProviderInfo = this.setProviderInfo.bind(this);\n    this.updateProviderInfo = this.updateProviderInfo.bind(this);\n    this.getChainId = this.getChainId.bind(this);\n    this.setAppInfo = this.setAppInfo.bind(this);\n    this.enable = this.enable.bind(this);\n    this.close = this.close.bind(this);\n    this.send = this.send.bind(this);\n    this.sendAsync = this.sendAsync.bind(this);\n    this.request = this.request.bind(this);\n    this._setAddresses = this._setAddresses.bind(this);\n    this.scanQRCode = this.scanQRCode.bind(this);\n    this.arbitraryRequest = this.arbitraryRequest.bind(this);\n    this.childRequestEthereumAccounts = this.childRequestEthereumAccounts.bind(this);\n    this._jsonRpcUrl = options.jsonRpcUrl;\n    this._overrideIsMetaMask = options.overrideIsMetaMask;\n    this._relayProvider = options.relayProvider;\n    this._storage = options.storage;\n    this._relayEventManager = options.relayEventManager;\n    const chainId = this.getChainId();\n    const chainIdStr = util_1.prepend0x(chainId.toString(16)); // indicate that we've connected, for EIP-1193 compliance\n\n    this.emit(\"connect\", {\n      chainIdStr\n    });\n\n    const cachedAddresses = this._storage.getItem(LOCAL_STORAGE_ADDRESSES_KEY);\n\n    if (cachedAddresses) {\n      const addresses = cachedAddresses.split(\" \");\n\n      if (addresses[0] !== \"\") {\n        this._addresses = addresses;\n        this.emit(\"accountsChanged\", addresses);\n      }\n    }\n\n    this._subscriptionManager.events.on(\"notification\", notification => {\n      this.emit(\"message\", {\n        type: notification.method,\n        data: notification.params\n      });\n    });\n\n    if (this._addresses.length > 0) {\n      this.initializeRelay();\n    }\n  }\n\n  get selectedAddress() {\n    return this._addresses[0] || undefined;\n  }\n\n  get networkVersion() {\n    return this.getChainId().toString(10);\n  }\n\n  get chainId() {\n    return util_1.prepend0x(this.getChainId().toString(16));\n  }\n\n  get isWalletLink() {\n    return true;\n  }\n  /**\n   * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return\n   * true for this method.\n   */\n\n\n  get isMetaMask() {\n    return this._overrideIsMetaMask;\n  }\n\n  get host() {\n    return this._jsonRpcUrl;\n  }\n\n  get connected() {\n    return true;\n  }\n\n  isConnected() {\n    return true;\n  } // @ts-ignore\n\n\n  setProviderInfo(jsonRpcUrl, chainId) {\n    if (this.isChainOverridden) return;\n    this.updateProviderInfo(jsonRpcUrl, this.getChainId(), false);\n  }\n\n  updateProviderInfo(jsonRpcUrl, chainId, fromRelay) {\n    const hasChainSwitched = this._storage.getItem(HAS_CHAIN_BEEN_SWITCHED_KEY) === \"true\";\n    if (hasChainSwitched && fromRelay) return;\n\n    if (fromRelay) {\n      this.isChainOverridden = true;\n    }\n\n    this._jsonRpcUrl = jsonRpcUrl; // emit chainChanged event if necessary\n\n    const originalChainId = this.getChainId();\n\n    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));\n\n    const chainChanged = util_1.ensureIntNumber(chainId) !== originalChainId;\n\n    if (chainChanged || !this.hasMadeFirstChainChangedEmission) {\n      this.emit(\"chainChanged\", this.getChainId());\n      this.hasMadeFirstChainChangedEmission = true;\n    }\n  }\n\n  async switchEthereumChain(rpcUrl, chainId) {\n    if (util_1.ensureIntNumber(chainId) === this.getChainId()) {\n      return;\n    }\n\n    const relay = await this.initializeRelay();\n    const res = await relay.switchEthereumChain(chainId.toString(10));\n\n    if (res.result === true) {\n      this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, \"true\");\n\n      this.updateProviderInfo(rpcUrl, chainId, false);\n    }\n  }\n\n  setAppInfo(appName, appLogoUrl) {\n    this.initializeRelay().then(relay => relay.setAppInfo(appName, appLogoUrl));\n  }\n\n  async enable() {\n    if (this._addresses.length > 0) {\n      return this._addresses;\n    }\n\n    return await this._send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);\n  }\n\n  close() {\n    this.initializeRelay().then(relay => relay.resetAndReload());\n  }\n\n  send(requestOrMethod, callbackOrParams) {\n    // send<T>(method, params): Promise<T>\n    if (typeof requestOrMethod === \"string\") {\n      const method = requestOrMethod;\n      const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== undefined ? [callbackOrParams] : [];\n      const request = {\n        jsonrpc: \"2.0\",\n        id: 0,\n        method,\n        params\n      };\n      return this._sendRequestAsync(request).then(res => res.result);\n    } // send(JSONRPCRequest | JSONRPCRequest[], callback): void\n\n\n    if (typeof callbackOrParams === \"function\") {\n      const request = requestOrMethod;\n      const callback = callbackOrParams;\n      return this._sendAsync(request, callback);\n    } // send(JSONRPCRequest[]): JSONRPCResponse[]\n\n\n    if (Array.isArray(requestOrMethod)) {\n      const requests = requestOrMethod;\n      return requests.map(r => this._sendRequest(r));\n    } // send(JSONRPCRequest): JSONRPCResponse\n\n\n    const req = requestOrMethod;\n    return this._sendRequest(req);\n  }\n\n  sendAsync(request, callback) {\n    if (typeof callback !== \"function\") {\n      throw new Error(\"callback is required\");\n    } // send(JSONRPCRequest[], callback): void\n\n\n    if (Array.isArray(request)) {\n      const arrayCb = callback;\n\n      this._sendMultipleRequestsAsync(request).then(responses => arrayCb(null, responses)).catch(err => arrayCb(err, null));\n\n      return;\n    } // send(JSONRPCRequest, callback): void\n\n\n    const cb = callback;\n\n    this._sendRequestAsync(request).then(response => cb(null, response)).catch(err => cb(err, null));\n  }\n\n  async request(args) {\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n        message: \"Expected a single, non-array, object argument.\",\n        data: args\n      });\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n        message: \"'args.method' must be a non-empty string.\",\n        data: args\n      });\n    }\n\n    if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n      throw eth_rpc_errors_1.ethErrors.rpc.invalidRequest({\n        message: \"'args.params' must be an object or array if provided.\",\n        data: args\n      });\n    }\n\n    const newParams = params === undefined ? [] : params; // WalletLink Requests\n\n    const id = this._relayEventManager.makeRequestId();\n\n    const result = await this._sendRequestAsync({\n      method,\n      params: newParams,\n      jsonrpc: \"2.0\",\n      id\n    });\n    return result.result;\n  }\n\n  async scanQRCode(match) {\n    const relay = await this.initializeRelay();\n    const res = await relay.scanQRCode(util_1.ensureRegExpString(match));\n\n    if (typeof res.result !== \"string\") {\n      throw new Error(\"result was not a string\");\n    }\n\n    return res.result;\n  }\n\n  async arbitraryRequest(data) {\n    const relay = await this.initializeRelay();\n    const res = await relay.arbitraryRequest(data);\n\n    if (typeof res.result !== \"string\") {\n      throw new Error(\"result was not a string\");\n    }\n\n    return res.result;\n  }\n\n  async childRequestEthereumAccounts(childSessionId, childSessionSecret, dappName, dappLogoURL, dappURL) {\n    const relay = await this.initializeRelay();\n    await relay.childRequestEthereumAccounts(childSessionId, childSessionSecret, dappName, dappLogoURL, dappURL);\n    return true;\n  }\n\n  supportsSubscriptions() {\n    return false;\n  }\n\n  subscribe() {\n    throw new Error(\"Subscriptions are not supported\");\n  }\n\n  unsubscribe() {\n    throw new Error(\"Subscriptions are not supported\");\n  }\n\n  disconnect() {\n    return true;\n  }\n\n  _sendRequest(request) {\n    const response = {\n      jsonrpc: \"2.0\",\n      id: request.id\n    };\n    const {\n      method\n    } = request;\n    response.result = this._handleSynchronousMethods(request);\n\n    if (response.result === undefined) {\n      throw new Error(`WalletLink does not support calling ${method} synchronously without ` + `a callback. Please provide a callback parameter to call ${method} ` + `asynchronously.`);\n    }\n\n    return response;\n  }\n\n  _setAddresses(addresses) {\n    if (!Array.isArray(addresses)) {\n      throw new Error(\"addresses is not an array\");\n    }\n\n    const newAddresses = addresses.map(address => util_1.ensureAddressString(address));\n\n    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {\n      return;\n    }\n\n    this._addresses = newAddresses;\n    this.emit(\"accountsChanged\", this._addresses);\n\n    this._storage.setItem(LOCAL_STORAGE_ADDRESSES_KEY, addresses.join(\" \"));\n\n    window.dispatchEvent(new CustomEvent(\"walletlink:addresses\", {\n      detail: this._addresses\n    }));\n  }\n\n  _sendRequestAsync(request) {\n    return new Promise((resolve, reject) => {\n      try {\n        const syncResult = this._handleSynchronousMethods(request);\n\n        if (syncResult !== undefined) {\n          return resolve({\n            jsonrpc: \"2.0\",\n            id: request.id,\n            result: syncResult\n          });\n        }\n\n        const filterPromise = this._handleAsynchronousFilterMethods(request);\n\n        if (filterPromise !== undefined) {\n          filterPromise.then(res => resolve(Object.assign(Object.assign({}, res), {\n            id: request.id\n          }))).catch(err => reject(err));\n          return;\n        }\n\n        const subscriptionPromise = this._handleSubscriptionMethods(request);\n\n        if (subscriptionPromise !== undefined) {\n          subscriptionPromise.then(res => resolve({\n            jsonrpc: \"2.0\",\n            id: request.id,\n            result: res.result\n          })).catch(err => reject(err));\n          return;\n        }\n      } catch (err) {\n        return reject(err);\n      }\n\n      this._handleAsynchronousMethods(request).then(res => resolve(Object.assign(Object.assign({}, res), {\n        id: request.id\n      }))).catch(err => reject(err));\n    });\n  }\n\n  _sendMultipleRequestsAsync(requests) {\n    return Promise.all(requests.map(r => this._sendRequestAsync(r)));\n  }\n\n  _handleSynchronousMethods(request) {\n    const {\n      method\n    } = request;\n    const params = request.params || [];\n\n    switch (method) {\n      case JSONRPC_1.JSONRPCMethod.eth_accounts:\n        return this._eth_accounts();\n\n      case JSONRPC_1.JSONRPCMethod.eth_coinbase:\n        return this._eth_coinbase();\n\n      case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:\n        return this._eth_uninstallFilter(params);\n\n      case JSONRPC_1.JSONRPCMethod.net_version:\n        return this._net_version();\n\n      case JSONRPC_1.JSONRPCMethod.eth_chainId:\n        return this._eth_chainId();\n\n      default:\n        return undefined;\n    }\n  }\n\n  _handleAsynchronousMethods(request) {\n    const {\n      method\n    } = request;\n    const params = request.params || [];\n\n    switch (method) {\n      case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:\n        return this._eth_requestAccounts();\n\n      case JSONRPC_1.JSONRPCMethod.eth_sign:\n        return this._eth_sign(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_ecRecover:\n        return this._eth_ecRecover(params);\n\n      case JSONRPC_1.JSONRPCMethod.personal_sign:\n        return this._personal_sign(params);\n\n      case JSONRPC_1.JSONRPCMethod.personal_ecRecover:\n        return this._personal_ecRecover(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_signTransaction:\n        return this._eth_signTransaction(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:\n        return this._eth_sendRawTransaction(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:\n        return this._eth_sendTransaction(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:\n        return this._eth_signTypedData_v1(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:\n        return this._throwUnsupportedMethodError();\n\n      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:\n        return this._eth_signTypedData_v3(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:\n      case JSONRPC_1.JSONRPCMethod.eth_signTypedData:\n        return this._eth_signTypedData_v4(params);\n\n      case JSONRPC_1.JSONRPCMethod.walletlink_arbitrary:\n        return this._walletlink_arbitrary(params);\n\n      case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:\n        return this._wallet_addEthereumChain(params);\n\n      case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:\n        return this._wallet_switchEthereumChain(params);\n    }\n\n    if (!this._jsonRpcUrl) throw Error(\"Error: No jsonRpcUrl provided\");\n    return window.fetch(this._jsonRpcUrl, {\n      method: \"POST\",\n      body: JSON.stringify(request),\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }).then(res => res.json()).then(json => {\n      if (!json) {\n        throw eth_rpc_errors_1.ethErrors.rpc.parse({});\n      }\n\n      const response = json;\n      const {\n        error\n      } = response;\n\n      if (error) {\n        throw eth_rpc_errors_1.serializeError(error);\n      }\n\n      return response;\n    });\n  }\n\n  _handleAsynchronousFilterMethods(request) {\n    const {\n      method\n    } = request;\n    const params = request.params || [];\n\n    switch (method) {\n      case JSONRPC_1.JSONRPCMethod.eth_newFilter:\n        return this._eth_newFilter(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:\n        return this._eth_newBlockFilter();\n\n      case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:\n        return this._eth_newPendingTransactionFilter();\n\n      case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:\n        return this._eth_getFilterChanges(params);\n\n      case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:\n        return this._eth_getFilterLogs(params);\n    }\n\n    return undefined;\n  }\n\n  _handleSubscriptionMethods(request) {\n    switch (request.method) {\n      case JSONRPC_1.JSONRPCMethod.eth_subscribe:\n      case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:\n        return this._subscriptionManager.handleRequest(request);\n    }\n\n    return undefined;\n  }\n\n  _isKnownAddress(addressString) {\n    try {\n      const address = util_1.ensureAddressString(addressString);\n      return this._addresses.includes(address);\n    } catch (_a) {}\n\n    return false;\n  }\n\n  _ensureKnownAddress(addressString) {\n    if (!this._isKnownAddress(addressString)) {\n      throw new Error(\"Unknown Ethereum address\");\n    }\n  }\n\n  _prepareTransactionParams(tx) {\n    const fromAddress = tx.from ? util_1.ensureAddressString(tx.from) : this.selectedAddress;\n\n    if (!fromAddress) {\n      throw new Error(\"Ethereum address is unavailable\");\n    }\n\n    this._ensureKnownAddress(fromAddress);\n\n    const toAddress = tx.to ? util_1.ensureAddressString(tx.to) : null;\n    const weiValue = tx.value != null ? util_1.ensureBN(tx.value) : new bn_js_1.default(0);\n    const data = tx.data ? util_1.ensureBuffer(tx.data) : Buffer.alloc(0);\n    const nonce = tx.nonce != null ? util_1.ensureIntNumber(tx.nonce) : null;\n    const gasPriceInWei = tx.gasPrice != null ? util_1.ensureBN(tx.gasPrice) : null;\n    const maxFeePerGas = tx.maxFeePerGas != null ? util_1.ensureBN(tx.maxFeePerGas) : null;\n    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? util_1.ensureBN(tx.maxPriorityFeePerGas) : null;\n    const gasLimit = tx.gas != null ? util_1.ensureBN(tx.gas) : null;\n    const chainId = this.getChainId();\n    return {\n      fromAddress,\n      toAddress,\n      weiValue,\n      data,\n      nonce,\n      gasPriceInWei,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      gasLimit,\n      chainId\n    };\n  }\n\n  _requireAuthorization() {\n    if (this._addresses.length === 0) {\n      throw eth_rpc_errors_1.ethErrors.provider.unauthorized({});\n    }\n  }\n\n  _throwUnsupportedMethodError() {\n    throw eth_rpc_errors_1.ethErrors.provider.unsupportedMethod({});\n  }\n\n  async _signEthereumMessage(message, address, addPrefix, typedDataJson) {\n    this._ensureKnownAddress(address);\n\n    try {\n      const relay = await this.initializeRelay();\n      const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson);\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: res.result\n      };\n    } catch (err) {\n      if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n        throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(\"User denied message signature\");\n      }\n\n      throw err;\n    }\n  }\n\n  async _ethereumAddressFromSignedMessage(message, signature, addPrefix) {\n    const relay = await this.initializeRelay();\n    const res = await relay.ethereumAddressFromSignedMessage(message, signature, addPrefix);\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: res.result\n    };\n  }\n\n  _eth_accounts() {\n    return this._addresses;\n  }\n\n  _eth_coinbase() {\n    return this.selectedAddress || null;\n  }\n\n  _net_version() {\n    return this.getChainId().toString(10);\n  }\n\n  _eth_chainId() {\n    return util_1.hexStringFromIntNumber(this.getChainId());\n  }\n\n  getChainId() {\n    const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY) || \"1\";\n    const chainId = parseInt(chainIdStr, 10);\n    return util_1.ensureIntNumber(chainId);\n  }\n\n  async _eth_requestAccounts() {\n    if (this._addresses.length > 0) {\n      return Promise.resolve({\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: this._addresses\n      });\n    }\n\n    let res;\n\n    try {\n      const relay = await this.initializeRelay();\n      res = await relay.requestEthereumAccounts();\n    } catch (err) {\n      if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n        throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(\"User denied account authorization\");\n      }\n\n      throw err;\n    }\n\n    if (!res.result) {\n      throw new Error(\"accounts received is empty\");\n    }\n\n    this._setAddresses(res.result);\n\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: this._addresses\n    };\n  }\n\n  _eth_sign(params) {\n    this._requireAuthorization();\n\n    const address = util_1.ensureAddressString(params[0]);\n    const message = util_1.ensureBuffer(params[1]);\n    return this._signEthereumMessage(message, address, false);\n  }\n\n  _eth_ecRecover(params) {\n    const message = util_1.ensureBuffer(params[0]);\n    const signature = util_1.ensureBuffer(params[1]);\n    return this._ethereumAddressFromSignedMessage(message, signature, false);\n  }\n\n  _personal_sign(params) {\n    this._requireAuthorization();\n\n    const message = util_1.ensureBuffer(params[0]);\n    const address = util_1.ensureAddressString(params[1]);\n    return this._signEthereumMessage(message, address, true);\n  }\n\n  _personal_ecRecover(params) {\n    const message = util_1.ensureBuffer(params[0]);\n    const signature = util_1.ensureBuffer(params[1]);\n    return this._ethereumAddressFromSignedMessage(message, signature, true);\n  }\n\n  async _eth_signTransaction(params) {\n    this._requireAuthorization();\n\n    const tx = this._prepareTransactionParams(params[0] || {});\n\n    try {\n      const relay = await this.initializeRelay();\n      const res = await relay.signEthereumTransaction(tx);\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: res.result\n      };\n    } catch (err) {\n      if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n        throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(\"User denied transaction signature\");\n      }\n\n      throw err;\n    }\n  }\n\n  async _eth_sendRawTransaction(params) {\n    const signedTransaction = util_1.ensureBuffer(params[0]);\n    const relay = await this.initializeRelay();\n    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId());\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: res.result\n    };\n  }\n\n  async _eth_sendTransaction(params) {\n    this._requireAuthorization();\n\n    const tx = this._prepareTransactionParams(params[0] || {});\n\n    try {\n      const relay = await this.initializeRelay();\n      const res = await relay.signAndSubmitEthereumTransaction(tx);\n      return {\n        jsonrpc: \"2.0\",\n        id: 0,\n        result: res.result\n      };\n    } catch (err) {\n      if (typeof err.message === \"string\" && err.message.match(/(denied|rejected)/i)) {\n        throw eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(\"User denied transaction signature\");\n      }\n\n      throw err;\n    }\n  }\n\n  async _eth_signTypedData_v1(params) {\n    this._requireAuthorization();\n\n    const typedData = util_1.ensureParsedJSONObject(params[0]);\n    const address = util_1.ensureAddressString(params[1]);\n\n    this._ensureKnownAddress(address);\n\n    const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({\n      data: typedData\n    });\n    const typedDataJSON = JSON.stringify(typedData, null, 2);\n    return this._signEthereumMessage(message, address, false, typedDataJSON);\n  }\n\n  async _eth_signTypedData_v3(params) {\n    this._requireAuthorization();\n\n    const address = util_1.ensureAddressString(params[0]);\n    const typedData = util_1.ensureParsedJSONObject(params[1]);\n\n    this._ensureKnownAddress(address);\n\n    const message = eth_eip712_util_1.default.hashForSignTypedData_v3({\n      data: typedData\n    });\n    const typedDataJSON = JSON.stringify(typedData, null, 2);\n    return this._signEthereumMessage(message, address, false, typedDataJSON);\n  }\n\n  async _eth_signTypedData_v4(params) {\n    this._requireAuthorization();\n\n    const address = util_1.ensureAddressString(params[0]);\n    const typedData = util_1.ensureParsedJSONObject(params[1]);\n\n    this._ensureKnownAddress(address);\n\n    const message = eth_eip712_util_1.default.hashForSignTypedData_v4({\n      data: typedData\n    });\n    const typedDataJSON = JSON.stringify(typedData, null, 2);\n    return this._signEthereumMessage(message, address, false, typedDataJSON);\n  }\n\n  async _walletlink_arbitrary(params) {\n    const data = params[0];\n\n    if (typeof data !== \"string\") {\n      throw new Error(\"parameter must be a string\");\n    }\n\n    const result = await this.arbitraryRequest(data);\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result\n    };\n  }\n\n  async _wallet_addEthereumChain(params) {\n    const request = params[0];\n    const chainIdNumber = parseInt(request.chainId, 16);\n    const ethereumChain = EthereumChain_1.EthereumChain.fromChainId(BigInt(chainIdNumber));\n\n    if (ethereumChain === undefined) {\n      return {\n        jsonrpc: '2.0',\n        id: 0,\n        error: {\n          code: 2,\n          message: `chainId ${request.chainId} not supported`\n        }\n      };\n    }\n\n    const rpcUrl = EthereumChain_1.EthereumChain.rpcUrl(ethereumChain); // @ts-ignore\n\n    await this.switchEthereumChain(rpcUrl, parseInt(request.chainId, 16));\n    return {\n      jsonrpc: '2.0',\n      id: 0,\n      result: null\n    };\n  }\n\n  async _wallet_switchEthereumChain(params) {\n    const request = params[0];\n    const chainIdNumber = parseInt(request.chainId, 16);\n    const ethereumChain = EthereumChain_1.EthereumChain.fromChainId(BigInt(chainIdNumber));\n\n    if (ethereumChain === undefined) {\n      return {\n        jsonrpc: '2.0',\n        id: 0,\n        error: {\n          code: 2,\n          message: `chainId ${request.chainId} not supported`\n        }\n      };\n    }\n\n    const rpcUrl = EthereumChain_1.EthereumChain.rpcUrl(ethereumChain); // @ts-ignore\n\n    await this.switchEthereumChain(rpcUrl, parseInt(request.chainId, 16));\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: null\n    };\n  }\n\n  _eth_uninstallFilter(params) {\n    const filterId = util_1.ensureHexString(params[0]);\n    return this._filterPolyfill.uninstallFilter(filterId);\n  }\n\n  async _eth_newFilter(params) {\n    const param = params[0];\n    const filterId = await this._filterPolyfill.newFilter(param);\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: filterId\n    };\n  }\n\n  async _eth_newBlockFilter() {\n    const filterId = await this._filterPolyfill.newBlockFilter();\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: filterId\n    };\n  }\n\n  async _eth_newPendingTransactionFilter() {\n    const filterId = await this._filterPolyfill.newPendingTransactionFilter();\n    return {\n      jsonrpc: \"2.0\",\n      id: 0,\n      result: filterId\n    };\n  }\n\n  _eth_getFilterChanges(params) {\n    const filterId = util_1.ensureHexString(params[0]);\n    return this._filterPolyfill.getFilterChanges(filterId);\n  }\n\n  _eth_getFilterLogs(params) {\n    const filterId = util_1.ensureHexString(params[0]);\n    return this._filterPolyfill.getFilterLogs(filterId);\n  }\n\n  initializeRelay() {\n    if (this._relay) {\n      return Promise.resolve(this._relay);\n    }\n\n    return this._relayProvider().then(relay => {\n      relay.setAccountsCallback(accounts => this._setAddresses(accounts));\n      relay.setChainIdCallback(chainId => {\n        this.updateProviderInfo(this._jsonRpcUrl, parseInt(chainId, 10), true);\n      });\n      relay.setJsonRpcUrlCallback(jsonRpcUrl => {\n        this.updateProviderInfo(jsonRpcUrl, this.getChainId(), true);\n      });\n      this._relay = relay;\n      return relay;\n    });\n  }\n\n}\n\nexports.WalletLinkProvider = WalletLinkProvider;","map":null,"metadata":{},"sourceType":"script"}