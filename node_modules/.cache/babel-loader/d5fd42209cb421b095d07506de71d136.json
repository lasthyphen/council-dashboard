{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.default = void 0;\n\nvar _ethers = require(\"ethers\"),\n    _token = require(\"./lib/token\"),\n    _formatBN = require(\"./lib/formatBN\"),\n    _default = provider =>\n/**\n* Format token amounts taking decimals into account\n*\n* @param {string} tokenAddress The address of the token\n* @param {*} amount The absolute amount for the token quantity (wei)\n* @param {bool} showSymbol Whether the token symbol will be printed after the amount\n* @param {*} precision The number of decimal places to format to. If set, the precision is always enforced.\n* @return {Promise<radspec/evaluator/TypedValue>}\n*/\nasync (tokenAddress, amount, showSymbol = !0, precision) => {\n  const amountBn = _ethers.BigNumber.from(amount),\n        fixed = !!precision;\n\n  let decimals, symbol;\n  if (tokenAddress === _token.ETH) decimals = _ethers.BigNumber.from(18), showSymbol && (symbol = \"ETH\");else {\n    let token = new _ethers.ethers.Contract(tokenAddress, _token.ERC20_SYMBOL_DECIMALS_ABI, provider);\n    if (decimals = _ethers.BigNumber.from((await token.decimals())), showSymbol) try {\n      symbol = (await token.symbol()) || \"\";\n    } catch (err) {\n      token = new _ethers.ethers.Contract(tokenAddress, _token.ERC20_SYMBOL_BYTES32_ABI, provider), symbol = (await token.symbol()) || \"\", symbol = symbol && _ethers.ethers.utils.toUtf8String(symbol);\n    }\n  }\n  precision = precision || decimals;\n  const formattedAmount = (0, _formatBN.formatBN)(amountBn, (0, _formatBN.tenPow)(decimals), +precision, fixed);\n  return {\n    type: \"string\",\n    value: showSymbol ? `${formattedAmount} ${symbol}` : formattedAmount\n  };\n};\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}