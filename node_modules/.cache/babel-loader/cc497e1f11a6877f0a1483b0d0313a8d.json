{"ast":null,"code":"import { utils as EthersUtils, BigNumber } from 'ethers';\nexport function bigNum(value) {\n  return BigNumber.from(value);\n}\nexport function formatTokenAmount(amount, isIncoming, decimals = 0, displaySign = false) {\n  return (displaySign ? isIncoming ? '+' : '-' : '') + formatUnits(amount, {\n    digits: decimals\n  });\n}\n/**\n * Format a decimal-based number back to a normal number\n *\n * @param {string} value the number\n * @param {number} digits number of decimal places\n * @returns {BN} value converted to it's normal representation\n */\n\nexport function parseUnits(value, digits) {\n  return EthersUtils.parseUnits(value, digits);\n}\n/**\n * Format an amount of units to be displayed.\n *\n * @param {BigNumber} value Amount of units to format.\n * @param {Number} options.digits Amount of digits on the token.\n * @param {Boolean} options.commas Use comma-separated groups.\n * @param {Boolean} options.replaceZeroBy The string to be returned when value is zero.\n * @param {Boolean} options.precision The precision of the resulting number\n * @returns {String} value formatted\n */\n\nexport function formatUnits(value, {\n  digits = 18,\n  commas = true,\n  replaceZeroBy = '0',\n  precision = 2\n} = {}) {\n  if (value.lt(0) || digits < 0) {\n    return '';\n  }\n\n  let valueBeforeCommas = EthersUtils.formatUnits(value.toString(), digits); // Replace 0 by an empty value\n\n  if (valueBeforeCommas === '0.0') {\n    return replaceZeroBy;\n  } // EthersUtils.formatUnits() adds a decimal even when 0, this removes it.\n\n\n  valueBeforeCommas = valueBeforeCommas.replace(/\\.0$/, '');\n  const roundedValue = round(valueBeforeCommas, precision);\n  return commas ? EthersUtils.commify(roundedValue) : roundedValue;\n}\n/**\n * Format an amount of units to be displayed.\n *\n * @param {String} value Value to round\n * @param {Number} precision Rounding precision\n * @returns {String} Value rounded to `precision` decimals\n */\n\nexport function round(value, precision = 2) {\n  let [whole, decimal] = value.split('.');\n  if (!decimal || decimal.length <= precision) return value; // Round and keep the last `precision` digits\n\n  decimal = Math.round(parseInt((decimal || '0').slice(0, precision + 2)) / 100);\n  return `${whole}${decimal ? `.${decimal}` : ''}`;\n}\nconst wordNumbers = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];\nexport function numberToWord(number) {\n  return wordNumbers[number];\n}\nconst ordinalNumbers = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth'];\nexport function numberToOrdinal(number) {\n  return ordinalNumbers[number - 1];\n}\nexport function getPercentage(value, totalValue) {\n  if (!totalValue > 0) return 0;\n  return Math.round(value * 100 / totalValue, 2);\n}\nexport function getPercentageBN(value, totalValue) {\n  const valueAsNumber = Number(EthersUtils.formatUnits(value, 18));\n  const totalValueAsNumber = Number(EthersUtils.formatUnits(totalValue, 18));\n  const PERCENT_BN = 100;\n  if (totalValue.lte(0)) return 0;\n  return valueAsNumber * PERCENT_BN / totalValueAsNumber;\n}\nexport function generateRandomNumber() {\n  const code = BigNumber.from(EthersUtils.randomBytes(32));\n  return code.toHexString().slice(2);\n}\n/**\n * Normalizes a number from another range into a value between 0 and 1.\n *\n * Identical to map(value, low, high, 0, 1)\n * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n * values are often intentional and useful.\n *\n * From Processing.js\n *\n * @param {Number} aNumber The incoming value to be converted\n * @param {Number} low Lower bound of the value's current range\n * @param {Number} high Upper bound of the value's current range\n * @returns {Number} Normalized number\n */\n\nexport function norm(aNumber, low, high) {\n  return (aNumber - low) / (high - low);\n}\n/**\n * Calculates a number between two numbers at a specific increment. The\n * progress parameter is the amount to interpolate between the two values where\n * 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is\n * half-way in between, etc. The lerp function is convenient for creating\n * motion along a straight path and for drawing dotted lines.\n *\n * From Processing.js\n *\n * @param {Number} progress Between 0.0 and 1.0\n * @param {Number} value1 First value\n * @param {Number} value2 Second value\n * @returns {Number} Increment value\n */\n\nexport function lerp(progress, value1, value2) {\n  return (value2 - value1) * progress + value1;\n}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/lib/math-utils.js"],"names":["utils","EthersUtils","BigNumber","bigNum","value","from","formatTokenAmount","amount","isIncoming","decimals","displaySign","formatUnits","digits","parseUnits","commas","replaceZeroBy","precision","lt","valueBeforeCommas","toString","replace","roundedValue","round","commify","whole","decimal","split","length","Math","parseInt","slice","wordNumbers","numberToWord","number","ordinalNumbers","numberToOrdinal","getPercentage","totalValue","getPercentageBN","valueAsNumber","Number","totalValueAsNumber","PERCENT_BN","lte","generateRandomNumber","code","randomBytes","toHexString","norm","aNumber","low","high","lerp","progress","value1","value2"],"mappings":"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","sourcesContent":["import { utils as EthersUtils, BigNumber } from 'ethers'\n\nexport function bigNum(value) {\n  return BigNumber.from(value)\n}\n\nexport function formatTokenAmount(\n  amount,\n  isIncoming,\n  decimals = 0,\n  displaySign = false\n) {\n  return (\n    (displaySign ? (isIncoming ? '+' : '-') : '') +\n    formatUnits(amount, { digits: decimals })\n  )\n}\n\n/**\n * Format a decimal-based number back to a normal number\n *\n * @param {string} value the number\n * @param {number} digits number of decimal places\n * @returns {BN} value converted to it's normal representation\n */\nexport function parseUnits(value, digits) {\n  return EthersUtils.parseUnits(value, digits)\n}\n\n/**\n * Format an amount of units to be displayed.\n *\n * @param {BigNumber} value Amount of units to format.\n * @param {Number} options.digits Amount of digits on the token.\n * @param {Boolean} options.commas Use comma-separated groups.\n * @param {Boolean} options.replaceZeroBy The string to be returned when value is zero.\n * @param {Boolean} options.precision The precision of the resulting number\n * @returns {String} value formatted\n */\nexport function formatUnits(\n  value,\n  { digits = 18, commas = true, replaceZeroBy = '0', precision = 2 } = {}\n) {\n  if (value.lt(0) || digits < 0) {\n    return ''\n  }\n\n  let valueBeforeCommas = EthersUtils.formatUnits(value.toString(), digits)\n\n  // Replace 0 by an empty value\n  if (valueBeforeCommas === '0.0') {\n    return replaceZeroBy\n  }\n\n  // EthersUtils.formatUnits() adds a decimal even when 0, this removes it.\n  valueBeforeCommas = valueBeforeCommas.replace(/\\.0$/, '')\n\n  const roundedValue = round(valueBeforeCommas, precision)\n\n  return commas ? EthersUtils.commify(roundedValue) : roundedValue\n}\n\n/**\n * Format an amount of units to be displayed.\n *\n * @param {String} value Value to round\n * @param {Number} precision Rounding precision\n * @returns {String} Value rounded to `precision` decimals\n */\nexport function round(value, precision = 2) {\n  let [whole, decimal] = value.split('.')\n\n  if (!decimal || decimal.length <= precision) return value\n\n  // Round and keep the last `precision` digits\n  decimal = Math.round(parseInt((decimal || '0').slice(0, precision + 2)) / 100)\n\n  return `${whole}${decimal ? `.${decimal}` : ''}`\n}\n\nconst wordNumbers = [\n  'one',\n  'two',\n  'three',\n  'four',\n  'five',\n  'six',\n  'seven',\n  'eight',\n  'nine',\n]\n\nexport function numberToWord(number) {\n  return wordNumbers[number]\n}\n\nconst ordinalNumbers = [\n  'first',\n  'second',\n  'third',\n  'fourth',\n  'fifth',\n  'sixth',\n  'seventh',\n  'eighth',\n  'ninth',\n]\n\nexport function numberToOrdinal(number) {\n  return ordinalNumbers[number - 1]\n}\n\nexport function getPercentage(value, totalValue) {\n  if (!totalValue > 0) return 0\n\n  return Math.round((value * 100) / totalValue, 2)\n}\n\nexport function getPercentageBN(value, totalValue) {\n  const valueAsNumber = Number(EthersUtils.formatUnits(value, 18))\n  const totalValueAsNumber = Number(EthersUtils.formatUnits(totalValue, 18))\n\n  const PERCENT_BN = 100\n\n  if (totalValue.lte(0)) return 0\n\n  return (valueAsNumber * PERCENT_BN) / totalValueAsNumber\n}\n\nexport function generateRandomNumber() {\n  const code = BigNumber.from(EthersUtils.randomBytes(32))\n  return code.toHexString().slice(2)\n}\n\n/**\n * Normalizes a number from another range into a value between 0 and 1.\n *\n * Identical to map(value, low, high, 0, 1)\n * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n * values are often intentional and useful.\n *\n * From Processing.js\n *\n * @param {Number} aNumber The incoming value to be converted\n * @param {Number} low Lower bound of the value's current range\n * @param {Number} high Upper bound of the value's current range\n * @returns {Number} Normalized number\n */\nexport function norm(aNumber, low, high) {\n  return (aNumber - low) / (high - low)\n}\n\n/**\n * Calculates a number between two numbers at a specific increment. The\n * progress parameter is the amount to interpolate between the two values where\n * 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is\n * half-way in between, etc. The lerp function is convenient for creating\n * motion along a straight path and for drawing dotted lines.\n *\n * From Processing.js\n *\n * @param {Number} progress Between 0.0 and 1.0\n * @param {Number} value1 First value\n * @param {Number} value2 Second value\n * @returns {Number} Increment value\n */\nexport function lerp(progress, value1, value2) {\n  return (value2 - value1) * progress + value1\n}\n"]},"metadata":{},"sourceType":"module"}