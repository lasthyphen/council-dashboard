{"ast":null,"code":"import { useEffect, useMemo, useState } from 'react';\nimport resolvePathname from 'resolve-pathname';\nimport { IPFS_ENDPOINT } from '../endpoints';\nimport { useCourtClock } from '../providers/CourtClock';\nimport { useCourtConfig } from '../providers/CourtConfig';\nimport { useSingleDisputeSubscription, useDisputesSubscription } from './subscription-hooks';\nimport { getPhaseAndTransition } from '../utils/dispute-utils';\nimport { ipfsGet, getIpfsCidFromUri } from '../lib/ipfs-utils';\nimport { convertToString, Status } from '../types/dispute-status-types';\nconst IPFS_ERROR_MSG = 'Error loading content from ipfs';\nexport default function useDisputes() {\n  const courtConfig = useCourtConfig();\n  const {\n    currentTermId\n  } = useCourtClock();\n  const {\n    disputes,\n    fetching,\n    error\n  } = useDisputesSubscription();\n  const disputesPhases = useMemo(() => {\n    if (!disputes) {\n      return null;\n    }\n\n    return disputes.map(d => getPhaseAndTransition(d, currentTermId, courtConfig));\n  }, [courtConfig, currentTermId, disputes]);\n  const disputesPhasesKey = disputesPhases ? disputesPhases.map(v => convertToString(Object.values(v)[0])).join('') : null;\n  return useMemo(() => {\n    if (error) {\n      return {\n        error\n      };\n    }\n\n    if (fetching) {\n      return {\n        fetching\n      };\n    }\n\n    return {\n      disputes: disputes.map((dispute, i) => {\n        return { ...dispute,\n          ...disputesPhases[i]\n        };\n      })\n    };\n  }, [disputesPhases, disputes, disputesPhasesKey, error]); // eslint-disable-line react-hooks/exhaustive-deps\n}\n/**\n * Hook that processes a single dispute data\n * @param {String} disputeId Id of the dispute\n * @returns {Array} Array conformed by the dispute processed data, fetching indicator and an error object from the graph or an ipfs error in that order\n * (the error also indicates if the error is from the graph since we need to handle in a different way\n * in the dispute detail, the timeline can not be displayed if is a graph error but can if the error is from ipfs)\n */\n\nexport function useDispute(disputeId) {\n  const courtConfig = useCourtConfig();\n  const {\n    currentTermId\n  } = useCourtClock();\n  const {\n    dispute,\n    fetching: graphFetching,\n    error: graphError\n  } = useSingleDisputeSubscription(disputeId);\n  const processedDispute = useProcessedDispute(dispute);\n  const disputePhase = getPhaseAndTransition(dispute, currentTermId, courtConfig);\n  const disputePhaseKey = disputePhase ? convertToString(Object.values(disputePhase)[0]) : '';\n  const graphErrorMessage = (graphError === null || graphError === void 0 ? void 0 : graphError.message) || '';\n  const disputeErrorMessage = (processedDispute === null || processedDispute === void 0 ? void 0 : processedDispute.error) || graphErrorMessage;\n  return useMemo(() => {\n    const fetching = graphFetching || dispute && !processedDispute;\n    return [dispute && processedDispute ? { ...processedDispute,\n      ...disputePhase\n    } : null, fetching, disputeErrorMessage ? {\n      message: disputeErrorMessage,\n      fromGraph: Boolean(graphErrorMessage)\n    } : null];\n  }\n  /* eslint-disable react-hooks/exhaustive-deps */\n  , [disputeErrorMessage, disputePhaseKey, graphErrorMessage, graphFetching, processedDispute]\n  /* eslint-enable react-hooks/exhaustive-deps */\n  );\n}\n\nfunction useProcessedDispute(dispute) {\n  const [processedDispute, setProcessedDispute] = useState(null);\n  useEffect(() => {\n    let cancelled = false;\n\n    const processDisputeData = async () => {\n      if (dispute.status === Status.Voided) {\n        return dispute;\n      }\n\n      const disputeData = await getDisputeData(dispute);\n      return { ...dispute,\n        ...disputeData,\n        error: disputeData ? null : IPFS_ERROR_MSG\n      };\n    };\n\n    const processDispute = async () => {\n      if (!dispute) {\n        return;\n      }\n\n      const processedDispute = await processDisputeData();\n\n      if (!cancelled) {\n        setProcessedDispute(processedDispute);\n      }\n    };\n\n    processDispute();\n    return () => {\n      cancelled = true;\n    };\n  }, [dispute]);\n  return processedDispute;\n}\n\nasync function getDisputeData(dispute) {\n  // Dispute is disputable\n  if (dispute.disputable) {\n    return processDisputableData(dispute);\n  } // Dispute is raw dispute\n\n\n  return processRawDisputeData(dispute);\n}\n\nasync function processDisputableData(dispute) {\n  const {\n    agreement,\n    defendant,\n    plaintiff,\n    organization,\n    title\n  } = dispute.disputable;\n  const agreementIpfsCid = getIpfsCidFromUri(agreement);\n  return {\n    agreementText: title,\n    agreementUrl: `${IPFS_ENDPOINT}/${agreementIpfsCid}`,\n    defendant,\n    description: title,\n    organization,\n    plaintiff\n  };\n}\n/**\n * Processes metadata for raw disputes. `metadataUri` contains the IPFS CID which will be fetched and parsed.\n * @param {*} dispute Dispute from which data will be processed.\n * @returns {Object | null} Dispute processed data.\n */\n\n\nasync function processRawDisputeData(dispute) {\n  const {\n    description: disputeDescription,\n    metadataUri\n  } = dispute;\n\n  if (metadataUri) {\n    const ipfsPath = getIpfsCidFromUri(metadataUri);\n\n    if (ipfsPath) {\n      // Fetch IPFS content\n      const {\n        data,\n        error\n      } = await ipfsGet(ipfsPath);\n\n      if (!error) {\n        try {\n          // Parse IPFS content\n          const parsedDisputeData = JSON.parse(data);\n          const agreementText = parsedDisputeData.agreementText.replace(/^.\\//, ''); // Note that in this case, we expect the agreement's location to be relative to the\n          // metadata URI. For example, if the metadataUri is `<cid>/metadata.json`, the agreement's\n          // location would be `<cid>/<agreement>`\n\n          const agreementUrl = agreementText ? resolvePathname(agreementText, `${IPFS_ENDPOINT}/${ipfsPath}`) : '';\n          const {\n            agreementTitle = '',\n            defendant = '',\n            description = disputeDescription,\n            disputedActionRadspec = '',\n            disputedActionText = '',\n            disputedActionURL = '',\n            organization = '',\n            plaintiff = ''\n          } = parsedDisputeData;\n          return {\n            agreementText: agreementTitle || agreementText || '',\n            agreementUrl,\n            defendant,\n            description,\n            disputedActionRadspec,\n            disputedActionText,\n            disputedActionURL,\n            organization,\n            plaintiff\n          };\n        } catch (err) {\n          return {\n            description: data\n          };\n        }\n      }\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useDisputes.js"],"names":["useEffect","useMemo","useState","resolvePathname","IPFS_ENDPOINT","useCourtClock","useCourtConfig","useSingleDisputeSubscription","useDisputesSubscription","getPhaseAndTransition","ipfsGet","getIpfsCidFromUri","convertToString","Status","IPFS_ERROR_MSG","useDisputes","courtConfig","currentTermId","disputes","fetching","error","disputesPhases","map","d","disputesPhasesKey","v","Object","values","join","dispute","i","useDispute","disputeId","graphFetching","graphError","processedDispute","useProcessedDispute","disputePhase","disputePhaseKey","graphErrorMessage","message","disputeErrorMessage","fromGraph","Boolean","setProcessedDispute","cancelled","processDisputeData","status","Voided","disputeData","getDisputeData","processDispute","disputable","processDisputableData","processRawDisputeData","agreement","defendant","plaintiff","organization","title","agreementIpfsCid","agreementText","agreementUrl","description","disputeDescription","metadataUri","ipfsPath","data","parsedDisputeData","JSON","parse","replace","agreementTitle","disputedActionRadspec","disputedActionText","disputedActionURL","err"],"mappings":"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","sourcesContent":["import { useEffect, useMemo, useState } from 'react'\nimport resolvePathname from 'resolve-pathname'\nimport { IPFS_ENDPOINT } from '../endpoints'\nimport { useCourtClock } from '../providers/CourtClock'\nimport { useCourtConfig } from '../providers/CourtConfig'\nimport {\n  useSingleDisputeSubscription,\n  useDisputesSubscription,\n} from './subscription-hooks'\nimport { getPhaseAndTransition } from '../utils/dispute-utils'\nimport { ipfsGet, getIpfsCidFromUri } from '../lib/ipfs-utils'\nimport { convertToString, Status } from '../types/dispute-status-types'\n\nconst IPFS_ERROR_MSG = 'Error loading content from ipfs'\n\nexport default function useDisputes() {\n  const courtConfig = useCourtConfig()\n  const { currentTermId } = useCourtClock()\n  const { disputes, fetching, error } = useDisputesSubscription()\n\n  const disputesPhases = useMemo(() => {\n    if (!disputes) {\n      return null\n    }\n\n    return disputes.map(d =>\n      getPhaseAndTransition(d, currentTermId, courtConfig)\n    )\n  }, [courtConfig, currentTermId, disputes])\n\n  const disputesPhasesKey = disputesPhases\n    ? disputesPhases.map(v => convertToString(Object.values(v)[0])).join('')\n    : null\n\n  return useMemo(() => {\n    if (error) {\n      return { error }\n    }\n\n    if (fetching) {\n      return { fetching }\n    }\n\n    return {\n      disputes: disputes.map((dispute, i) => {\n        return {\n          ...dispute,\n          ...disputesPhases[i],\n        }\n      }),\n    }\n  }, [disputesPhases, disputes, disputesPhasesKey, error]) // eslint-disable-line react-hooks/exhaustive-deps\n}\n\n/**\n * Hook that processes a single dispute data\n * @param {String} disputeId Id of the dispute\n * @returns {Array} Array conformed by the dispute processed data, fetching indicator and an error object from the graph or an ipfs error in that order\n * (the error also indicates if the error is from the graph since we need to handle in a different way\n * in the dispute detail, the timeline can not be displayed if is a graph error but can if the error is from ipfs)\n */\nexport function useDispute(disputeId) {\n  const courtConfig = useCourtConfig()\n  const { currentTermId } = useCourtClock()\n  const {\n    dispute,\n    fetching: graphFetching,\n    error: graphError,\n  } = useSingleDisputeSubscription(disputeId)\n\n  const processedDispute = useProcessedDispute(dispute)\n  const disputePhase = getPhaseAndTransition(\n    dispute,\n    currentTermId,\n    courtConfig\n  )\n  const disputePhaseKey = disputePhase\n    ? convertToString(Object.values(disputePhase)[0])\n    : ''\n\n  const graphErrorMessage = graphError?.message || ''\n  const disputeErrorMessage = processedDispute?.error || graphErrorMessage\n\n  return useMemo(\n    () => {\n      const fetching = graphFetching || (dispute && !processedDispute)\n\n      return [\n        dispute && processedDispute\n          ? {\n              ...processedDispute,\n              ...disputePhase,\n            }\n          : null,\n        fetching,\n        disputeErrorMessage\n          ? {\n              message: disputeErrorMessage,\n              fromGraph: Boolean(graphErrorMessage),\n            }\n          : null,\n      ]\n    } /* eslint-disable react-hooks/exhaustive-deps */,\n    [\n      disputeErrorMessage,\n      disputePhaseKey,\n      graphErrorMessage,\n      graphFetching,\n      processedDispute,\n    ]\n    /* eslint-enable react-hooks/exhaustive-deps */\n  )\n}\n\nfunction useProcessedDispute(dispute) {\n  const [processedDispute, setProcessedDispute] = useState(null)\n\n  useEffect(() => {\n    let cancelled = false\n\n    const processDisputeData = async () => {\n      if (dispute.status === Status.Voided) {\n        return dispute\n      }\n\n      const disputeData = await getDisputeData(dispute)\n\n      return {\n        ...dispute,\n        ...disputeData,\n        error: disputeData ? null : IPFS_ERROR_MSG,\n      }\n    }\n\n    const processDispute = async () => {\n      if (!dispute) {\n        return\n      }\n\n      const processedDispute = await processDisputeData()\n      if (!cancelled) {\n        setProcessedDispute(processedDispute)\n      }\n    }\n\n    processDispute()\n\n    return () => {\n      cancelled = true\n    }\n  }, [dispute])\n\n  return processedDispute\n}\n\nasync function getDisputeData(dispute) {\n  // Dispute is disputable\n  if (dispute.disputable) {\n    return processDisputableData(dispute)\n  }\n\n  // Dispute is raw dispute\n  return processRawDisputeData(dispute)\n}\n\nasync function processDisputableData(dispute) {\n  const {\n    agreement,\n    defendant,\n    plaintiff,\n    organization,\n    title,\n  } = dispute.disputable\n\n  const agreementIpfsCid = getIpfsCidFromUri(agreement)\n\n  return {\n    agreementText: title,\n    agreementUrl: `${IPFS_ENDPOINT}/${agreementIpfsCid}`,\n    defendant,\n    description: title,\n    organization,\n    plaintiff,\n  }\n}\n\n/**\n * Processes metadata for raw disputes. `metadataUri` contains the IPFS CID which will be fetched and parsed.\n * @param {*} dispute Dispute from which data will be processed.\n * @returns {Object | null} Dispute processed data.\n */\nasync function processRawDisputeData(dispute) {\n  const { description: disputeDescription, metadataUri } = dispute\n\n  if (metadataUri) {\n    const ipfsPath = getIpfsCidFromUri(metadataUri)\n\n    if (ipfsPath) {\n      // Fetch IPFS content\n      const { data, error } = await ipfsGet(ipfsPath)\n      if (!error) {\n        try {\n          // Parse IPFS content\n          const parsedDisputeData = JSON.parse(data)\n          const agreementText = parsedDisputeData.agreementText.replace(\n            /^.\\//,\n            ''\n          )\n          // Note that in this case, we expect the agreement's location to be relative to the\n          // metadata URI. For example, if the metadataUri is `<cid>/metadata.json`, the agreement's\n          // location would be `<cid>/<agreement>`\n          const agreementUrl = agreementText\n            ? resolvePathname(agreementText, `${IPFS_ENDPOINT}/${ipfsPath}`)\n            : ''\n\n          const {\n            agreementTitle = '',\n            defendant = '',\n            description = disputeDescription,\n            disputedActionRadspec = '',\n            disputedActionText = '',\n            disputedActionURL = '',\n            organization = '',\n            plaintiff = '',\n          } = parsedDisputeData\n\n          return {\n            agreementText: agreementTitle || agreementText || '',\n            agreementUrl,\n            defendant,\n            description,\n            disputedActionRadspec,\n            disputedActionText,\n            disputedActionURL,\n            organization,\n            plaintiff,\n          }\n        } catch (err) {\n          return {\n            description: data,\n          }\n        }\n      }\n    }\n  }\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}