{"ast":null,"code":"import { useMemo } from 'react';\nimport { useQuery } from 'urql';\nimport { useCourtConfig } from '../providers/CourtConfig'; // queries\n\nimport { OpenTasks } from '../queries/tasks';\nimport { CourtConfig, FeeMovements, JurorsRegistryModule } from '../queries/court';\nimport { AllDisputes, SingleDispute } from '../queries/disputes';\nimport { AppealsByMaker, AppealsByTaker } from '../queries/appeals';\nimport { JurorANJBalances, JurorANJWalletBalance, JurorTreasuryBalances } from '../queries/balances';\nimport { JurorDraftsFrom, JurorDraftsRewards } from '../queries/jurorDrafts'; // utils\n\nimport { bigNum } from '../lib/math-utils';\nimport { dayjs, toMs } from '../utils/date-utils';\nimport { groupMovements } from '../utils/anj-movement-utils';\nimport { transformAppealDataAttributes } from '../utils/appeal-utils';\nimport { transformRoundDataAttributes, transformDisputeDataAttributes } from '../utils/dispute-utils';\nimport { transformJurorDataAttributes } from '../utils/juror-draft-utils';\nimport { transformClaimedFeesDataAttributes } from '../utils/subscription-utils';\nimport { getModuleAddress, transformCourtConfigDataAttributes } from '../utils/court-utils'; // types\n\nimport { CourtModuleType } from '../types/court-module-types';\nimport { JurorLastFeeWithdrawal } from '../queries/juror';\nconst NO_AMOUNT = bigNum(0);\n\nfunction useQuerySub(query, variables = {}, options = {}) {\n  return useQuery({\n    query: query,\n    variables: variables,\n    requestPolicy: 'cache-and-network',\n    pollInterval: 13 * 1000,\n    ...options\n  });\n} // Subscription to get juror's wallet balance\n\n\nfunction useANJBalance(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorANJWalletBalance, {\n    id: jurorId.toLowerCase()\n  });\n  return {\n    data,\n    error\n  };\n} // Subscription to get juror's active, inactive and\n// locked balances and all 24 hrs movements\n\n\nfunction useJuror(jurorId) {\n  // get 24hs from current time (seconds)\n  const yesterday = dayjs().subtract(1, 'day').unix();\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorANJBalances, {\n    id: jurorId.toLowerCase(),\n    from: yesterday\n  });\n  return {\n    data,\n    error\n  };\n} // Subscription to get all treasury balances of juror with id `jurorId`\n\n\nfunction useJurorTreasuryBalances(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorTreasuryBalances, {\n    owner: jurorId.toLowerCase()\n  });\n  return {\n    data,\n    error\n  };\n}\n/**\n * Subscribes to all juror balances as well as to the latest 24h movements and all subscription fees claimed by the juror\n * @param {String} jurorId Address of the juror\n * @returns {Object} Object containing al juror balances (Wallet, Inactive, Active, Locked, Deactivation Process, Treasury),\n * latest 24h movements and all subscription fees claimed by the juror\n */\n\n\nexport function useJurorBalancesSubscription(jurorId) {\n  // Juror wallet balance\n  const {\n    data: anjBalanceData,\n    error: anjBalanceError\n  } = useANJBalance(jurorId); // Juror ANJ balances, 24h movements and subscritpion claimed fees\n\n  const {\n    data: jurorData,\n    error: jurorError\n  } = useJuror(jurorId);\n  const {\n    data: treasuryBalancesData,\n    error: treasuryBalancesError\n  } = useJurorTreasuryBalances(jurorId);\n  const errors = [anjBalanceError, jurorError, treasuryBalancesError].filter(err => err);\n  const {\n    anjBalances,\n    anjMovements,\n    claimedSubscriptionFees,\n    treasury\n  } = useMemo(() => {\n    // Means it's still fetching\n    if (!jurorData || !anjBalanceData || !treasuryBalancesData) {\n      return {};\n    } // If the account doesn't hold any ANJ we set 0 as default\n\n\n    const {\n      amount: walletBalance = NO_AMOUNT\n    } = anjBalanceData.anjbalance || {}; // If the juror is null then means that the connnected account is not a juror but we are already done fetching\n    // We set 0 as default values\n\n    const {\n      activeBalance = NO_AMOUNT,\n      anjMovements = [],\n      availableBalance = NO_AMOUNT,\n      claimedSubscriptionFees = [],\n      deactivationBalance = NO_AMOUNT,\n      lockedBalance = NO_AMOUNT\n    } = jurorData.juror || {};\n    const {\n      treasuryBalances = []\n    } = treasuryBalancesData || {};\n    return {\n      anjBalances: {\n        activeBalance: bigNum(activeBalance),\n        deactivationBalance: bigNum(deactivationBalance),\n        inactiveBalance: bigNum(availableBalance),\n        lockedBalance: bigNum(lockedBalance),\n        walletBalance: bigNum(walletBalance)\n      },\n      anjMovements: groupMovements(anjMovements),\n      claimedSubscriptionFees: claimedSubscriptionFees.map(transformClaimedFeesDataAttributes),\n      treasury: treasuryBalances.map(balance => ({ ...balance,\n        amount: bigNum(balance.amount)\n      }))\n    };\n  }, [anjBalanceData, jurorData, treasuryBalancesData]);\n  return {\n    anjBalances,\n    anjMovements,\n    claimedSubscriptionFees,\n    treasury,\n    fetching: !anjBalances && errors.length === 0,\n    errors\n  };\n}\n/**\n * Subscribes to the court configuration data\n * @param {String} courtAddress Adrress of the court contract\n * @returns {Object} Court configuration data\n */\n\nexport function useCourtConfigSubscription(courtAddress) {\n  const [{\n    data\n  }] = useQuerySub(CourtConfig, {\n    id: courtAddress.toLowerCase()\n  }); // TODO: handle possible errors\n\n  const courtConfig = useMemo(() => (data === null || data === void 0 ? void 0 : data.courtConfig) ? transformCourtConfigDataAttributes(data.courtConfig) : null, [data]);\n  return courtConfig;\n}\n/**\n * Subscribes to the dispute with id == `id`\n * @param {String} id Id of the dispute\n * @returns {Object} Dispute by `id`\n */\n\nexport function useSingleDisputeSubscription(id) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(SingleDispute, {\n    id\n  });\n  const dispute = useMemo(() => data && data.dispute ? transformDisputeDataAttributes(data.dispute) : null, [data]);\n  return {\n    dispute,\n    fetching: !data && !error,\n    error\n  };\n}\n/**\n * Subscribes to all existing disputes on the court\n * @returns {Object} All disputes\n */\n\nexport function useDisputesSubscription() {\n  const courtConfig = useCourtConfig();\n  const [{\n    data,\n    error\n  }] = useQuerySub(AllDisputes);\n  const disputes = useMemo(() => (data === null || data === void 0 ? void 0 : data.disputes) ? data.disputes.map(dispute => transformDisputeDataAttributes(dispute, courtConfig)) : null, [courtConfig, data]);\n  return {\n    disputes,\n    fetching: !data && !error,\n    error\n  };\n}\n/**\n * Subscribe to all `jurorId` drafts for the current term\n * @param {String} jurorId Address of the juror\n * @param {Number} termStartTime Start time of the term inseconds\n * @param {Boolean} pause Tells whether to pause the subscription or not\n * @returns {Object} All `jurorId` drafts for the current term\n */\n\nexport function useCurrentTermJurorDraftsSubscription(jurorId, termStartTime, pause) {\n  const [result] = useQuerySub(JurorDraftsFrom, {\n    id: jurorId.toLowerCase(),\n    from: termStartTime\n  }, {\n    pause\n  });\n  const {\n    juror\n  } = result.data || {};\n  return juror && juror.drafts ? juror.drafts : [];\n}\n/**\n * Subscribes to all `jurorId` drafts\n * @dev This subscription is useful to get all rewards pending for claiming as well\n * as for the amount of locked ANJ a juror has per dispute\n * Ideally we would check that the round is not settled but we cannot do nested filters for now\n *\n * @param {String} jurorId Address of the juror\n * @returns {Object} All `jurorId` drafts\n */\n\nexport function useJurorDraftsRewardsSubscription(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorDraftsRewards, {\n    id: jurorId.toLowerCase()\n  });\n  const jurorDrafts = useMemo(() => {\n    var _data$juror;\n\n    if (!data) {\n      return null;\n    }\n\n    return ((_data$juror = data.juror) === null || _data$juror === void 0 ? void 0 : _data$juror.drafts.map(transformJurorDataAttributes)) || [];\n  }, [data]);\n  return {\n    jurorDrafts,\n    fetching: !jurorDrafts && !error,\n    error\n  };\n}\n\nfunction useAppealsByMaker(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(AppealsByMaker, {\n    maker: jurorId.toLowerCase()\n  });\n  return {\n    data,\n    error\n  };\n}\n\nfunction useAppealsByTaker(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(AppealsByTaker, {\n    taker: jurorId.toLowerCase()\n  });\n  return {\n    data,\n    error\n  };\n}\n/**\n * Subscribes to all `jurorId` appeal collaterals\n * @dev Since we cannot do or operators on graphql queries, we need to get appeals by taker and maker separately\n *\n * @param {String} jurorId Address of the juror\n * @returns {Object} All `jurorId` appeal collaterals\n */\n\n\nexport function useAppealsByUserSubscription(jurorId) {\n  const {\n    data: makerAppealsData,\n    error: makerAppealsError\n  } = useAppealsByMaker(jurorId);\n  const {\n    data: takerAppealsData,\n    error: takerAppealsError\n  } = useAppealsByTaker(jurorId);\n  const appeals = useMemo(() => {\n    if (!makerAppealsData || !takerAppealsData) {\n      return null;\n    }\n\n    const makerAppeals = makerAppealsData.appeals;\n    const takerAppeals = takerAppealsData.appeals;\n    return [...makerAppeals, ...takerAppeals].map(transformAppealDataAttributes);\n  }, [makerAppealsData, takerAppealsData]);\n  const errors = [makerAppealsError, takerAppealsError].filter(err => err);\n  return {\n    appeals,\n    fetching: !appeals && errors.length === 0,\n    errors\n  };\n}\nexport function useTasksSubscription() {\n  // 1- Committing, 4-Confirming Appeal , 5- Ended\n  const subscriptionVariables = {\n    state: [1, 4]\n  };\n  const [{\n    data,\n    error\n  }] = useQuerySub(OpenTasks, subscriptionVariables);\n  const tasks = (data === null || data === void 0 ? void 0 : data.adjudicationRounds.map(transformRoundDataAttributes)) || null;\n  return {\n    tasks,\n    fetching: !data && !error,\n    error\n  };\n}\nexport function useJurorRegistrySubscription() {\n  const {\n    modules\n  } = useCourtConfig();\n  const jurorRegistryAddress = getModuleAddress(modules, CourtModuleType.JurorsRegistry);\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorsRegistryModule, {\n    id: jurorRegistryAddress\n  });\n  const jurorRegistryStats = (data === null || data === void 0 ? void 0 : data.jurorsRegistryModule) || null;\n  return {\n    data: jurorRegistryStats,\n    error\n  };\n}\nexport function useTotalRewardsSubscription() {\n  const [{\n    data,\n    error\n  }] = useQuerySub(FeeMovements);\n  const rewards = (data === null || data === void 0 ? void 0 : data.feeMovements) || null;\n  return {\n    data: rewards,\n    error\n  };\n}\n/**\n * Queries for the last withdrawal fee movement time made by the given juror\n * @param {String} jurorId Address of the juror\n * @returns {Number} Juror's last withdrawal fee movement date in unix time\n */\n\nexport function useJurorLastWithdrawalTimeSubscription(jurorId) {\n  const [{\n    data\n  }] = useQuerySub(JurorLastFeeWithdrawal, {\n    owner: jurorId === null || jurorId === void 0 ? void 0 : jurorId.toLowerCase()\n  }, {\n    pause: !jurorId\n  });\n\n  if (!data) {\n    return null;\n  }\n\n  if (data.feeMovements.length === 0) {\n    return -1;\n  }\n\n  return toMs(data.feeMovements[0].createdAt);\n}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/subscription-hooks.js"],"names":["useMemo","useQuery","useCourtConfig","OpenTasks","CourtConfig","FeeMovements","JurorsRegistryModule","AllDisputes","SingleDispute","AppealsByMaker","AppealsByTaker","JurorANJBalances","JurorANJWalletBalance","JurorTreasuryBalances","JurorDraftsFrom","JurorDraftsRewards","bigNum","dayjs","toMs","groupMovements","transformAppealDataAttributes","transformRoundDataAttributes","transformDisputeDataAttributes","transformJurorDataAttributes","transformClaimedFeesDataAttributes","getModuleAddress","transformCourtConfigDataAttributes","CourtModuleType","JurorLastFeeWithdrawal","NO_AMOUNT","useQuerySub","query","variables","options","requestPolicy","pollInterval","useANJBalance","jurorId","data","error","id","toLowerCase","useJuror","yesterday","subtract","unix","from","useJurorTreasuryBalances","owner","useJurorBalancesSubscription","anjBalanceData","anjBalanceError","jurorData","jurorError","treasuryBalancesData","treasuryBalancesError","errors","filter","err","anjBalances","anjMovements","claimedSubscriptionFees","treasury","amount","walletBalance","anjbalance","activeBalance","availableBalance","deactivationBalance","lockedBalance","juror","treasuryBalances","inactiveBalance","map","balance","fetching","length","useCourtConfigSubscription","courtAddress","courtConfig","useSingleDisputeSubscription","dispute","useDisputesSubscription","disputes","useCurrentTermJurorDraftsSubscription","termStartTime","pause","result","drafts","useJurorDraftsRewardsSubscription","jurorDrafts","useAppealsByMaker","maker","useAppealsByTaker","taker","useAppealsByUserSubscription","makerAppealsData","makerAppealsError","takerAppealsData","takerAppealsError","appeals","makerAppeals","takerAppeals","useTasksSubscription","subscriptionVariables","state","tasks","adjudicationRounds","useJurorRegistrySubscription","modules","jurorRegistryAddress","JurorsRegistry","jurorRegistryStats","jurorsRegistryModule","useTotalRewardsSubscription","rewards","feeMovements","useJurorLastWithdrawalTimeSubscription","createdAt"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\nimport { useQuery } from 'urql'\nimport { useCourtConfig } from '../providers/CourtConfig'\n\n// queries\nimport { OpenTasks } from '../queries/tasks'\nimport {\n  CourtConfig,\n  FeeMovements,\n  JurorsRegistryModule,\n} from '../queries/court'\nimport { AllDisputes, SingleDispute } from '../queries/disputes'\nimport { AppealsByMaker, AppealsByTaker } from '../queries/appeals'\nimport {\n  JurorANJBalances,\n  JurorANJWalletBalance,\n  JurorTreasuryBalances,\n} from '../queries/balances'\nimport { JurorDraftsFrom, JurorDraftsRewards } from '../queries/jurorDrafts'\n\n// utils\nimport { bigNum } from '../lib/math-utils'\nimport { dayjs, toMs } from '../utils/date-utils'\nimport { groupMovements } from '../utils/anj-movement-utils'\nimport { transformAppealDataAttributes } from '../utils/appeal-utils'\nimport {\n  transformRoundDataAttributes,\n  transformDisputeDataAttributes,\n} from '../utils/dispute-utils'\nimport { transformJurorDataAttributes } from '../utils/juror-draft-utils'\nimport { transformClaimedFeesDataAttributes } from '../utils/subscription-utils'\nimport {\n  getModuleAddress,\n  transformCourtConfigDataAttributes,\n} from '../utils/court-utils'\n\n// types\nimport { CourtModuleType } from '../types/court-module-types'\nimport { JurorLastFeeWithdrawal } from '../queries/juror'\n\nconst NO_AMOUNT = bigNum(0)\n\nfunction useQuerySub(query, variables = {}, options = {}) {\n  return useQuery({\n    query: query,\n    variables: variables,\n    requestPolicy: 'cache-and-network',\n    pollInterval: 13 * 1000,\n    ...options,\n  })\n}\n\n// Subscription to get juror's wallet balance\nfunction useANJBalance(jurorId) {\n  const [{ data, error }] = useQuerySub(JurorANJWalletBalance, {\n    id: jurorId.toLowerCase(),\n  })\n  return { data, error }\n}\n\n// Subscription to get juror's active, inactive and\n// locked balances and all 24 hrs movements\nfunction useJuror(jurorId) {\n  // get 24hs from current time (seconds)\n  const yesterday = dayjs()\n    .subtract(1, 'day')\n    .unix()\n\n  const [{ data, error }] = useQuerySub(JurorANJBalances, {\n    id: jurorId.toLowerCase(),\n    from: yesterday,\n  })\n\n  return { data, error }\n}\n\n// Subscription to get all treasury balances of juror with id `jurorId`\nfunction useJurorTreasuryBalances(jurorId) {\n  const [{ data, error }] = useQuerySub(JurorTreasuryBalances, {\n    owner: jurorId.toLowerCase(),\n  })\n  return { data, error }\n}\n\n/**\n * Subscribes to all juror balances as well as to the latest 24h movements and all subscription fees claimed by the juror\n * @param {String} jurorId Address of the juror\n * @returns {Object} Object containing al juror balances (Wallet, Inactive, Active, Locked, Deactivation Process, Treasury),\n * latest 24h movements and all subscription fees claimed by the juror\n */\nexport function useJurorBalancesSubscription(jurorId) {\n  // Juror wallet balance\n  const { data: anjBalanceData, error: anjBalanceError } = useANJBalance(\n    jurorId\n  )\n\n  // Juror ANJ balances, 24h movements and subscritpion claimed fees\n  const { data: jurorData, error: jurorError } = useJuror(jurorId)\n  const {\n    data: treasuryBalancesData,\n    error: treasuryBalancesError,\n  } = useJurorTreasuryBalances(jurorId)\n\n  const errors = [anjBalanceError, jurorError, treasuryBalancesError].filter(\n    err => err\n  )\n\n  const {\n    anjBalances,\n    anjMovements,\n    claimedSubscriptionFees,\n    treasury,\n  } = useMemo(() => {\n    // Means it's still fetching\n    if (!jurorData || !anjBalanceData || !treasuryBalancesData) {\n      return {}\n    }\n\n    // If the account doesn't hold any ANJ we set 0 as default\n    const { amount: walletBalance = NO_AMOUNT } =\n      anjBalanceData.anjbalance || {}\n\n    // If the juror is null then means that the connnected account is not a juror but we are already done fetching\n    // We set 0 as default values\n    const {\n      activeBalance = NO_AMOUNT,\n      anjMovements = [],\n      availableBalance = NO_AMOUNT,\n      claimedSubscriptionFees = [],\n      deactivationBalance = NO_AMOUNT,\n      lockedBalance = NO_AMOUNT,\n    } = jurorData.juror || {}\n\n    const { treasuryBalances = [] } = treasuryBalancesData || {}\n\n    return {\n      anjBalances: {\n        activeBalance: bigNum(activeBalance),\n        deactivationBalance: bigNum(deactivationBalance),\n        inactiveBalance: bigNum(availableBalance),\n        lockedBalance: bigNum(lockedBalance),\n        walletBalance: bigNum(walletBalance),\n      },\n      anjMovements: groupMovements(anjMovements),\n      claimedSubscriptionFees: claimedSubscriptionFees.map(\n        transformClaimedFeesDataAttributes\n      ),\n      treasury: treasuryBalances.map(balance => ({\n        ...balance,\n        amount: bigNum(balance.amount),\n      })),\n    }\n  }, [anjBalanceData, jurorData, treasuryBalancesData])\n\n  return {\n    anjBalances,\n    anjMovements,\n    claimedSubscriptionFees,\n    treasury,\n    fetching: !anjBalances && errors.length === 0,\n    errors,\n  }\n}\n\n/**\n * Subscribes to the court configuration data\n * @param {String} courtAddress Adrress of the court contract\n * @returns {Object} Court configuration data\n */\nexport function useCourtConfigSubscription(courtAddress) {\n  const [{ data }] = useQuerySub(CourtConfig, {\n    id: courtAddress.toLowerCase(),\n  })\n\n  // TODO: handle possible errors\n  const courtConfig = useMemo(\n    () =>\n      data?.courtConfig\n        ? transformCourtConfigDataAttributes(data.courtConfig)\n        : null,\n    [data]\n  )\n\n  return courtConfig\n}\n\n/**\n * Subscribes to the dispute with id == `id`\n * @param {String} id Id of the dispute\n * @returns {Object} Dispute by `id`\n */\nexport function useSingleDisputeSubscription(id) {\n  const [{ data, error }] = useQuerySub(SingleDispute, { id })\n\n  const dispute = useMemo(\n    () =>\n      data && data.dispute\n        ? transformDisputeDataAttributes(data.dispute)\n        : null,\n    [data]\n  )\n\n  return { dispute, fetching: !data && !error, error }\n}\n\n/**\n * Subscribes to all existing disputes on the court\n * @returns {Object} All disputes\n */\nexport function useDisputesSubscription() {\n  const courtConfig = useCourtConfig()\n  const [{ data, error }] = useQuerySub(AllDisputes)\n\n  const disputes = useMemo(\n    () =>\n      data?.disputes\n        ? data.disputes.map(dispute =>\n            transformDisputeDataAttributes(dispute, courtConfig)\n          )\n        : null,\n    [courtConfig, data]\n  )\n\n  return { disputes, fetching: !data && !error, error }\n}\n\n/**\n * Subscribe to all `jurorId` drafts for the current term\n * @param {String} jurorId Address of the juror\n * @param {Number} termStartTime Start time of the term inseconds\n * @param {Boolean} pause Tells whether to pause the subscription or not\n * @returns {Object} All `jurorId` drafts for the current term\n */\nexport function useCurrentTermJurorDraftsSubscription(\n  jurorId,\n  termStartTime,\n  pause\n) {\n  const [result] = useQuerySub(\n    JurorDraftsFrom,\n    { id: jurorId.toLowerCase(), from: termStartTime },\n    { pause }\n  )\n\n  const { juror } = result.data || {}\n  return juror && juror.drafts ? juror.drafts : []\n}\n\n/**\n * Subscribes to all `jurorId` drafts\n * @dev This subscription is useful to get all rewards pending for claiming as well\n * as for the amount of locked ANJ a juror has per dispute\n * Ideally we would check that the round is not settled but we cannot do nested filters for now\n *\n * @param {String} jurorId Address of the juror\n * @returns {Object} All `jurorId` drafts\n */\nexport function useJurorDraftsRewardsSubscription(jurorId) {\n  const [{ data, error }] = useQuerySub(JurorDraftsRewards, {\n    id: jurorId.toLowerCase(),\n  })\n\n  const jurorDrafts = useMemo(() => {\n    if (!data) {\n      return null\n    }\n\n    return data.juror?.drafts.map(transformJurorDataAttributes) || []\n  }, [data])\n\n  return { jurorDrafts, fetching: !jurorDrafts && !error, error }\n}\n\nfunction useAppealsByMaker(jurorId) {\n  const [{ data, error }] = useQuerySub(AppealsByMaker, {\n    maker: jurorId.toLowerCase(),\n  })\n  return { data, error }\n}\n\nfunction useAppealsByTaker(jurorId) {\n  const [{ data, error }] = useQuerySub(AppealsByTaker, {\n    taker: jurorId.toLowerCase(),\n  })\n  return { data, error }\n}\n\n/**\n * Subscribes to all `jurorId` appeal collaterals\n * @dev Since we cannot do or operators on graphql queries, we need to get appeals by taker and maker separately\n *\n * @param {String} jurorId Address of the juror\n * @returns {Object} All `jurorId` appeal collaterals\n */\nexport function useAppealsByUserSubscription(jurorId) {\n  const {\n    data: makerAppealsData,\n    error: makerAppealsError,\n  } = useAppealsByMaker(jurorId)\n  const {\n    data: takerAppealsData,\n    error: takerAppealsError,\n  } = useAppealsByTaker(jurorId)\n\n  const appeals = useMemo(() => {\n    if (!makerAppealsData || !takerAppealsData) {\n      return null\n    }\n\n    const makerAppeals = makerAppealsData.appeals\n    const takerAppeals = takerAppealsData.appeals\n\n    return [...makerAppeals, ...takerAppeals].map(transformAppealDataAttributes)\n  }, [makerAppealsData, takerAppealsData])\n\n  const errors = [makerAppealsError, takerAppealsError].filter(err => err)\n\n  return { appeals, fetching: !appeals && errors.length === 0, errors }\n}\n\nexport function useTasksSubscription() {\n  // 1- Committing, 4-Confirming Appeal , 5- Ended\n  const subscriptionVariables = { state: [1, 4] }\n\n  const [{ data, error }] = useQuerySub(OpenTasks, subscriptionVariables)\n\n  const tasks =\n    data?.adjudicationRounds.map(transformRoundDataAttributes) || null\n\n  return { tasks, fetching: !data && !error, error }\n}\n\nexport function useJurorRegistrySubscription() {\n  const { modules } = useCourtConfig()\n  const jurorRegistryAddress = getModuleAddress(\n    modules,\n    CourtModuleType.JurorsRegistry\n  )\n\n  const [{ data, error }] = useQuerySub(JurorsRegistryModule, {\n    id: jurorRegistryAddress,\n  })\n\n  const jurorRegistryStats = data?.jurorsRegistryModule || null\n\n  return { data: jurorRegistryStats, error }\n}\n\nexport function useTotalRewardsSubscription() {\n  const [{ data, error }] = useQuerySub(FeeMovements)\n\n  const rewards = data?.feeMovements || null\n\n  return { data: rewards, error }\n}\n\n/**\n * Queries for the last withdrawal fee movement time made by the given juror\n * @param {String} jurorId Address of the juror\n * @returns {Number} Juror's last withdrawal fee movement date in unix time\n */\nexport function useJurorLastWithdrawalTimeSubscription(jurorId) {\n  const [{ data }] = useQuerySub(\n    JurorLastFeeWithdrawal,\n    { owner: jurorId?.toLowerCase() },\n    { pause: !jurorId }\n  )\n\n  if (!data) {\n    return null\n  }\n\n  if (data.feeMovements.length === 0) {\n    return -1\n  }\n\n  return toMs(data.feeMovements[0].createdAt)\n}\n"]},"metadata":{},"sourceType":"module"}