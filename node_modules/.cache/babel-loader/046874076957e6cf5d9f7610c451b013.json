{"ast":null,"code":"import _slicedToArray from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _asyncToGenerator from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { ethers } from 'ethers';\nimport { erc20ABI, forwarderAbi, forwarderFeeAbi } from './abis';\nimport { isFullMethodSignature } from './app';\nexport function createDirectTransaction(_x, _x2, _x3, _x4) {\n  return _createDirectTransaction.apply(this, arguments);\n}\n\nfunction _createDirectTransaction() {\n  _createDirectTransaction = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(sender, destination, methodAbiFragment, params) {\n    var transactionOptions, options, ethersInterface;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            transactionOptions = {}; // If an extra parameter has been provided, it is the transaction options if it is an object\n\n            if (methodAbiFragment.inputs.length + 1 === params.length && typeof params[params.length - 1] === 'object') {\n              options = params.pop();\n              transactionOptions = _objectSpread({}, transactionOptions, {}, options);\n            }\n\n            ethersInterface = new ethers.utils.Interface([methodAbiFragment]); // The direct transaction we eventually want to perform\n\n            return _context.abrupt(\"return\", _objectSpread({}, transactionOptions, {\n              from: sender,\n              to: destination,\n              data: ethersInterface.encodeFunctionData(ethers.utils.FunctionFragment.from(methodAbiFragment), params)\n            }));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _createDirectTransaction.apply(this, arguments);\n}\n\nexport function createDirectTransactionForApp(_x5, _x6, _x7, _x8) {\n  return _createDirectTransactionForApp.apply(this, arguments);\n}\n\nfunction _createDirectTransactionForApp() {\n  _createDirectTransactionForApp = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(sender, app, methodSignature, params) {\n    var destination, methodAbiFragment;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (app) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new Error(\"Could not create transaction due to missing app artifact\");\n\n          case 2:\n            destination = app.address;\n\n            if (app.abi) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new Error(\"No ABI specified in artifact for \".concat(destination));\n\n          case 5:\n            methodAbiFragment = app.abi.find(function (method) {\n              // If the full signature isn't given, just find the first overload declared\n              if (!isFullMethodSignature(methodSignature)) {\n                return method.name === methodSignature;\n              } // Fallback functions don't have inputs in the ABI\n\n\n              var currentParameterTypes = Array.isArray(method.inputs) ? method.inputs.map(function (_ref) {\n                var type = _ref.type;\n                return type;\n              }) : [];\n              var currentMethodSignature = \"\".concat(method.name, \"(\").concat(currentParameterTypes.join(','), \")\");\n              return currentMethodSignature === methodSignature;\n            });\n\n            if (methodAbiFragment) {\n              _context2.next = 8;\n              break;\n            }\n\n            throw new Error(\"\".concat(methodSignature, \" not found on ABI for \").concat(destination));\n\n          case 8:\n            return _context2.abrupt(\"return\", createDirectTransaction(sender, destination, methodAbiFragment, params));\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _createDirectTransactionForApp.apply(this, arguments);\n}\n\nexport function createForwarderTransactionBuilder(sender, directTransaction) {\n  var forwarder = new ethers.utils.Interface(forwarderAbi);\n  return function (forwarderAddress, script) {\n    return _objectSpread({}, directTransaction, {\n      from: sender,\n      to: forwarderAddress,\n      data: forwarder.encodeFunctionData('forward', [script])\n    });\n  };\n}\nexport function buildPretransaction(_x9, _x10) {\n  return _buildPretransaction.apply(this, arguments);\n}\n\nfunction _buildPretransaction() {\n  _buildPretransaction = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(transaction, provider) {\n    var from, to, _transaction$token, tokenAddress, tokenValue, spender, approveSpender, tokenContract, balance, tokenValueBN, allowance, allowanceBN, erc20;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // Token allowance pretransactionn\n            from = transaction.from, to = transaction.to, _transaction$token = transaction.token, tokenAddress = _transaction$token.address, tokenValue = _transaction$token.value, spender = _transaction$token.spender; // Approve the transaction destination unless an spender is passed to approve a different contract\n\n            approveSpender = spender || to;\n            tokenContract = new ethers.Contract(tokenAddress, erc20ABI, provider);\n            _context3.next = 5;\n            return tokenContract.balanceOf(from);\n\n          case 5:\n            balance = _context3.sent;\n            tokenValueBN = BigInt(tokenValue);\n\n            if (!(BigInt(balance) < tokenValueBN)) {\n              _context3.next = 9;\n              break;\n            }\n\n            throw new Error(\"Balance too low. \".concat(from, \" balance of \").concat(tokenAddress, \" token is \").concat(balance, \" (attempting to send \").concat(tokenValue, \")\"));\n\n          case 9:\n            _context3.next = 11;\n            return tokenContract.allowance(from, approveSpender);\n\n          case 11:\n            allowance = _context3.sent;\n            allowanceBN = BigInt(allowance); // If allowance is already greater than or equal to amount, there is no need to do an approve transaction\n\n            if (!(allowanceBN < tokenValueBN)) {\n              _context3.next = 17;\n              break;\n            }\n\n            if (allowanceBN > BigInt(0)) {\n              // TODO: Actually handle existing approvals (some tokens fail when the current allowance is not 0)\n              console.warn(\"\".concat(from, \" already approved \").concat(approveSpender, \". In some tokens, approval will fail unless the allowance is reset to 0 before re-approving again.\"));\n            }\n\n            erc20 = new ethers.utils.Interface(erc20ABI);\n            return _context3.abrupt(\"return\", {\n              from: from,\n              to: tokenAddress,\n              data: erc20.encodeFunctionData('approve', [approveSpender, tokenValue])\n            });\n\n          case 17:\n            return _context3.abrupt(\"return\", undefined);\n\n          case 18:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _buildPretransaction.apply(this, arguments);\n}\n\nexport function buildForwardingFeePretransaction(_x11, _x12) {\n  return _buildForwardingFeePretransaction.apply(this, arguments);\n}\n\nfunction _buildForwardingFeePretransaction() {\n  _buildForwardingFeePretransaction = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(forwardingTransaction, provider) {\n    var forwarderAddress, from, forwarderFee, feeDetails, overrides, _ref2, _ref3, tokenAddress, amount, forwardingTxWithTokenData;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            forwarderAddress = forwardingTransaction.to, from = forwardingTransaction.from;\n            forwarderFee = new ethers.Contract(forwarderAddress, forwarderFeeAbi, provider);\n            feeDetails = {\n              amount: BigInt(0),\n              tokenAddress: ''\n            };\n            _context4.prev = 3;\n            overrides = {\n              from: from\n            }; // Passing the EOA as `msg.sender` to the forwardFee call is useful for use cases where the fee differs relative to the account\n\n            _context4.next = 7;\n            return forwarderFee.forwardFee(overrides);\n\n          case 7:\n            _ref2 = _context4.sent;\n            _ref3 = _slicedToArray(_ref2, 2);\n            tokenAddress = _ref3[0];\n            amount = _ref3[1];\n            // forwardFee() returns (address, uint256)\n            feeDetails.tokenAddress = tokenAddress;\n            feeDetails.amount = BigInt(amount);\n            _context4.next = 17;\n            break;\n\n          case 15:\n            _context4.prev = 15;\n            _context4.t0 = _context4[\"catch\"](3);\n\n          case 17:\n            if (!(feeDetails.tokenAddress && feeDetails.amount > BigInt(0))) {\n              _context4.next = 20;\n              break;\n            }\n\n            // Needs a token approval pretransaction\n            forwardingTxWithTokenData = _objectSpread({}, forwardingTransaction, {\n              token: {\n                address: feeDetails.tokenAddress,\n                spender: forwarderAddress,\n                value: feeDetails.amount.toString()\n              }\n            });\n            return _context4.abrupt(\"return\", buildPretransaction(forwardingTxWithTokenData, provider));\n\n          case 20:\n            return _context4.abrupt(\"return\", undefined);\n\n          case 21:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[3, 15]]);\n  }));\n  return _buildForwardingFeePretransaction.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}