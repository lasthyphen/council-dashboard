{"ast":null,"code":"import { ethers } from 'ethers';\nimport { ConnectorJson, Organization, toNetwork } from '@aragon/connect-core';\nimport ConnectorEthereum from '@aragon/connect-ethereum';\nimport ConnectorTheGraph from '@aragon/connect-thegraph';\nimport { XDAI_WSS_ENDPOINT, DEFAULT_IPFS_URL } from './constants';\n\nfunction ipfsResolverFromUrlTemplate(urlTemplate) {\n  return function ipfsResolver(cid, path) {\n    const url = urlTemplate.replace(/\\{cid\\}/, cid);\n\n    if (!path) {\n      return url.replace(/\\{path\\}/, '');\n    }\n\n    if (!path.startsWith('/')) {\n      path = `/${path}`;\n    }\n\n    return url.replace(/\\{path\\}/, path);\n  };\n}\n\nfunction getIpfsResolver(ipfs) {\n  if (typeof ipfs === 'function') {\n    return ipfs;\n  }\n\n  return ipfsResolverFromUrlTemplate(ipfs || DEFAULT_IPFS_URL);\n}\n\nfunction normalizeConnectorConfig(connector) {\n  if (Array.isArray(connector)) {\n    return [connector[0], connector[1] || {}];\n  }\n\n  if (typeof connector === 'string') {\n    return [connector, {}];\n  }\n\n  return null;\n}\n\nfunction getConnector(connector, network) {\n  const normalizedConfig = normalizeConnectorConfig(connector);\n\n  if (normalizedConfig === null) {\n    return connector;\n  }\n\n  const [name, config] = normalizedConfig;\n\n  if (!config.network) {\n    config.network = network;\n  }\n\n  if (name === 'json') {\n    return new ConnectorJson(config);\n  }\n\n  if (name === 'thegraph') {\n    return new ConnectorTheGraph(config);\n  }\n\n  if (name === 'ethereum') {\n    return new ConnectorEthereum(config);\n  }\n\n  throw new Error(`Unsupported connector name: ${name}`);\n}\n\nfunction getEthersProvider(ethereumProvider, network) {\n  // Ethers compatibility: ethereum => homestead\n  if (network.name === 'ethereum' && network.chainId === 1) {\n    network = { ...network,\n      name: 'homestead'\n    };\n  }\n\n  if (ethereumProvider) {\n    try {\n      return new ethers.providers.Web3Provider(ethereumProvider, network);\n    } catch (err) {\n      console.error('Invalid provider:', ethereumProvider);\n      throw err;\n    }\n  }\n\n  if (network.chainId === 100) {\n    return new ethers.providers.WebSocketProvider(XDAI_WSS_ENDPOINT, network);\n  }\n\n  return ethers.getDefaultProvider(network);\n}\n\nasync function resolveAddress(ethersProvider, location) {\n  const address = ethers.utils.isAddress(location) ? location : await ethersProvider.resolveName(location);\n\n  if (!ethers.utils.isAddress(address)) {\n    throw new Error('Please provide a valid address or ENS domain.');\n  }\n\n  return address;\n}\n\nasync function connect(location, connector, {\n  actAs,\n  ethereum: ethereumProvider,\n  ipfs,\n  network,\n  verbose\n} = {}) {\n  var _a;\n\n  const _network = toNetwork(network !== null && network !== void 0 ? network : 'ethereum');\n\n  const ethersProvider = getEthersProvider(ethereumProvider, _network);\n  const orgConnector = getConnector(connector, _network);\n  const orgAddress = await resolveAddress(ethersProvider, location);\n  const connectionContext = {\n    actAs: actAs || null,\n    ethereumProvider: ethereumProvider || null,\n    ethersProvider,\n    ipfs: getIpfsResolver(ipfs),\n    network: _network,\n    orgAddress,\n    orgConnector,\n    orgLocation: location,\n    verbose: verbose !== null && verbose !== void 0 ? verbose : false\n  };\n  await ((_a = orgConnector.connect) === null || _a === void 0 ? void 0 : _a.call(orgConnector, connectionContext));\n  return new Organization(connectionContext);\n}\n\nexport default connect;","map":null,"metadata":{},"sourceType":"module"}