{"ast":null,"code":"import { connect, describeScript, findAppMethodFromIntent } from '@aragon/connect';\nimport { getContract } from '../web3-contracts';\nimport { logWithSentry } from '../sentry';\nimport env from '../environment';\nimport { DISPUTABLE_ACTIONS } from './mappings';\nimport { getAragonSubgraph } from './connect-endpoints';\nimport { addressesEqual, getNetworkType } from '../lib/web3-utils';\nimport { buildArbitrableUrl, isArbitrableKnown } from './known-arbitrables'; // Disputable abi\n\nimport disputableAbi from '../abi/disputables/IDisputable.json';\nconst cachedDescriptions = new Map([]);\nconst ERROR_MSG = 'Failed to fetch disputed action';\n/**\n * Get disputable long and short description as well as the URL where the disputed action is taking place\n * @param {String} disputeId Id of the dispute\n * @param {String} organization Address of the organization where the action is being disputed\n * @param {String} disputableAddress Address of the disputable app where the disputed action is taking place\n * @param {String} disputableActionId Disputed action's id relative to the disputable app (e.g. in the context of a disputable voting app, vote #6)\n * @param {String} arbitrableAddress Address of the arbitrable\n * @returns {Object} Object containing the disputed action short and long description as well as the URL.\n */\n\nexport async function describeDisputedAction(disputeId, organization, disputableAddress, disputableActionId, arbitrableAddress) {\n  try {\n    if (cachedDescriptions.has(disputeId)) {\n      return cachedDescriptions.get(disputeId);\n    } // Get disputable appId\n\n\n    const disputableContract = getContract(disputableAddress, disputableAbi);\n    const appId = await disputableContract.appId();\n\n    if (DISPUTABLE_ACTIONS.has(appId)) {\n      const {\n        entityPath,\n        scriptExtractor\n      } = DISPUTABLE_ACTIONS.get(appId);\n      const evmScript = await scriptExtractor(disputableAddress, disputableActionId, appId);\n      const disputedActionURL = buildDisputedActionUrl(organization, disputableAddress, entityPath, disputableActionId, arbitrableAddress);\n      const [disputedActionRadspec, disputedActionText, executionPath] = await describeActionScript(evmScript, organization); // Get long and short description corresponding to the disputed action.\n\n      const disputedActionDescription = {\n        disputedActionRadspec,\n        disputedActionText,\n        // Build URL where the disputed action is taking place\n        disputedActionURL,\n        // Transaction path\n        executionPath\n      }; // Cache disputed action description\n\n      cachedDescriptions.set(disputeId, disputedActionDescription);\n      return disputedActionDescription;\n    }\n  } catch (err) {\n    console.error('Error describing disputable action', err);\n    logWithSentry(`'Error describing disputable action ${err}`);\n  }\n\n  return {\n    disputedActionRadspec: ERROR_MSG\n  };\n}\n/**\n * Describes the disputed action script using @aragon/connect\n * @param {String} evmScript The EVM script to describe\n * @param {String} organization Address of the organization in question\n * @returns {Array} Array of items where the first item is an array of transaction requests in the path of the disputed action\n *                    and the second item, the app belonging to the organization where the disputed action is taking place.\n */\n\nasync function describeActionScript(evmScript, organization) {\n  // No EVM script, means it's not an executable action (e.g. signaling vote)\n  if (evmScript === '0x') {\n    return [];\n  }\n\n  const org = await connect(organization, ['thegraph', {\n    orgSubgraphUrl: getAragonSubgraph()\n  }], // TODO: Remove when @aragon/connect defaults to own node subgraph urls\n  {\n    network: env('CHAIN_ID')\n  });\n  const apps = await org.apps();\n  const transactionRequests = (await describeScript(evmScript, apps, org.provider)) || [];\n\n  if (!transactionRequests.length) {\n    return [ERROR_MSG];\n  } // Get disputed action long description\n\n\n  const disputedActionRadspec = buildDisputedActionRadspec(transactionRequests); // In order to get the terminal action/s we must search through the `transactionRequests` children (if any)\n\n  const terminalActions = getTerminalActions(transactionRequests);\n  const executionPath = contextualizeExecutionPath(transactionRequests, apps); // Get disputed action short text\n  // In most cases we'll have just a single action to describe\n  // If we do have multiple, we use the first action.\n\n  const terminalAction = terminalActions[0];\n  const terminalActionAppAddress = terminalAction.to; // Find the App object corresponding to the app where the terminal action will take place\n\n  const app = apps.find(app => addressesEqual(app.address, terminalActionAppAddress)); // Get disputed action short text\n  // Find method corresponding to the function of the disputed action.\n\n  const method = await findAppMethodFromIntent(app, terminalAction);\n  const disputedActionText = method ? buildDisputedActionText(app, method) : '';\n  return [disputedActionRadspec, disputedActionText, executionPath];\n}\n/**\n * Gets the array of all children transactions belonging to first step transactions in a forwarding path\n * @param {Array} transactions Array of transactions corresponding to the first step in a forwarding path\n * @returns {Array} Array of all childrens.\n */\n\n\nfunction getTerminalActions(transactions) {\n  return transactions.map(transaction => transaction.children ? getTerminalActions(transaction.children) : transaction).flat();\n}\n/**\n * Gets execution path specified by `transactions`\n * @param {Array} transactions Array of transactions in the execution path\n * @param {Array} apps Array of all the org's apps\n * @returns {Array} Execution path\n */\n\n\nfunction contextualizeExecutionPath(transactions, apps) {\n  return transactions.map(transaction => {\n    const {\n      name\n    } = apps.find(app => addressesEqual(app.address, transaction.to)) || {};\n    const appName = name ? describeAppName(name) : 'Unknown app';\n    return { ...transaction,\n      appName,\n      children: transaction.children ? contextualizeExecutionPath(transaction.children, apps) : []\n    };\n  });\n}\n/**\n * Describes function signature (e.g grantPermission => Grant permission)\n * @param {String} sig Signature of the function to describe\n * @returns {String} Described signature\n */\n\n\nfunction describeFunctionSig(sig) {\n  return sig.replace(/\\(.*?\\)/, '').split(/(?=[A-Z])/).map((s, index) => index === 0 ? capitalize(s) : s.toLowerCase()).join(' ');\n}\n/**\n * Builds the disputed action short description\n * @param {App} app App where the disputed terminal action will take place\n * @param {Object} method Method corresponding to the disputed terminal action function\n * @returns {String} Short description of the disputed action\n */\n\n\nfunction buildDisputedActionText(app, method) {\n  const {\n    artifact,\n    name,\n    appId\n  } = app;\n  const role = artifact.roles.find(role => method.roles.includes(role.id)); // If the terminal action function is not protected by a role, we'll try to describe the function signature\n  // (e.g grantPermission would become Grant permission)\n\n  const actionText = (role === null || role === void 0 ? void 0 : role.name) || describeFunctionSig(method.sig); // If `name` is null most likely means the app is Kernel or ACL\n\n  const appName = name ? describeAppName(name) : `Unknown app (${appId})`;\n  return `${appName}: ${actionText}`;\n}\n/**\n * Builds the disputed action radspec description\n * Assumes array of transactions not empty\n * @param {Array<Object>} transactions Transactions in the disputed action path\n * @returns {String} Radspec description of the disputed action\n */\n\n\nfunction buildDisputedActionRadspec(transactions) {\n  return transactions.map(step => {\n    return `${step.description || 'No description'}`;\n  }).join('\\n');\n}\n/**\n * Builds the URL corresponding to the disputed action. (e.g the URL of a vote)\n * @param {String} organization Address of the organization\n * @param {String} appAddress Address of the app\n * @param {String} entityPath Entity where the action is being disputed (e.g vote, delay, etc)\n * @param {String} actionId Disputable action id\n * @param {String} arbitrableAddress Address of the arbitrable\n * @returns {String} URL of the disputed action.\n */\n\n\nfunction buildDisputedActionUrl(organization, appAddress, entityPath, actionId, arbitrableAddress) {\n  const networkType = getNetworkType();\n  const arbitrableKnown = isArbitrableKnown(arbitrableAddress, networkType);\n  let url;\n\n  if (arbitrableKnown) {\n    url = buildArbitrableUrl(arbitrableAddress, actionId, networkType);\n  } else {\n    // Fallback to Aragon client url\n    url = buildClientUrl(organization, appAddress, entityPath, actionId, networkType);\n  }\n\n  return url;\n}\n/**\n * Builds URL of the organization in the Aragon client\n * @param {String} organization Address of the organization in question\n * @param {String} appAddress Address of the app\n * @param {String} entityPath Realtive path where the disputed action is taking place\n * @param {String} actionId Id of the disputed action in the context of the disputable app\n * @param {String} networkType The network type\n * @returns {String} URL of the organization\n */\n\n\nfunction buildClientUrl(organization, appAddress, entityPath, actionId, networkType) {\n  return [`http://localhost:300/#/${organization}`, appAddress, entityPath, actionId].join('/');\n}\n\nconst describeAppName = appName => appName.split('-').map(capitalize).join(' ');\n\nconst capitalize = str => str.charAt(0).toUpperCase() + str.slice(1);","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/disputables/index.js"],"names":["connect","describeScript","findAppMethodFromIntent","getContract","logWithSentry","env","DISPUTABLE_ACTIONS","getAragonSubgraph","addressesEqual","getNetworkType","buildArbitrableUrl","isArbitrableKnown","disputableAbi","cachedDescriptions","Map","ERROR_MSG","describeDisputedAction","disputeId","organization","disputableAddress","disputableActionId","arbitrableAddress","has","get","disputableContract","appId","entityPath","scriptExtractor","evmScript","disputedActionURL","buildDisputedActionUrl","disputedActionRadspec","disputedActionText","executionPath","describeActionScript","disputedActionDescription","set","err","console","error","org","orgSubgraphUrl","network","apps","transactionRequests","provider","length","buildDisputedActionRadspec","terminalActions","getTerminalActions","contextualizeExecutionPath","terminalAction","terminalActionAppAddress","to","app","find","address","method","buildDisputedActionText","transactions","map","transaction","children","flat","name","appName","describeAppName","describeFunctionSig","sig","replace","split","s","index","capitalize","toLowerCase","join","artifact","role","roles","includes","id","actionText","step","description","appAddress","actionId","networkType","arbitrableKnown","url","buildClientUrl","str","charAt","toUpperCase","slice"],"mappings":"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","sourcesContent":["import {\n  connect,\n  describeScript,\n  findAppMethodFromIntent,\n} from '@aragon/connect'\nimport { getContract } from '../web3-contracts'\nimport { logWithSentry } from '../sentry'\n\nimport env from '../environment'\nimport { DISPUTABLE_ACTIONS } from './mappings'\nimport { getAragonSubgraph } from './connect-endpoints'\nimport { addressesEqual, getNetworkType } from '../lib/web3-utils'\nimport { buildArbitrableUrl, isArbitrableKnown } from './known-arbitrables'\n\n// Disputable abi\nimport disputableAbi from '../abi/disputables/IDisputable.json'\n\nconst cachedDescriptions = new Map([])\n\nconst ERROR_MSG = 'Failed to fetch disputed action'\n\n/**\n * Get disputable long and short description as well as the URL where the disputed action is taking place\n * @param {String} disputeId Id of the dispute\n * @param {String} organization Address of the organization where the action is being disputed\n * @param {String} disputableAddress Address of the disputable app where the disputed action is taking place\n * @param {String} disputableActionId Disputed action's id relative to the disputable app (e.g. in the context of a disputable voting app, vote #6)\n * @param {String} arbitrableAddress Address of the arbitrable\n * @returns {Object} Object containing the disputed action short and long description as well as the URL.\n */\nexport async function describeDisputedAction(\n  disputeId,\n  organization,\n  disputableAddress,\n  disputableActionId,\n  arbitrableAddress\n) {\n  try {\n    if (cachedDescriptions.has(disputeId)) {\n      return cachedDescriptions.get(disputeId)\n    }\n    // Get disputable appId\n    const disputableContract = getContract(disputableAddress, disputableAbi)\n    const appId = await disputableContract.appId()\n\n    if (DISPUTABLE_ACTIONS.has(appId)) {\n      const { entityPath, scriptExtractor } = DISPUTABLE_ACTIONS.get(appId)\n\n      const evmScript = await scriptExtractor(\n        disputableAddress,\n        disputableActionId,\n        appId\n      )\n\n      const disputedActionURL = buildDisputedActionUrl(\n        organization,\n        disputableAddress,\n        entityPath,\n        disputableActionId,\n        arbitrableAddress\n      )\n\n      const [\n        disputedActionRadspec,\n        disputedActionText,\n        executionPath,\n      ] = await describeActionScript(evmScript, organization)\n\n      // Get long and short description corresponding to the disputed action.\n\n      const disputedActionDescription = {\n        disputedActionRadspec,\n        disputedActionText,\n\n        // Build URL where the disputed action is taking place\n        disputedActionURL,\n\n        // Transaction path\n        executionPath,\n      }\n\n      // Cache disputed action description\n      cachedDescriptions.set(disputeId, disputedActionDescription)\n\n      return disputedActionDescription\n    }\n  } catch (err) {\n    console.error('Error describing disputable action', err)\n    logWithSentry(`'Error describing disputable action ${err}`)\n  }\n\n  return { disputedActionRadspec: ERROR_MSG }\n}\n\n/**\n * Describes the disputed action script using @aragon/connect\n * @param {String} evmScript The EVM script to describe\n * @param {String} organization Address of the organization in question\n * @returns {Array} Array of items where the first item is an array of transaction requests in the path of the disputed action\n *                    and the second item, the app belonging to the organization where the disputed action is taking place.\n */\nasync function describeActionScript(evmScript, organization) {\n  // No EVM script, means it's not an executable action (e.g. signaling vote)\n  if (evmScript === '0x') {\n    return []\n  }\n\n  const org = await connect(\n    organization,\n    ['thegraph', { orgSubgraphUrl: getAragonSubgraph() }], // TODO: Remove when @aragon/connect defaults to own node subgraph urls\n    {\n      network: env('CHAIN_ID'),\n    }\n  )\n  const apps = await org.apps()\n\n  const transactionRequests =\n    (await describeScript(evmScript, apps, org.provider)) || []\n\n  if (!transactionRequests.length) {\n    return [ERROR_MSG]\n  }\n\n  // Get disputed action long description\n  const disputedActionRadspec = buildDisputedActionRadspec(transactionRequests)\n  // In order to get the terminal action/s we must search through the `transactionRequests` children (if any)\n  const terminalActions = getTerminalActions(transactionRequests)\n  const executionPath = contextualizeExecutionPath(transactionRequests, apps)\n\n  // Get disputed action short text\n  // In most cases we'll have just a single action to describe\n  // If we do have multiple, we use the first action.\n  const terminalAction = terminalActions[0]\n  const terminalActionAppAddress = terminalAction.to\n\n  // Find the App object corresponding to the app where the terminal action will take place\n  const app = apps.find(app =>\n    addressesEqual(app.address, terminalActionAppAddress)\n  )\n\n  // Get disputed action short text\n  // Find method corresponding to the function of the disputed action.\n  const method = await findAppMethodFromIntent(app, terminalAction)\n  const disputedActionText = method ? buildDisputedActionText(app, method) : ''\n\n  return [disputedActionRadspec, disputedActionText, executionPath]\n}\n\n/**\n * Gets the array of all children transactions belonging to first step transactions in a forwarding path\n * @param {Array} transactions Array of transactions corresponding to the first step in a forwarding path\n * @returns {Array} Array of all childrens.\n */\nfunction getTerminalActions(transactions) {\n  return transactions\n    .map(transaction =>\n      transaction.children\n        ? getTerminalActions(transaction.children)\n        : transaction\n    )\n    .flat()\n}\n\n/**\n * Gets execution path specified by `transactions`\n * @param {Array} transactions Array of transactions in the execution path\n * @param {Array} apps Array of all the org's apps\n * @returns {Array} Execution path\n */\nfunction contextualizeExecutionPath(transactions, apps) {\n  return transactions.map(transaction => {\n    const { name } =\n      apps.find(app => addressesEqual(app.address, transaction.to)) || {}\n    const appName = name ? describeAppName(name) : 'Unknown app'\n\n    return {\n      ...transaction,\n      appName,\n      children: transaction.children\n        ? contextualizeExecutionPath(transaction.children, apps)\n        : [],\n    }\n  })\n}\n\n/**\n * Describes function signature (e.g grantPermission => Grant permission)\n * @param {String} sig Signature of the function to describe\n * @returns {String} Described signature\n */\nfunction describeFunctionSig(sig) {\n  return sig\n    .replace(/\\(.*?\\)/, '')\n    .split(/(?=[A-Z])/)\n    .map((s, index) => (index === 0 ? capitalize(s) : s.toLowerCase()))\n    .join(' ')\n}\n\n/**\n * Builds the disputed action short description\n * @param {App} app App where the disputed terminal action will take place\n * @param {Object} method Method corresponding to the disputed terminal action function\n * @returns {String} Short description of the disputed action\n */\nfunction buildDisputedActionText(app, method) {\n  const { artifact, name, appId } = app\n  const role = artifact.roles.find(role => method.roles.includes(role.id))\n\n  // If the terminal action function is not protected by a role, we'll try to describe the function signature\n  // (e.g grantPermission would become Grant permission)\n  const actionText = role?.name || describeFunctionSig(method.sig)\n\n  // If `name` is null most likely means the app is Kernel or ACL\n  const appName = name ? describeAppName(name) : `Unknown app (${appId})`\n\n  return `${appName}: ${actionText}`\n}\n\n/**\n * Builds the disputed action radspec description\n * Assumes array of transactions not empty\n * @param {Array<Object>} transactions Transactions in the disputed action path\n * @returns {String} Radspec description of the disputed action\n */\nfunction buildDisputedActionRadspec(transactions) {\n  return transactions\n    .map(step => {\n      return `${step.description || 'No description'}`\n    })\n    .join('\\n')\n}\n\n/**\n * Builds the URL corresponding to the disputed action. (e.g the URL of a vote)\n * @param {String} organization Address of the organization\n * @param {String} appAddress Address of the app\n * @param {String} entityPath Entity where the action is being disputed (e.g vote, delay, etc)\n * @param {String} actionId Disputable action id\n * @param {String} arbitrableAddress Address of the arbitrable\n * @returns {String} URL of the disputed action.\n */\nfunction buildDisputedActionUrl(\n  organization,\n  appAddress,\n  entityPath,\n  actionId,\n  arbitrableAddress\n) {\n  const networkType = getNetworkType()\n  const arbitrableKnown = isArbitrableKnown(arbitrableAddress, networkType)\n\n  let url\n  if (arbitrableKnown) {\n    url = buildArbitrableUrl(arbitrableAddress, actionId, networkType)\n  } else {\n    // Fallback to Aragon client url\n    url = buildClientUrl(\n      organization,\n      appAddress,\n      entityPath,\n      actionId,\n      networkType\n    )\n  }\n\n  return url\n}\n\n/**\n * Builds URL of the organization in the Aragon client\n * @param {String} organization Address of the organization in question\n * @param {String} appAddress Address of the app\n * @param {String} entityPath Realtive path where the disputed action is taking place\n * @param {String} actionId Id of the disputed action in the context of the disputable app\n * @param {String} networkType The network type\n * @returns {String} URL of the organization\n */\nfunction buildClientUrl(\n  organization,\n  appAddress,\n  entityPath,\n  actionId,\n  networkType\n) {\n  return [\n    `http://localhost:300/#/${organization}`,\n    appAddress,\n    entityPath,\n    actionId,\n  ].join('/')\n}\n\nconst describeAppName = appName =>\n  appName\n    .split('-')\n    .map(capitalize)\n    .join(' ')\n\nconst capitalize = str => str.charAt(0).toUpperCase() + str.slice(1)\n"]},"metadata":{},"sourceType":"module"}