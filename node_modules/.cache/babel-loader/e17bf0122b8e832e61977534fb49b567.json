{"ast":null,"code":"import _objectSpread from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _objectWithoutProperties from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";import _slicedToArray from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _toConsumableArray from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import{useMemo}from'react';import{useDashboardState}from'../components/Dashboard/DashboardStateProvider';import{useCourtConfig}from'../providers/CourtConfig';import{bigNum}from'../lib/math-utils';import{isJurorCoherent}from'../utils/juror-draft-utils';import{getAppealerFees,shouldAppealerBeRewarded}from'../utils/appeal-utils';import{getRoundFees}from'../utils/dispute-utils';import{useWallet}from'../providers/Wallet';import{useJurorLastWithdrawalTimeSubscription}from'./subscription-hooks';export default function useJurorRewards(){var courtConfig=useCourtConfig();var wallet=useWallet();var _useDashboardState=useDashboardState(),jurorDrafts=_useDashboardState.jurorDrafts,appeals=_useDashboardState.appeals;var lastWithdrawalTime=useJurorLastWithdrawalTimeSubscription(wallet.account);// For arbitrable and appeal fees we will use a map where map = [disputeId, { amount, rounds }]\n// Where `rounds` is the array of roundIds of non settled rounds\n// This is useful as jurors could have rewards from many rounds for the same dispute\n// which will need to be settled (in case they aren't) before withdrawing them from the treasury\nreturn useMemo(function(){if(!jurorDrafts||!appeals||!lastWithdrawalTime)return null;// Get ruling and disputes fees\n// Only jurors that voted in consensus with the winning outcome can claim rewards (coherent jurors)\n// We also include already settled rewards which have not been withdrawn from the treasury yet.\nvar _jurorDrafts$filter$r=jurorDrafts.filter(function(jurorDraft){return jurorDraft.round.settledPenalties&&(!jurorDraft.rewarded||jurorDraft.rewardedAt>lastWithdrawalTime)&&isJurorCoherent(jurorDraft);}).reduce(function(_ref,_ref2){var rulingFees=_ref.rulingFees,arbitrableFees=_ref.arbitrableFees;var rewarded=_ref2.rewarded,round=_ref2.round,weight=_ref2.weight;var jurorFees=round.jurorFees,coherentJurors=round.coherentJurors,collectedTokens=round.collectedTokens,dispute=round.dispute;// Calculate fees\nvar rulingFeesAmount=collectedTokens.mul(weight).div(coherentJurors);var disputeFeesAmount=jurorFees.mul(weight).div(coherentJurors);return{rulingFees:rulingFees.add(rulingFeesAmount),arbitrableFees:setOrUpdateFee(arbitrableFees,dispute.id,round.number,disputeFeesAmount,rewarded)};},{rulingFees:bigNum(0),arbitrableFees:new Map()}),rulingFees=_jurorDrafts$filter$r.rulingFees,arbitrableFees=_jurorDrafts$filter$r.arbitrableFees;// Before settling appeals it's required that the penalties for the round are settled, so we need to filter the ones that aren't\n// We also need to check that the appealer should be rewarded.\nvar appealFees=appeals.filter(function(appeal){return appeal.round.settledPenalties&&(!appeal.settled||appeal.settledAt>lastWithdrawalTime)&&shouldAppealerBeRewarded(appeal,wallet.account);}).reduce(function(appealsFee,appeal){var round=appeal.round,settled=appeal.settled;// We need to calculate the totalFees of the next round since this amount will be discounted from the appeal reward for the appealer\nvar nextRoundId=round.number+1;var nextRound=round.dispute.rounds[nextRoundId];// It could happen that the appeal is never confirmed. In this case the appealer should get the entire appeal deposit\nvar totalFees=nextRound?getRoundFees(nextRound,courtConfig):bigNum(0);var appealerFees=getAppealerFees(appeal,totalFees,wallet.account);return setOrUpdateFee(appealsFee,round.dispute.id,round.number,appealerFees,settled);},new Map());return{anjRewards:rulingFees,feeRewards:{arbitrableFees:feeMapToArray(arbitrableFees),appealFees:feeMapToArray(appealFees),distribution:getDisputesFeesDistribution(arbitrableFees,appealFees)}};},[appeals,courtConfig,jurorDrafts,lastWithdrawalTime,wallet]);}/**\n * Adds or updates a fee entry on the map\n * @param {Map} feeMap Map contianing fee data\n * @param {Number} disputeId Id of the dispute\n * @param {Number} roundId Id of the round\n * @param {BigNum} feeAmount Amount of fees to add to the entry\n * @param {Boolean} settled True if fees for the given round are settled\n * @returns {Map} Updated map with the new entry or the amount updated\n */function setOrUpdateFee(feeMap,disputeId,roundId,feeAmount){var settled=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var feeEntry;if(feeMap.has(disputeId)){var _feeMap$get=feeMap.get(disputeId),amount=_feeMap$get.amount,rounds=_feeMap$get.rounds,settledAmount=_feeMap$get.settledAmount;feeEntry={amount:amount.add(feeAmount),settledAmount:settled?settledAmount.add(feeAmount):settledAmount,rounds:[].concat(_toConsumableArray(rounds),_toConsumableArray(settled?[]:[roundId]))};}else{feeEntry={amount:feeAmount,settledAmount:settled?feeAmount:bigNum(0),rounds:settled?[]:[roundId]};}feeMap.set(disputeId,feeEntry);return feeMap;}/**\n * Creates a new array containing the total amount of fees per dispute\n * @param {Map} artbitrableFeesMap Map of arbitrable fees\n * @param {Map} appealFeesMap Map of appeal fees\n * @returns {Array} New array with the total fees for each dispute\n */function getDisputesFeesDistribution(artbitrableFeesMap,appealFeesMap){var appealFeesMapCopy=new Map(_toConsumableArray(appealFeesMap));var disputeFees=[];var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=artbitrableFeesMap.entries()[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var _step$value=_slicedToArray(_step.value,2),disputeId=_step$value[0],amount=_step$value[1].amount;var totalFeeAmount=amount;if(appealFeesMapCopy.has(disputeId)){var appealFee=appealFeesMap.get(disputeId);totalFeeAmount=totalFeeAmount.add(appealFee.amount);appealFeesMapCopy.delete(disputeId);}disputeFees.push({disputeId:disputeId,amount:totalFeeAmount});}// Add the reaminaing appealing fees in case there wasn't an arbitrable reward in the remaining disputes\n}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=appealFeesMapCopy.entries()[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var _step2$value=_slicedToArray(_step2.value,2),_disputeId=_step2$value[0],_amount=_step2$value[1].amount;disputeFees.push({disputeId:_disputeId,amount:_amount});}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator2.return!=null){_iterator2.return();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}return disputeFees;}/**\n * Converts Map into Array\n * @param {Map} feeMap Map to convert to an array\n * @returns {Array} New array containing map data\n */function feeMapToArray(feeMap){var arr=[];var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=feeMap[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var _ref4=_step3.value;var _ref5=_slicedToArray(_ref4,2),disputeId=_ref5[0],_ref5$=_ref5[1],rounds=_ref5$.rounds,feeEntry=_objectWithoutProperties(_ref5$,[\"rounds\"]);arr.push(_objectSpread({disputeId:disputeId},feeEntry,{rounds:rounds.sort()}));}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally{try{if(!_iteratorNormalCompletion3&&_iterator3.return!=null){_iterator3.return();}}finally{if(_didIteratorError3){throw _iteratorError3;}}}return arr;}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useJurorRewards.js"],"names":["useMemo","useDashboardState","useCourtConfig","bigNum","isJurorCoherent","getAppealerFees","shouldAppealerBeRewarded","getRoundFees","useWallet","useJurorLastWithdrawalTimeSubscription","useJurorRewards","courtConfig","wallet","jurorDrafts","appeals","lastWithdrawalTime","account","filter","jurorDraft","round","settledPenalties","rewarded","rewardedAt","reduce","rulingFees","arbitrableFees","weight","jurorFees","coherentJurors","collectedTokens","dispute","rulingFeesAmount","mul","div","disputeFeesAmount","add","setOrUpdateFee","id","number","Map","appealFees","appeal","settled","settledAt","appealsFee","nextRoundId","nextRound","rounds","totalFees","appealerFees","anjRewards","feeRewards","feeMapToArray","distribution","getDisputesFeesDistribution","feeMap","disputeId","roundId","feeAmount","feeEntry","has","get","amount","settledAmount","set","artbitrableFeesMap","appealFeesMap","appealFeesMapCopy","disputeFees","entries","totalFeeAmount","appealFee","delete","push","arr","sort"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\nimport { useDashboardState } from '../components/Dashboard/DashboardStateProvider'\nimport { useCourtConfig } from '../providers/CourtConfig'\nimport { bigNum } from '../lib/math-utils'\nimport { isJurorCoherent } from '../utils/juror-draft-utils'\nimport {\n  getAppealerFees,\n  shouldAppealerBeRewarded,\n} from '../utils/appeal-utils'\nimport { getRoundFees } from '../utils/dispute-utils'\nimport { useWallet } from '../providers/Wallet'\nimport { useJurorLastWithdrawalTimeSubscription } from './subscription-hooks'\n\nexport default function useJurorRewards() {\n  const courtConfig = useCourtConfig()\n  const wallet = useWallet()\n  const { jurorDrafts, appeals } = useDashboardState()\n  const lastWithdrawalTime = useJurorLastWithdrawalTimeSubscription(\n    wallet.account\n  )\n\n  // For arbitrable and appeal fees we will use a map where map = [disputeId, { amount, rounds }]\n  // Where `rounds` is the array of roundIds of non settled rounds\n  // This is useful as jurors could have rewards from many rounds for the same dispute\n  // which will need to be settled (in case they aren't) before withdrawing them from the treasury\n  return useMemo(() => {\n    if (!jurorDrafts || !appeals || !lastWithdrawalTime) return null\n\n    // Get ruling and disputes fees\n    // Only jurors that voted in consensus with the winning outcome can claim rewards (coherent jurors)\n    // We also include already settled rewards which have not been withdrawn from the treasury yet.\n    const { rulingFees, arbitrableFees } = jurorDrafts\n      .filter(\n        jurorDraft =>\n          jurorDraft.round.settledPenalties &&\n          (!jurorDraft.rewarded ||\n            jurorDraft.rewardedAt > lastWithdrawalTime) &&\n          isJurorCoherent(jurorDraft)\n      )\n      .reduce(\n        ({ rulingFees, arbitrableFees }, { rewarded, round, weight }) => {\n          const { jurorFees, coherentJurors, collectedTokens, dispute } = round\n\n          // Calculate fees\n          const rulingFeesAmount = collectedTokens\n            .mul(weight)\n            .div(coherentJurors)\n\n          const disputeFeesAmount = jurorFees.mul(weight).div(coherentJurors)\n\n          return {\n            rulingFees: rulingFees.add(rulingFeesAmount),\n            arbitrableFees: setOrUpdateFee(\n              arbitrableFees,\n              dispute.id,\n              round.number,\n              disputeFeesAmount,\n              rewarded\n            ),\n          }\n        },\n        { rulingFees: bigNum(0), arbitrableFees: new Map() }\n      )\n\n    // Before settling appeals it's required that the penalties for the round are settled, so we need to filter the ones that aren't\n    // We also need to check that the appealer should be rewarded.\n    const appealFees = appeals\n      .filter(\n        appeal =>\n          appeal.round.settledPenalties &&\n          (!appeal.settled || appeal.settledAt > lastWithdrawalTime) &&\n          shouldAppealerBeRewarded(appeal, wallet.account)\n      )\n      .reduce((appealsFee, appeal) => {\n        const { round, settled } = appeal\n\n        // We need to calculate the totalFees of the next round since this amount will be discounted from the appeal reward for the appealer\n        const nextRoundId = round.number + 1\n        const nextRound = round.dispute.rounds[nextRoundId]\n\n        // It could happen that the appeal is never confirmed. In this case the appealer should get the entire appeal deposit\n        const totalFees = nextRound\n          ? getRoundFees(nextRound, courtConfig)\n          : bigNum(0)\n\n        const appealerFees = getAppealerFees(appeal, totalFees, wallet.account)\n\n        return setOrUpdateFee(\n          appealsFee,\n          round.dispute.id,\n          round.number,\n          appealerFees,\n          settled\n        )\n      }, new Map())\n\n    return {\n      anjRewards: rulingFees,\n      feeRewards: {\n        arbitrableFees: feeMapToArray(arbitrableFees),\n        appealFees: feeMapToArray(appealFees),\n        distribution: getDisputesFeesDistribution(arbitrableFees, appealFees),\n      },\n    }\n  }, [appeals, courtConfig, jurorDrafts, lastWithdrawalTime, wallet])\n}\n\n/**\n * Adds or updates a fee entry on the map\n * @param {Map} feeMap Map contianing fee data\n * @param {Number} disputeId Id of the dispute\n * @param {Number} roundId Id of the round\n * @param {BigNum} feeAmount Amount of fees to add to the entry\n * @param {Boolean} settled True if fees for the given round are settled\n * @returns {Map} Updated map with the new entry or the amount updated\n */\nfunction setOrUpdateFee(\n  feeMap,\n  disputeId,\n  roundId,\n  feeAmount,\n  settled = false\n) {\n  let feeEntry\n\n  if (feeMap.has(disputeId)) {\n    const { amount, rounds, settledAmount } = feeMap.get(disputeId)\n    feeEntry = {\n      amount: amount.add(feeAmount),\n      settledAmount: settled ? settledAmount.add(feeAmount) : settledAmount,\n      rounds: [...rounds, ...(settled ? [] : [roundId])],\n    }\n  } else {\n    feeEntry = {\n      amount: feeAmount,\n      settledAmount: settled ? feeAmount : bigNum(0),\n      rounds: settled ? [] : [roundId],\n    }\n  }\n\n  feeMap.set(disputeId, feeEntry)\n  return feeMap\n}\n\n/**\n * Creates a new array containing the total amount of fees per dispute\n * @param {Map} artbitrableFeesMap Map of arbitrable fees\n * @param {Map} appealFeesMap Map of appeal fees\n * @returns {Array} New array with the total fees for each dispute\n */\n\nfunction getDisputesFeesDistribution(artbitrableFeesMap, appealFeesMap) {\n  const appealFeesMapCopy = new Map([...appealFeesMap])\n\n  const disputeFees = []\n  for (const [disputeId, { amount }] of artbitrableFeesMap.entries()) {\n    let totalFeeAmount = amount\n\n    if (appealFeesMapCopy.has(disputeId)) {\n      const appealFee = appealFeesMap.get(disputeId)\n      totalFeeAmount = totalFeeAmount.add(appealFee.amount)\n      appealFeesMapCopy.delete(disputeId)\n    }\n\n    disputeFees.push({ disputeId, amount: totalFeeAmount })\n  }\n\n  // Add the reaminaing appealing fees in case there wasn't an arbitrable reward in the remaining disputes\n  for (const [disputeId, { amount }] of appealFeesMapCopy.entries()) {\n    disputeFees.push({ disputeId, amount })\n  }\n\n  return disputeFees\n}\n\n/**\n * Converts Map into Array\n * @param {Map} feeMap Map to convert to an array\n * @returns {Array} New array containing map data\n */\nfunction feeMapToArray(feeMap) {\n  const arr = []\n  for (const [disputeId, { rounds, ...feeEntry }] of feeMap) {\n    arr.push({\n      disputeId,\n      ...feeEntry,\n      rounds: rounds.sort(),\n    })\n  }\n\n  return arr\n}\n"]},"metadata":{},"sourceType":"module"}