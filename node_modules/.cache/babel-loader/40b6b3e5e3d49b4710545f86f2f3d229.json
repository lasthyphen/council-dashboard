{"ast":null,"code":"import _regeneratorRuntime from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction normalizeConnectorConfig(connector) {\n  var _a;\n\n  if (Array.isArray(connector)) {\n    // Returning `{} as Config` shouldn’t be an issue, because the config type\n    // of an app connector should have all its properties declared as optional.\n    return [connector[0], (_a = connector[1]) !== null && _a !== void 0 ? _a : {}];\n  }\n\n  if (typeof connector === 'string') {\n    return [connector, {}];\n  }\n\n  throw new Error('The connector should be passed as a string or an array.');\n} // Check if an app is valid. We are not using instanceof here, because the\n// passed app might come from the final app dependency, while @connect-core\n// might come from the app connector they are using, with two different\n// versions. It also makes it easier to work with linked dependencies, as it\n// creates the same kind of issues.\n\n\nfunction isAppValid(app) {\n  return app && app.name && app.address && app.appId && app.version;\n}\n\nexport function createAppConnector(callback) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _connect = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(app, connector) {\n        var connection, orgConnector, _normalizeConnectorCo, _normalizeConnectorCo2, connectorName, connectorConfig, connectedApp;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return app;\n\n              case 2:\n                app = _context.sent;\n\n                if (isAppValid(app)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"App connector: the passed value doesn\\u2019t appear to be an App.\");\n\n              case 5:\n                connection = app.organization.connection;\n                orgConnector = connection.orgConnector; // App connector config.\n\n                _normalizeConnectorCo = normalizeConnectorConfig( // Contrary to the main connect() function, app connectors don’t require\n                // the connector to be passed. In this case, the name of the org\n                // connector (e.g. `name`) is used instead.\n                connector || orgConnector.name), _normalizeConnectorCo2 = _slicedToArray(_normalizeConnectorCo, 2), connectorName = _normalizeConnectorCo2[0], connectorConfig = _normalizeConnectorCo2[1];\n                _context.next = 10;\n                return callback({\n                  app: app,\n                  config: connectorConfig,\n                  connector: connectorName,\n                  ipfs: connection.ipfs,\n                  network: orgConnector.network,\n                  orgConnector: orgConnector,\n                  verbose: connection.verbose\n                });\n\n              case 10:\n                connectedApp = _context.sent;\n                return _context.abrupt(\"return\", Object.assign(connectedApp, app));\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function connect(_x, _x2) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  );\n}","map":null,"metadata":{},"sourceType":"module"}