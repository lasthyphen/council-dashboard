{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n};\n\nvar _client, _pollInterval, _verbose;\n\nimport fetch from 'isomorphic-unfetch';\nimport { Client, createRequest as createRequestUrql } from '@urql/core';\nimport { pipe, subscribe } from 'wonka'; // Average block time is about 13 seconds on the 2020-08-14\n// See https://etherscan.io/chart/blocktime\n\nconst POLL_INTERVAL_DEFAULT = 13 * 1000;\n\nfunction createRequest(query, args) {\n  // Make every operation type a query, until GraphQL subscriptions get added again.\n  if (query.definitions) {\n    query = { ...query,\n      definitions: query.definitions.map(definition => ({ ...definition,\n        operation: 'query'\n      }))\n    };\n  }\n\n  return createRequestUrql(query, args);\n}\n\nexport default class GraphQLWrapper {\n  constructor(subgraphUrl, options = {}) {\n    var _a, _b;\n\n    _client.set(this, void 0);\n\n    _pollInterval.set(this, void 0);\n\n    _verbose.set(this, void 0);\n\n    if (typeof options === 'boolean') {\n      console.warn('GraphQLWrapper: please use `new GraphQLWrapper(url, { verbose })` rather than `new GraphQLWrapper(url, verbose)`.');\n      options = {\n        verbose: options\n      };\n    }\n\n    options = options;\n\n    __classPrivateFieldSet(this, _verbose, (_a = options.verbose) !== null && _a !== void 0 ? _a : false);\n\n    __classPrivateFieldSet(this, _pollInterval, (_b = options.pollInterval) !== null && _b !== void 0 ? _b : POLL_INTERVAL_DEFAULT);\n\n    __classPrivateFieldSet(this, _client, new Client({\n      maskTypename: true,\n      url: subgraphUrl,\n      fetch\n    }));\n  }\n\n  close() {// Do nothing for now.\n    // Will be used when GraphQL subscriptions will be added again.\n  }\n\n  subscribeToQuery(query, args = {}, callback) {\n    const request = createRequest(query, args);\n    return pipe(__classPrivateFieldGet(this, _client).executeQuery(request, {\n      pollInterval: __classPrivateFieldGet(this, _pollInterval),\n      requestPolicy: 'cache-and-network'\n    }), subscribe(result => {\n      if (__classPrivateFieldGet(this, _verbose)) {\n        console.log(this.describeQueryResult(result));\n      }\n\n      if (result.error) {\n        throw new Error(['Error performing subscription.', `${result.error.name}: ${result.error.message}`, this.describeQueryResult(result)].join('\\n'));\n      }\n\n      callback(result);\n    }));\n  }\n\n  subscribeToQueryWithParser(query, args = {}, callback, parser) {\n    return this.subscribeToQuery(query, args, async result => {\n      callback((await this.parseQueryResult(parser, result)));\n    });\n  }\n\n  async performQuery(query, args = {}) {\n    const result = await __classPrivateFieldGet(this, _client).query(query, args).toPromise();\n\n    if (__classPrivateFieldGet(this, _verbose)) {\n      console.log(this.describeQueryResult(result));\n    }\n\n    if (result.error) {\n      throw new Error(this.describeQueryResultError(result) + this.describeQueryResult(result));\n    }\n\n    return result;\n  }\n\n  async performQueryWithParser(query, args = {}, parser) {\n    const result = await this.performQuery(query, args);\n    return this.parseQueryResult(parser, result);\n  }\n\n  async parseQueryResult(parser, result) {\n    try {\n      return parser(result);\n    } catch (error) {\n      throw new Error(error.message + '\\n\\n' + this.describeQueryResult(result));\n    }\n  }\n\n  describeQueryResultError(result) {\n    if (!result.error) {\n      return '';\n    }\n\n    return `${result.error.name}: ${result.error.message}\\n\\n`;\n  }\n\n  describeQueryResult(result) {\n    var _a;\n\n    const queryStr = (_a = result.operation.query.loc) === null || _a === void 0 ? void 0 : _a.source.body;\n    const dataStr = JSON.stringify(result.data, null, 2);\n    const argsStr = JSON.stringify(result.operation.variables, null, 2);\n    const subgraphUrl = result.operation.context.url;\n    return [`Subgraph: ${subgraphUrl}`, `Arguments: ${argsStr}`, `Query: ${queryStr}`, `Returned data: ${dataStr}`].join('\\n\\n');\n  }\n\n}\n_client = new WeakMap(), _pollInterval = new WeakMap(), _verbose = new WeakMap();","map":null,"metadata":{},"sourceType":"module"}