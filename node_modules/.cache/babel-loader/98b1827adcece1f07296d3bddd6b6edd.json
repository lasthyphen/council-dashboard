{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.parse = parse, exports.Parser = void 0;\n/**\n* @module radspec/parser\n*/\n\n/**\n* A token.\n* @typedef {Object} Token\n* @property {string} type The token type\n* @property {*?} value The value of the token\n*/\n\n/**\n* An AST node.\n* @typedef {Object} Node\n* @property {string} type The node type\n*/\n\n/**\n* An AST.\n* @typedef {Object} AST\n* @property {string} type\n* @property {Array<Node>} body The AST nodes\n*/\n\n/**\n* Enum for parser state.\n*\n* @readonly\n* @enum {string}\n*/\n\nvar PARSER_STATE = {\n  OK: \"OK\",\n  ERROR: \"ERROR\"\n};\n/**\n* Parses a token list into an AST.\n*\n* @class Parser\n* @param {Array<Token>} tokens\n* @property {string} state The state of the parser (`OK` or `ERROR`)\n* @property {Array<Token>} tokens\n* @property {number} cursor\n*/\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(tokens) {\n    _classCallCheck(this, Parser);\n\n    this.state = PARSER_STATE.OK, this.tokens = tokens, this.cursor = 0;\n  }\n  /**\n  * Get the current token and increase the cursor by 1\n  *\n  * @return {Token}\n  */\n\n\n  _createClass(Parser, [{\n    key: \"consume\",\n    value: function consume() {\n      return this.cursor++, this.tokens[this.cursor - 1];\n    }\n    /**\n    * Get the previous token.\n    *\n    * @return {Token}\n    */\n\n  }, {\n    key: \"previous\",\n    value: function previous() {\n      return this.tokens[this.cursor - 1];\n    }\n    /**\n    * Get the token under the cursor without consuming it.\n    *\n    * @return {Token}\n    */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.tokens[this.cursor];\n    }\n    /**\n    * Checks if the type of the next token matches any of the expected types.\n    *\n    * Increases the cursor by 1 if the token matches.\n    *\n    * @param {...string} expected The expected types\n    * @return {boolean} True if the next token matches, otherwise false\n    */\n\n  }, {\n    key: \"matches\",\n    value: function matches() {\n      if (this.eof()) return !1;\n\n      for (var _len = arguments.length, expected = new Array(_len), _key = 0; _key < _len; _key++) {\n        expected[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _expected = expected; _i < _expected.length; _i++) {\n        var type = _expected[_i];\n        if (this.peek().type === type) return this.cursor++, !0;\n      }\n\n      return !1;\n    }\n    /**\n    * Try to parse comparison operators.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"comparison\",\n    value: function comparison(astBody) {\n      var node = this.addition(astBody);\n\n      for (; this.matches(\"GREATER\", \"GREATER_EQUAL\", \"LESS\", \"LESS_EQUAL\", \"EQUAL_EQUAL\", \"BANG_EQUAL\");) {\n        var operator = this.previous().type,\n            right = this.addition(astBody);\n        node = {\n          type: \"ComparisonExpression\",\n          operator: operator,\n          left: node,\n          right: right\n        };\n      }\n\n      return this.matches(\"QUESTION_MARK\") && (node = {\n        type: \"TernaryExpression\",\n        predicate: node,\n        left: this.comparison(astBody)\n      }, !this.matches(\"COLON\") && this.report(\"Half-baked ternary (expected colon)\"), node.right = this.comparison(astBody)), this.matches(\"DOUBLE_VERTICAL_BAR\") && (node = {\n        left: node,\n        right: this.comparison(),\n        type: \"DefaultExpression\"\n      }), node;\n    }\n    /**\n    * Try to parse arithmetic operators.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"addition\",\n    value: function addition(astBody) {\n      var node = this.multiplication(astBody);\n\n      for (; this.matches(\"MINUS\", \"PLUS\");) {\n        var operator = this.previous().type,\n            right = this.multiplication(astBody);\n        node = {\n          type: \"BinaryExpression\",\n          operator: operator,\n          left: node,\n          right: right\n        };\n      }\n\n      return node;\n    }\n    /**\n    * Try to parse binary operators.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"multiplication\",\n    value: function multiplication(astBody) {\n      var node = this.power(astBody);\n\n      for (; this.matches(\"SLASH\", \"STAR\", \"MODULO\");) {\n        var operator = this.previous().type,\n            right = this.power(astBody);\n        node = {\n          type: \"BinaryExpression\",\n          operator: operator,\n          left: node,\n          right: right\n        };\n      }\n\n      return node;\n    }\n    /**\n    * Try to parse exponential operators.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"power\",\n    value: function power(astBody) {\n      var node = this.unary(astBody);\n\n      for (; this.matches(\"POWER\");) {\n        var operator = this.previous().type,\n            right = this.unary(astBody);\n        node = {\n          type: \"BinaryExpression\",\n          operator: operator,\n          left: node,\n          right: right\n        };\n      }\n\n      return node;\n    }\n    /**\n    * Try to parse unary operators.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"unary\",\n    value: function unary(astBody) {\n      if (this.matches(\"BANG\", \"MINUS\")) {\n        var operator = this.previous().type,\n            right = this.unary(astBody);\n        return {\n          type: \"UnaryExpression\",\n          operator: operator,\n          right: right\n        };\n      }\n\n      return this.identifier(astBody);\n    }\n    /**\n    * Try to parse identifiers and call expressions.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"identifier\",\n    value: function identifier(astBody) {\n      var node;\n\n      if (this.matches(\"IDENTIFIER\") && (node = {\n        type: \"Identifier\",\n        value: this.previous().value\n      }), !node) {\n        var previousNode = astBody.length && astBody[astBody.length - 1];\n        previousNode && (\"Identifier\" === previousNode.type || \"GroupedExpression\" === previousNode.type || \"CallExpression\" === previousNode.type) && (node = previousNode, astBody.pop());\n      }\n\n      if (node) {\n        for (; this.matches(\"DOT\");) {\n          var property = this.consume().value;\n          node = {\n            type: \"PropertyAccessExpression\",\n            target: node,\n            property: property\n          };\n        }\n\n        return this.matches(\"LEFT_PAREN\") && (node = {\n          type: \"CallExpression\",\n          target: node.target,\n          callee: node.property,\n          inputs: this.functionInputs(astBody),\n          outputs: []\n        }, this.eof() && this.report(\"Unterminated call expression\"), node.outputs = this.typeList()), node;\n      }\n\n      return this.helper(astBody);\n    }\n    /**\n    * Try to parse helper functions\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"helper\",\n    value: function helper(astBody) {\n      if (this.matches(\"AT\")) {\n        var identifier = this.consume(),\n            name = identifier.value;\n        \"IDENTIFIER\" !== identifier.type && this.report(\"Invalid helper function name '\".concat(name, \"' provided after @\"));\n        var node = {\n          type: \"HelperFunction\",\n          name: name\n        };\n        return this.matches(\"LEFT_PAREN\") ? node.inputs = this.functionInputs(astBody) : this.report(\"Expected '(' for executing helper function\"), node;\n      }\n\n      return this.primary(astBody);\n    }\n    /**\n    * Try to parse primaries (literals).\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"primary\",\n    value: function primary() {\n      if (this.matches(\"NUMBER\", \"STRING\", \"HEXADECIMAL\", \"BOOLEAN\")) {\n        var type = {\n          NUMBER: \"NumberLiteral\",\n          STRING: \"StringLiteral\",\n          HEXADECIMAL: \"BytesLiteral\",\n          BOOLEAN: \"BoolLiteral\"\n        }[this.previous().type];\n        return {\n          type: type,\n          value: this.previous().value\n        };\n      }\n\n      if (this.matches(\"LEFT_PAREN\")) {\n        var expression;\n\n        do {\n          // Keep munching expressions in the context of the current expression\n          expression = this.comparison(expression ? [expression] : []);\n        } while (!this.eof() && !this.matches(\"RIGHT_PAREN\"));\n\n        return this.eof() && this.report(\"Unterminated grouping\"), {\n          type: \"GroupedExpression\",\n          body: expression\n        };\n      }\n\n      this.report(\"Unknown token \\\"\".concat(this.consume().type, \"\\\"\"));\n    }\n    /**\n    * Try to parse a type.\n    *\n    * @return {string} The type\n    */\n\n  }, {\n    key: \"type\",\n    value: function type() {\n      return this.matches(\"COLON\") || \"TYPE\" === this.peek().type || this.report(\"Expected a type, got \\\"\".concat(this.peek().type, \"\\\"\")), this.consume().value;\n    }\n    /**\n    * Try to parse a type list.\n    *\n    * @return {Array<string>} The list of types\n    */\n\n  }, {\n    key: \"typeList\",\n    value: function typeList() {\n      // We just have a single type\n      if (this.matches(\"COLON\") || \"TYPE\" === this.peek().type && \"LEFT_PAREN\" === this.peek().type || this.report(\"Expected a type or a list of types, got \\\"\".concat(this.peek().type, \"\\\"\")), !this.matches(\"LEFT_PAREN\")) return [{\n        type: this.consume().value,\n        selected: !0\n      }];\n      var typeList = [];\n\n      for (; !this.eof() && !this.matches(\"RIGHT_PAREN\");) {\n        // Check if the type is preceded by a < to denote\n        // that this is the type of the return value we want.\n        var selected = this.matches(\"LESS\");\n        \"TYPE\" === !this.peek().type && this.report(\"Unexpected identifier in type list, expected type, got \\\"\".concat(this.peek().type, \"\\\"\")), typeList.push({\n          type: this.consume().value,\n          selected: selected\n        }), selected && !this.matches(\"GREATER\") && this.report(\"Unclosed selected type\"), this.matches(\"COMMA\") || \"RIGHT_PAREN\" === this.peek().type || this.report(\"Undelimited parameter type (expected comma delimiter or closing brace)\");\n      }\n\n      this.eof() && this.report(\"Unclosed type list\"); // Verify that at least one type in the type list has been selected\n      // as the type of the return value.\n      //\n      // If no type has been selected, and the number of types in the type\n      // list is exactly 1, then we assume that that type should be\n      // marked as selected.\n\n      var hasSelectedTypeInList = !!typeList.find(function (item) {\n        return item.selected;\n      });\n      return hasSelectedTypeInList || 1 !== typeList.length ? !hasSelectedTypeInList && this.report(\"Type list has no selected type\") : typeList[0].selected = !0, typeList;\n    }\n    /**\n    * Try to parse function arguments.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Array<Node>}\n    */\n\n  }, {\n    key: \"functionInputs\",\n    value: function functionInputs(astBody) {\n      var inputs = [];\n\n      for (; !this.eof() && !this.matches(\"RIGHT_PAREN\");) {\n        var input = this.comparison(astBody);\n        input.type ? this.matches(\"COLON\") && this.report(\"Unexpected type (already inferred type of parameter)\") : input.type = this.type(), inputs.push(input), this.matches(\"COMMA\") || \"RIGHT_PAREN\" === this.peek().type || this.report(\"Undelimited parameter type (expected comma delimiter or closing brace)\");\n      }\n\n      return inputs;\n    }\n    /**\n    * Walk all possible paths and try to parse a single node\n    * from the list of tokens.\n    *\n    * @param  {Array<Node>} astBody Subtree of AST being walked\n    * @return {Node}\n    */\n\n  }, {\n    key: \"walk\",\n    value: function walk(astBody) {\n      var token = this.peek();\n      if (\"MONOLOGUE\" === token.type) return {\n        type: \"MonologueStatement\",\n        value: this.consume().value\n      };\n\n      if (\"TICK\" === token.type) {\n        var node = {\n          type: \"ExpressionStatement\",\n          body: []\n        };\n\n        for (this.matches(\"TICK\"); !this.eof() && \"TICK\" !== this.peek().type;) {\n          node.body.push(this.walk(node.body));\n        }\n\n        return this.eof() && this.report(\"Unterminated expression\"), this.matches(\"TICK\"), node;\n      }\n\n      return this.comparison(astBody);\n    }\n    /**\n    * Walks the token list and returns an AST.\n    *\n    * @return {AST} The AST\n    */\n\n  }, {\n    key: \"parse\",\n    value: function () {\n      var _parse = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var ast;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                ast = {\n                  type: \"Program\",\n                  body: []\n                };\n\n                for (; !this.eof();) {\n                  ast.body.push(this.walk(ast.body));\n                }\n\n                return _context.abrupt(\"return\", this.state === PARSER_STATE.ERROR ? (console.error(\"Errors encountered while parsing source\"), ast) : ast);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function parse() {\n        return _parse.apply(this, arguments);\n      }\n\n      return parse;\n    }()\n    /**\n    * Returns true if we've reached the end of the token list, otherwise false.\n    *\n    * @return {boolean}\n    */\n\n  }, {\n    key: \"eof\",\n    value: function eof() {\n      return this.cursor >= this.tokens.length;\n    }\n    /**\n    * Prints an error with location information to `stderr`\n    * and sets the parser state to `PARSER_STATE.ERROR`\n    *\n    * @param {string} error\n    * @return {void}\n    */\n\n  }, {\n    key: \"report\",\n    value: function report(error) {\n      this.state = PARSER_STATE.ERROR, console.error(\"Error (\".concat(this.cursor, \"): \").concat(error));\n    }\n  }]);\n\n  return Parser;\n}();\n/**\n* Walks token list and returns an AST.\n*\n* @memberof radspec/parser\n* @param  {Array<Token>} tokens\n* @return {AST} The AST\n*/\n\n\nexports.Parser = Parser;\n\nfunction parse(tokens) {\n  return new Parser(tokens).parse();\n}","map":null,"metadata":{},"sourceType":"script"}