{"ast":null,"code":"const EventEmitter = require('events');\n\nconst dev = process.env.NODE_ENV === 'development';\n\nclass ConnectionManager extends EventEmitter {\n  constructor(connections, targets, options) {\n    super();\n    this.targets = targets;\n    this.connections = connections;\n    this.connected = false;\n    this.status = 'loading';\n    this.interval = options.interval || 5000;\n    this.name = options.name || 'default';\n    this.inSetup = true;\n    this.connect();\n  }\n\n  connect(index = 0) {\n    if (dev && index === 0) console.log(`\\n\\n\\n\\nA connection cycle started for provider with name: ${this.name}`);\n\n    if (this.connection && this.connection.status === 'connected' && index >= this.connection.index) {\n      if (dev) console.log('Stopping connection cycle becasuse we\\'re already connected to a higher priority provider');\n    } else if (this.targets.length === 0) {\n      if (dev) console.log('No valid targets supplied');\n    } else {\n      const {\n        protocol,\n        location\n      } = this.targets[index];\n      this.connection = this.connections[protocol](location);\n      this.connection.on('error', err => {\n        if (!this.connected) return this.connectionError(index, err);\n        if (this.listenerCount('error')) return this.emit('error', err);\n        console.warn('eth-provider - Uncaught connection error: ' + err.message);\n      });\n      this.connection.on('close', summary => {\n        this.connected = false;\n        this.emit('close');\n        if (!this.closing) this.refresh();\n      });\n      this.connection.on('connect', () => {\n        this.connection.target = this.targets[index];\n        this.connection.index = index;\n        this.targets[index].status = this.connection.status;\n        this.connected = true;\n        this.inSetup = false;\n        if (dev) console.log('Successfully connected to: ' + this.targets[index].location);\n        this.emit('connect');\n      });\n      this.connection.on('data', data => this.emit('data', data));\n      this.connection.on('payload', payload => this.emit('payload', payload));\n    }\n  }\n\n  refresh(interval = this.interval) {\n    if (dev) console.log(`Reconnect queued for ${(interval / 1000).toFixed(2)}s in the future`);\n    clearTimeout(this.connectTimer);\n    this.connectTimer = setTimeout(() => this.connect(), interval);\n  }\n\n  connectionError(index, err) {\n    this.targets[index].status = err;\n\n    if (this.targets.length - 1 === index) {\n      this.inSetup = false;\n      if (dev) console.warn('eth-provider unable to connect to any targets, view connection cycle summary: ', this.targets);\n      this.refresh();\n    } else {\n      // Not last target, move on the next connection option\n      this.connect(++index);\n    }\n  }\n\n  close() {\n    this.closing = true;\n\n    if (this.connection) {\n      this.connection.close(); // Let event bubble from here\n    } else {\n      this.emit('close');\n    }\n\n    clearTimeout(this.connectTimer);\n  }\n\n  error(payload, message, code = -1) {\n    this.emit('payload', {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        message,\n        code\n      }\n    });\n  }\n\n  send(payload) {\n    if (this.inSetup) {\n      setTimeout(() => this.send(payload), 100);\n    } else if (this.connection.closed) {\n      this.error(payload, 'Not connected');\n    } else {\n      this.connection.send(payload);\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;","map":null,"metadata":{},"sourceType":"script"}