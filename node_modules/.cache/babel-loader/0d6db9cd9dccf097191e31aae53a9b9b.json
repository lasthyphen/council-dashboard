{"ast":null,"code":"import _objectSpread from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{bigNum}from'../lib/math-utils';import{addressesEqual}from'../lib/web3-utils';import{toMs}from'./date-utils';export function transformAppealDataAttributes(appeal){var appealedRuling=appeal.appealedRuling,opposedRuling=appeal.opposedRuling,appealDeposit=appeal.appealDeposit,confirmAppealDeposit=appeal.confirmAppealDeposit,round=appeal.round,settledAt=appeal.settledAt;return _objectSpread({},appeal,{round:_objectSpread({},round,{number:parseInt(round.number,10),dispute:_objectSpread({},round.dispute,{lastRoundId:parseInt(round.dispute.lastRoundId,10),rounds:round.dispute.rounds.map(function(round){return _objectSpread({},round,{number:parseInt(round.number,10)});})})}),appealedRuling:parseInt(appealedRuling,10),opposedRuling:parseInt(opposedRuling,10),appealDeposit:bigNum(appealDeposit),confirmAppealDeposit:bigNum(confirmAppealDeposit),settledAt:toMs(parseInt(settledAt||0,10))});}export function shouldAppealerBeRewarded(appeal,connectedAccount){var maker=appeal.maker,taker=appeal.taker,appealedRuling=appeal.appealedRuling,opposedRuling=appeal.opposedRuling,round=appeal.round;var isMaker=addressesEqual(connectedAccount,maker);// If appealer is maker and the appeal wasn't confirmed\nif(isMaker&&!opposedRuling){return true;}var finalRuling=round.dispute.finalRuling;// If maker && appealed for the wininig outcome\nif(isMaker&&appealedRuling===finalRuling){return true;}var isTaker=addressesEqual(connectedAccount,taker);// If taker && confirmed appealed for the winning outcome\nif(isTaker&&opposedRuling===finalRuling){return true;}// Check if  none of the appealers ruled for the winning outcome\nreturn appealedRuling!==finalRuling&&opposedRuling!==finalRuling;}// Assumes the appealer should be rewarded\nexport function getAppealerFees(appeal,totalFees,connectedAccount){var maker=appeal.maker,appealDeposit=appeal.appealDeposit,appealedRuling=appeal.appealedRuling,taker=appeal.taker,confirmAppealDeposit=appeal.confirmAppealDeposit,opposedRuling=appeal.opposedRuling,round=appeal.round;var isMaker=addressesEqual(connectedAccount,maker);var isTaker=addressesEqual(connectedAccount,taker);// If appealer is maker and the appeal wasn't confirmed\nif(isMaker&&!opposedRuling){return appealDeposit;}var finalRuling=round.dispute.finalRuling;var totalDeposit=appealDeposit.add(confirmAppealDeposit);// if appealed for the wininig outcome\nif(isMaker&&appealedRuling===finalRuling||isTaker&&opposedRuling===finalRuling){return totalDeposit.sub(totalFees);}// Note that since we assume that the appealer should be rewarded, we can ensure\n// that the finalRuling is different from the appealedRuling and the opossedRuling\nvar feesRefund=totalFees.div(2);return(isMaker?appealDeposit:confirmAppealDeposit).sub(feesRefund);}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/utils/appeal-utils.js"],"names":["bigNum","addressesEqual","toMs","transformAppealDataAttributes","appeal","appealedRuling","opposedRuling","appealDeposit","confirmAppealDeposit","round","settledAt","number","parseInt","dispute","lastRoundId","rounds","map","shouldAppealerBeRewarded","connectedAccount","maker","taker","isMaker","finalRuling","isTaker","getAppealerFees","totalFees","totalDeposit","add","sub","feesRefund","div"],"mappings":"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","sourcesContent":["import { bigNum } from '../lib/math-utils'\nimport { addressesEqual } from '../lib/web3-utils'\nimport { toMs } from './date-utils'\n\nexport function transformAppealDataAttributes(appeal) {\n  const {\n    appealedRuling,\n    opposedRuling,\n    appealDeposit,\n    confirmAppealDeposit,\n    round,\n    settledAt,\n  } = appeal\n\n  return {\n    ...appeal,\n    round: {\n      ...round,\n      number: parseInt(round.number, 10),\n      dispute: {\n        ...round.dispute,\n        lastRoundId: parseInt(round.dispute.lastRoundId, 10),\n        rounds: round.dispute.rounds.map(round => ({\n          ...round,\n          number: parseInt(round.number, 10),\n        })),\n      },\n    },\n    appealedRuling: parseInt(appealedRuling, 10),\n    opposedRuling: parseInt(opposedRuling, 10),\n    appealDeposit: bigNum(appealDeposit),\n    confirmAppealDeposit: bigNum(confirmAppealDeposit),\n    settledAt: toMs(parseInt(settledAt || 0, 10)),\n  }\n}\n\nexport function shouldAppealerBeRewarded(appeal, connectedAccount) {\n  const { maker, taker, appealedRuling, opposedRuling, round } = appeal\n\n  const isMaker = addressesEqual(connectedAccount, maker)\n\n  // If appealer is maker and the appeal wasn't confirmed\n  if (isMaker && !opposedRuling) {\n    return true\n  }\n\n  const { finalRuling } = round.dispute\n  // If maker && appealed for the wininig outcome\n  if (isMaker && appealedRuling === finalRuling) {\n    return true\n  }\n\n  const isTaker = addressesEqual(connectedAccount, taker)\n\n  // If taker && confirmed appealed for the winning outcome\n  if (isTaker && opposedRuling === finalRuling) {\n    return true\n  }\n\n  // Check if  none of the appealers ruled for the winning outcome\n  return appealedRuling !== finalRuling && opposedRuling !== finalRuling\n}\n\n// Assumes the appealer should be rewarded\nexport function getAppealerFees(appeal, totalFees, connectedAccount) {\n  const {\n    maker,\n    appealDeposit,\n    appealedRuling,\n    taker,\n    confirmAppealDeposit,\n    opposedRuling,\n    round,\n  } = appeal\n\n  const isMaker = addressesEqual(connectedAccount, maker)\n  const isTaker = addressesEqual(connectedAccount, taker)\n\n  // If appealer is maker and the appeal wasn't confirmed\n  if (isMaker && !opposedRuling) {\n    return appealDeposit\n  }\n\n  const { finalRuling } = round.dispute\n  const totalDeposit = appealDeposit.add(confirmAppealDeposit)\n\n  // if appealed for the wininig outcome\n  if (\n    (isMaker && appealedRuling === finalRuling) ||\n    (isTaker && opposedRuling === finalRuling)\n  ) {\n    return totalDeposit.sub(totalFees)\n  }\n\n  // Note that since we assume that the appealer should be rewarded, we can ensure\n  // that the finalRuling is different from the appealedRuling and the opossedRuling\n  const feesRefund = totalFees.div(2)\n  return (isMaker ? appealDeposit : confirmAppealDeposit).sub(feesRefund)\n}\n"]},"metadata":{},"sourceType":"module"}