{"ast":null,"code":"import { useMemo } from 'react';\nimport { useWallet } from '../providers/Wallet';\nimport { useCourtClock } from '../providers/CourtClock';\nimport { useCourtConfig } from '../providers/CourtConfig';\nimport { useFirstANJActivationQuery } from './query-hooks';\nimport { useDashboardState } from '../components/Dashboard/DashboardStateProvider';\nimport { isMovementOf, convertMovement, isMovementEffective, getUpdatedLockedMovement, getLatestMovementByBalance, acceptedMovementsPerBalance, getAmountNotEffectiveByBalance } from '../utils/anj-movement-utils';\nimport { getTermStartTime } from '../utils/court-utils';\nimport { getDraftLockAmount } from '../utils/dispute-utils';\nimport { ANJBalance, ANJMovement } from '../types/anj-types';\nexport function useANJBalances() {\n  const {\n    anjBalances,\n    anjMovements\n  } = useDashboardState();\n  const {\n    walletBalance,\n    activeBalance,\n    lockedBalance,\n    inactiveBalance,\n    deactivationBalance\n  } = anjBalances || {};\n  const convertedMovements = useConvertedMovements(anjMovements);\n  const convertedWalletBalance = useBalanceWithMovements(walletBalance, convertedMovements, ANJBalance.Wallet);\n  const convertedInactiveBalance = useBalanceWithMovements(inactiveBalance, convertedMovements, ANJBalance.Inactive);\n  const convertedActiveBalance = useBalanceWithMovements(activeBalance, convertedMovements, ANJBalance.Active); // Use ANJ Locked distribution\n\n  const lockedDistribution = useJurorLockedANJDistribution();\n  const convertedLockedBalance = useMemo(() => {\n    return {\n      amount: lockedBalance,\n      distribution: lockedDistribution\n    };\n  }, [lockedBalance, lockedDistribution]);\n  const convertedDeactivationBalance = useMemo(() => {\n    return {\n      amount: deactivationBalance\n    };\n  }, [deactivationBalance]); // Since we pass the whole object through props to components, we should memoize it\n\n  return useMemo(() => {\n    if (!anjBalances) {\n      return null;\n    }\n\n    return {\n      walletBalance: convertedWalletBalance,\n      inactiveBalance: convertedInactiveBalance,\n      activeBalance: convertedActiveBalance,\n      lockedBalance: convertedLockedBalance,\n      deactivationBalance: convertedDeactivationBalance\n    };\n  }, [anjBalances, convertedActiveBalance, convertedDeactivationBalance, convertedInactiveBalance, convertedLockedBalance, convertedWalletBalance]);\n} // Asummes movements in descending order of creation\n\nfunction useConvertedMovements(movements) {\n  const {\n    currentTermId\n  } = useCourtClock();\n  const courtConfig = useCourtConfig();\n  const effectiveStates = movements ? movements.map(mov => isMovementEffective(mov, currentTermId)) : [];\n  const effectiveStatesKey = effectiveStates.join('');\n  return useMemo(() => {\n    if (!movements) {\n      return null;\n    } // Since Activation, Deactivations and Slashing movements are effective on next term of creation\n    // but only Deactivations don't update the balance immediately, we'll use another attr (isImmediate) to differentiate these cases\n\n\n    return movements.map((mov, i) => {\n      const isImmediate = ANJMovement[mov.type] !== ANJMovement.Deactivation;\n      let updatesBalanceAt = mov.createdAt;\n\n      if (!isImmediate && mov.effectiveTermId && effectiveStates[i]) {\n        const termStartTimeMs = getTermStartTime(mov.effectiveTermId, courtConfig);\n        updatesBalanceAt = termStartTimeMs / 1000;\n      }\n\n      return { ...mov,\n        isEffective: effectiveStates[i],\n        updatesBalanceAt,\n        isImmediate\n      };\n    }).sort((mov1, mov2) => {\n      // We are resorting movements by time they update the balance at\n      if (mov1.updatesBalanceAt === mov2.updatesBalanceAt) {\n        return mov2.createdAt - mov1.createdAt;\n      }\n\n      return mov2.updatesBalanceAt - mov1.updatesBalanceAt;\n    });\n  }, [effectiveStatesKey, movements] //eslint-disable-line\n  );\n}\n/**\n * Calculates total amount, total not effective amount and the latest movement for `balanceType`\n * @dev In case the balance is active or inactive, we must also calculate all non effective movements to get the effective balance at current term\n *\n * @param {BigNum} balance Total balance amount\n * @param {Array} movements Latest 24h movements\n * @param {Symbol} balanceType Type of balance (Wallet, Inactive, Active)\n * @returns {Object} Converted balance\n */\n\n\nfunction useBalanceWithMovements(balance, movements, balanceType) {\n  const {\n    anjBalances\n  } = useDashboardState();\n  const {\n    lockedBalance\n  } = anjBalances || {};\n  const acceptedMovements = acceptedMovementsPerBalance.get(balanceType);\n  const filteredMovements = useFilteredMovements(movements, acceptedMovements);\n  return useMemo(() => {\n    if (!balance) {\n      return null;\n    } // Calculate total not effective (If balanceType === wallet returns 0)\n\n\n    const amountNotEffective = getAmountNotEffectiveByBalance(movements, balanceType); // Get latest movement\n\n    let latestMovement = getLatestMovementByBalance(filteredMovements, balanceType); // Update latest movement if necessary\n\n    if (balanceType === ANJBalance.Active) {\n      if (lockedBalance === null || lockedBalance === void 0 ? void 0 : lockedBalance.gt(0)) latestMovement = getUpdatedLockedMovement(lockedBalance, latestMovement);\n    }\n\n    return {\n      amount: balance,\n      amountNotEffective,\n      latestMovement: convertMovement(acceptedMovements, latestMovement)\n    };\n  }, [acceptedMovements, balance, balanceType, filteredMovements, lockedBalance, movements]);\n}\n\nfunction useFilteredMovements(movements, acceptedMovements) {\n  return useMemo(() => {\n    if (!movements) {\n      return null;\n    }\n\n    return movements.filter(movement => {\n      return isMovementOf(acceptedMovements, ANJMovement[movement.type]);\n    });\n  }, [acceptedMovements, movements]);\n}\n/**\n * @param {Object} options query options\n * @param {Boolean} options.pause Tells whether to pause query or not\n * @return {Boolean} true if account's first ANJ activation happened on current term\n */\n\n\nexport function useJurorFirstTimeANJActivation(options) {\n  const wallet = useWallet();\n  const {\n    currentTermId\n  } = useCourtClock();\n  const firstANJActivation = useFirstANJActivationQuery(wallet.account, options);\n  if (!firstANJActivation) return false;\n  const firstANJActivationTerm = parseInt(firstANJActivation.effectiveTermId, 10); // Activation is effective on next term from when the activation was performed\n\n  return firstANJActivationTerm === currentTermId + 1;\n}\nexport function useJurorLockedANJDistribution() {\n  const {\n    maxRegularAppealRounds,\n    minActiveBalance,\n    penaltyPct\n  } = useCourtConfig();\n  const {\n    jurorDrafts,\n    anjBalances\n  } = useDashboardState();\n  const {\n    lockedBalance\n  } = anjBalances || {};\n  return useMemo(() => {\n    if (!lockedBalance || lockedBalance.eq(0) || !jurorDrafts) return null; // For final rounds the ANJ at stake is pre-slashed for all jurors when they commit their vote\n\n    return jurorDrafts.filter(jurorDraft => !jurorDraft.round.settledPenalties && jurorDraft.round.number < maxRegularAppealRounds).reduce((lockDistribution, {\n      weight,\n      round\n    }) => {\n      const {\n        dispute\n      } = round; // Since the subgraph cannot provide a way to tell how much was locked per draft we calculate it ourselves\n      // See https://github.com/aragon/court-subgraph/blob/7f0fec5c8953e9dbd67e5607fb6da03f69a60f40/src/DisputeManager.ts#L57\n\n      const lockedAmount = getDraftLockAmount(minActiveBalance, penaltyPct, weight);\n      const index = lockDistribution.findIndex(locks => locks.disputeId === dispute.id);\n\n      if (index >= 0) {\n        const elem = lockDistribution[index]; // Replace with updated amount and weight\n\n        lockDistribution.splice(index, 1, { ...elem,\n          amount: elem.amount.add(lockedAmount),\n          weight: elem.weight.add(weight)\n        });\n      } else {\n        lockDistribution.push({\n          disputeId: dispute.id,\n          amount: lockedAmount,\n          weight\n        });\n      }\n\n      return lockDistribution;\n    }, []);\n  }, [jurorDrafts, lockedBalance, maxRegularAppealRounds, minActiveBalance, penaltyPct]);\n}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useANJ.js"],"names":["useMemo","useWallet","useCourtClock","useCourtConfig","useFirstANJActivationQuery","useDashboardState","isMovementOf","convertMovement","isMovementEffective","getUpdatedLockedMovement","getLatestMovementByBalance","acceptedMovementsPerBalance","getAmountNotEffectiveByBalance","getTermStartTime","getDraftLockAmount","ANJBalance","ANJMovement","useANJBalances","anjBalances","anjMovements","walletBalance","activeBalance","lockedBalance","inactiveBalance","deactivationBalance","convertedMovements","useConvertedMovements","convertedWalletBalance","useBalanceWithMovements","Wallet","convertedInactiveBalance","Inactive","convertedActiveBalance","Active","lockedDistribution","useJurorLockedANJDistribution","convertedLockedBalance","amount","distribution","convertedDeactivationBalance","movements","currentTermId","courtConfig","effectiveStates","map","mov","effectiveStatesKey","join","i","isImmediate","type","Deactivation","updatesBalanceAt","createdAt","effectiveTermId","termStartTimeMs","isEffective","sort","mov1","mov2","balance","balanceType","acceptedMovements","get","filteredMovements","useFilteredMovements","amountNotEffective","latestMovement","gt","filter","movement","useJurorFirstTimeANJActivation","options","wallet","firstANJActivation","account","firstANJActivationTerm","parseInt","maxRegularAppealRounds","minActiveBalance","penaltyPct","jurorDrafts","eq","jurorDraft","round","settledPenalties","number","reduce","lockDistribution","weight","dispute","lockedAmount","index","findIndex","locks","disputeId","id","elem","splice","add","push"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\n\nimport { useWallet } from '../providers/Wallet'\nimport { useCourtClock } from '../providers/CourtClock'\nimport { useCourtConfig } from '../providers/CourtConfig'\nimport { useFirstANJActivationQuery } from './query-hooks'\nimport { useDashboardState } from '../components/Dashboard/DashboardStateProvider'\n\nimport {\n  isMovementOf,\n  convertMovement,\n  isMovementEffective,\n  getUpdatedLockedMovement,\n  getLatestMovementByBalance,\n  acceptedMovementsPerBalance,\n  getAmountNotEffectiveByBalance,\n} from '../utils/anj-movement-utils'\nimport { getTermStartTime } from '../utils/court-utils'\nimport { getDraftLockAmount } from '../utils/dispute-utils'\nimport { ANJBalance, ANJMovement } from '../types/anj-types'\n\nexport function useANJBalances() {\n  const { anjBalances, anjMovements } = useDashboardState()\n\n  const {\n    walletBalance,\n    activeBalance,\n    lockedBalance,\n    inactiveBalance,\n    deactivationBalance,\n  } = anjBalances || {}\n\n  const convertedMovements = useConvertedMovements(anjMovements)\n\n  const convertedWalletBalance = useBalanceWithMovements(\n    walletBalance,\n    convertedMovements,\n    ANJBalance.Wallet\n  )\n\n  const convertedInactiveBalance = useBalanceWithMovements(\n    inactiveBalance,\n    convertedMovements,\n    ANJBalance.Inactive\n  )\n\n  const convertedActiveBalance = useBalanceWithMovements(\n    activeBalance,\n    convertedMovements,\n    ANJBalance.Active\n  )\n\n  // Use ANJ Locked distribution\n  const lockedDistribution = useJurorLockedANJDistribution()\n  const convertedLockedBalance = useMemo(() => {\n    return { amount: lockedBalance, distribution: lockedDistribution }\n  }, [lockedBalance, lockedDistribution])\n\n  const convertedDeactivationBalance = useMemo(() => {\n    return { amount: deactivationBalance }\n  }, [deactivationBalance])\n\n  // Since we pass the whole object through props to components, we should memoize it\n  return useMemo(() => {\n    if (!anjBalances) {\n      return null\n    }\n\n    return {\n      walletBalance: convertedWalletBalance,\n      inactiveBalance: convertedInactiveBalance,\n      activeBalance: convertedActiveBalance,\n      lockedBalance: convertedLockedBalance,\n      deactivationBalance: convertedDeactivationBalance,\n    }\n  }, [\n    anjBalances,\n    convertedActiveBalance,\n    convertedDeactivationBalance,\n    convertedInactiveBalance,\n    convertedLockedBalance,\n    convertedWalletBalance,\n  ])\n}\n\n// Asummes movements in descending order of creation\nfunction useConvertedMovements(movements) {\n  const { currentTermId } = useCourtClock()\n  const courtConfig = useCourtConfig()\n\n  const effectiveStates = movements\n    ? movements.map(mov => isMovementEffective(mov, currentTermId))\n    : []\n  const effectiveStatesKey = effectiveStates.join('')\n\n  return useMemo(\n    () => {\n      if (!movements) {\n        return null\n      }\n\n      // Since Activation, Deactivations and Slashing movements are effective on next term of creation\n      // but only Deactivations don't update the balance immediately, we'll use another attr (isImmediate) to differentiate these cases\n      return movements\n        .map((mov, i) => {\n          const isImmediate = ANJMovement[mov.type] !== ANJMovement.Deactivation\n\n          let updatesBalanceAt = mov.createdAt\n          if (!isImmediate && mov.effectiveTermId && effectiveStates[i]) {\n            const termStartTimeMs = getTermStartTime(\n              mov.effectiveTermId,\n              courtConfig\n            )\n            updatesBalanceAt = termStartTimeMs / 1000\n          }\n\n          return {\n            ...mov,\n            isEffective: effectiveStates[i],\n            updatesBalanceAt,\n            isImmediate,\n          }\n        })\n        .sort((mov1, mov2) => {\n          // We are resorting movements by time they update the balance at\n          if (mov1.updatesBalanceAt === mov2.updatesBalanceAt) {\n            return mov2.createdAt - mov1.createdAt\n          }\n\n          return mov2.updatesBalanceAt - mov1.updatesBalanceAt\n        })\n    },\n    [effectiveStatesKey, movements] //eslint-disable-line\n  )\n}\n\n/**\n * Calculates total amount, total not effective amount and the latest movement for `balanceType`\n * @dev In case the balance is active or inactive, we must also calculate all non effective movements to get the effective balance at current term\n *\n * @param {BigNum} balance Total balance amount\n * @param {Array} movements Latest 24h movements\n * @param {Symbol} balanceType Type of balance (Wallet, Inactive, Active)\n * @returns {Object} Converted balance\n */\nfunction useBalanceWithMovements(balance, movements, balanceType) {\n  const { anjBalances } = useDashboardState()\n  const { lockedBalance } = anjBalances || {}\n\n  const acceptedMovements = acceptedMovementsPerBalance.get(balanceType)\n  const filteredMovements = useFilteredMovements(movements, acceptedMovements)\n\n  return useMemo(() => {\n    if (!balance) {\n      return null\n    }\n\n    // Calculate total not effective (If balanceType === wallet returns 0)\n    const amountNotEffective = getAmountNotEffectiveByBalance(\n      movements,\n      balanceType\n    )\n\n    // Get latest movement\n    let latestMovement = getLatestMovementByBalance(\n      filteredMovements,\n      balanceType\n    )\n\n    // Update latest movement if necessary\n    if (balanceType === ANJBalance.Active) {\n      if (lockedBalance?.gt(0))\n        latestMovement = getUpdatedLockedMovement(lockedBalance, latestMovement)\n    }\n\n    return {\n      amount: balance,\n      amountNotEffective,\n      latestMovement: convertMovement(acceptedMovements, latestMovement),\n    }\n  }, [\n    acceptedMovements,\n    balance,\n    balanceType,\n    filteredMovements,\n    lockedBalance,\n    movements,\n  ])\n}\n\nfunction useFilteredMovements(movements, acceptedMovements) {\n  return useMemo(() => {\n    if (!movements) {\n      return null\n    }\n    return movements.filter(movement => {\n      return isMovementOf(acceptedMovements, ANJMovement[movement.type])\n    })\n  }, [acceptedMovements, movements])\n}\n\n/**\n * @param {Object} options query options\n * @param {Boolean} options.pause Tells whether to pause query or not\n * @return {Boolean} true if account's first ANJ activation happened on current term\n */\nexport function useJurorFirstTimeANJActivation(options) {\n  const wallet = useWallet()\n  const { currentTermId } = useCourtClock()\n  const firstANJActivation = useFirstANJActivationQuery(wallet.account, options)\n\n  if (!firstANJActivation) return false\n\n  const firstANJActivationTerm = parseInt(\n    firstANJActivation.effectiveTermId,\n    10\n  )\n\n  // Activation is effective on next term from when the activation was performed\n  return firstANJActivationTerm === currentTermId + 1\n}\n\nexport function useJurorLockedANJDistribution() {\n  const {\n    maxRegularAppealRounds,\n    minActiveBalance,\n    penaltyPct,\n  } = useCourtConfig()\n  const { jurorDrafts, anjBalances } = useDashboardState()\n  const { lockedBalance } = anjBalances || {}\n\n  return useMemo(() => {\n    if (!lockedBalance || lockedBalance.eq(0) || !jurorDrafts) return null\n\n    // For final rounds the ANJ at stake is pre-slashed for all jurors when they commit their vote\n    return jurorDrafts\n      .filter(\n        jurorDraft =>\n          !jurorDraft.round.settledPenalties &&\n          jurorDraft.round.number < maxRegularAppealRounds\n      )\n      .reduce((lockDistribution, { weight, round }) => {\n        const { dispute } = round\n\n        // Since the subgraph cannot provide a way to tell how much was locked per draft we calculate it ourselves\n        // See https://github.com/aragon/court-subgraph/blob/7f0fec5c8953e9dbd67e5607fb6da03f69a60f40/src/DisputeManager.ts#L57\n        const lockedAmount = getDraftLockAmount(\n          minActiveBalance,\n          penaltyPct,\n          weight\n        )\n\n        const index = lockDistribution.findIndex(\n          locks => locks.disputeId === dispute.id\n        )\n\n        if (index >= 0) {\n          const elem = lockDistribution[index]\n\n          // Replace with updated amount and weight\n          lockDistribution.splice(index, 1, {\n            ...elem,\n            amount: elem.amount.add(lockedAmount),\n            weight: elem.weight.add(weight),\n          })\n        } else {\n          lockDistribution.push({\n            disputeId: dispute.id,\n            amount: lockedAmount,\n            weight,\n          })\n        }\n\n        return lockDistribution\n      }, [])\n  }, [\n    jurorDrafts,\n    lockedBalance,\n    maxRegularAppealRounds,\n    minActiveBalance,\n    penaltyPct,\n  ])\n}\n"]},"metadata":{},"sourceType":"module"}