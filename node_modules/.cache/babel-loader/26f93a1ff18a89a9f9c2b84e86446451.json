{"ast":null,"code":"const SafeEventEmitter = require('@metamask/safe-event-emitter').default;\n\nconst createScaffoldMiddleware = require('eth-json-rpc-middleware/scaffold');\n\nconst {\n  createAsyncMiddleware\n} = require('json-rpc-engine');\n\nconst createFilterMiddleware = require('./index.js');\n\nconst {\n  unsafeRandomBytes,\n  incrementHexInt\n} = require('./hexUtils.js');\n\nconst getBlocksForRange = require('./getBlocksForRange.js');\n\nmodule.exports = createSubscriptionMiddleware;\n\nfunction createSubscriptionMiddleware({\n  blockTracker,\n  provider\n}) {\n  // state and utilities for handling subscriptions\n  const subscriptions = {};\n  const filterManager = createFilterMiddleware({\n    blockTracker,\n    provider\n  }); // internal flag\n\n  let isDestroyed = false; // create subscriptionManager api object\n\n  const events = new SafeEventEmitter();\n  const middleware = createScaffoldMiddleware({\n    eth_subscribe: createAsyncMiddleware(subscribe),\n    eth_unsubscribe: createAsyncMiddleware(unsubscribe)\n  });\n  middleware.destroy = destroy;\n  return {\n    events,\n    middleware\n  };\n\n  async function subscribe(req, res) {\n    if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n    const subscriptionType = req.params[0]; // subId is 16 byte hex string\n\n    const subId = unsafeRandomBytes(16); // create sub\n\n    let sub;\n\n    switch (subscriptionType) {\n      case 'newHeads':\n        sub = createSubNewHeads({\n          subId\n        });\n        break;\n\n      case 'logs':\n        const filterParams = req.params[1];\n        const filter = await filterManager.newLogFilter(filterParams);\n        sub = createSubFromFilter({\n          subId,\n          filter\n        });\n        break;\n\n      default:\n        throw new Error(`SubscriptionManager - unsupported subscription type \"${subscriptionType}\"`);\n    }\n\n    subscriptions[subId] = sub;\n    res.result = subId;\n    return;\n\n    function createSubNewHeads({\n      subId\n    }) {\n      const sub = {\n        type: subscriptionType,\n        destroy: async () => {\n          blockTracker.removeListener('sync', sub.update);\n        },\n        update: async ({\n          oldBlock,\n          newBlock\n        }) => {\n          // for newHeads\n          const toBlock = newBlock;\n          const fromBlock = incrementHexInt(oldBlock);\n          const rawBlocks = await getBlocksForRange({\n            provider,\n            fromBlock,\n            toBlock\n          });\n          const results = rawBlocks.map(normalizeBlock);\n          results.forEach(value => {\n            _emitSubscriptionResult(subId, value);\n          });\n        }\n      }; // check for subscription updates on new block\n\n      blockTracker.on('sync', sub.update);\n      return sub;\n    }\n\n    function createSubFromFilter({\n      subId,\n      filter\n    }) {\n      filter.on('update', result => _emitSubscriptionResult(subId, result));\n      const sub = {\n        type: subscriptionType,\n        destroy: async () => {\n          return await filterManager.uninstallFilter(filter.idHex);\n        }\n      };\n      return sub;\n    }\n  }\n\n  async function unsubscribe(req, res) {\n    if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n    const id = req.params[0];\n    const subscription = subscriptions[id]; // if missing, return \"false\" to indicate it was not removed\n\n    if (!subscription) {\n      res.result = false;\n      return;\n    } // cleanup subscription\n\n\n    delete subscriptions[id];\n    await subscription.destroy();\n    res.result = true;\n  }\n\n  function _emitSubscriptionResult(filterIdHex, value) {\n    events.emit('notification', {\n      jsonrpc: '2.0',\n      method: 'eth_subscription',\n      params: {\n        subscription: filterIdHex,\n        result: value\n      }\n    });\n  }\n\n  function destroy() {\n    events.removeAllListeners();\n\n    for (const id in subscriptions) {\n      subscriptions[id].destroy();\n      delete subscriptions[id];\n    }\n\n    isDestroyed = true;\n  }\n}\n\nfunction normalizeBlock(block) {\n  return {\n    hash: block.hash,\n    parentHash: block.parentHash,\n    sha3Uncles: block.sha3Uncles,\n    miner: block.miner,\n    stateRoot: block.stateRoot,\n    transactionsRoot: block.transactionsRoot,\n    receiptsRoot: block.receiptsRoot,\n    logsBloom: block.logsBloom,\n    difficulty: block.difficulty,\n    number: block.number,\n    gasLimit: block.gasLimit,\n    gasUsed: block.gasUsed,\n    nonce: block.nonce,\n    mixHash: block.mixHash,\n    timestamp: block.timestamp,\n    extraData: block.extraData\n  };\n}","map":null,"metadata":{},"sourceType":"script"}