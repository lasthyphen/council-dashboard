{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filterFromParam = exports.FilterPolyfill = void 0;\n\nconst types_1 = require(\"../types\");\n\nconst util_1 = require(\"../util\");\n\nconst TIMEOUT = 5 * 60 * 1000; // 5 minutes\n\nconst JSONRPC_TEMPLATE = {\n  jsonrpc: \"2.0\",\n  id: 0\n};\n\nclass FilterPolyfill {\n  constructor(provider) {\n    this.logFilters = new Map(); // <id, filter>\n\n    this.blockFilters = new Set(); // <id>\n\n    this.pendingTransactionFilters = new Set(); // <id, true>\n\n    this.cursors = new Map(); // <id, cursor>\n\n    this.timeouts = new Map(); // <id, setTimeout id>\n\n    this.nextFilterId = types_1.IntNumber(1);\n    this.provider = provider;\n  }\n\n  async newFilter(param) {\n    const filter = filterFromParam(param);\n    const id = this.makeFilterId();\n    const cursor = await this.setInitialCursorPosition(id, filter.fromBlock);\n    console.log(`Installing new log filter(${id}):`, filter, \"initial cursor position:\", cursor);\n    this.logFilters.set(id, filter);\n    this.setFilterTimeout(id);\n    return util_1.hexStringFromIntNumber(id);\n  }\n\n  async newBlockFilter() {\n    const id = this.makeFilterId();\n    const cursor = await this.setInitialCursorPosition(id, \"latest\");\n    console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);\n    this.blockFilters.add(id);\n    this.setFilterTimeout(id);\n    return util_1.hexStringFromIntNumber(id);\n  }\n\n  async newPendingTransactionFilter() {\n    const id = this.makeFilterId();\n    const cursor = await this.setInitialCursorPosition(id, \"latest\");\n    console.log(`Installing new block filter (${id}) with initial cursor position:`, cursor);\n    this.pendingTransactionFilters.add(id);\n    this.setFilterTimeout(id);\n    return util_1.hexStringFromIntNumber(id);\n  }\n\n  uninstallFilter(filterId) {\n    const id = util_1.intNumberFromHexString(filterId);\n    console.log(`Uninstalling filter (${id})`);\n    this.deleteFilter(id);\n    return true;\n  }\n\n  getFilterChanges(filterId) {\n    const id = util_1.intNumberFromHexString(filterId);\n\n    if (this.timeouts.has(id)) {\n      // extend timeout\n      this.setFilterTimeout(id);\n    }\n\n    if (this.logFilters.has(id)) {\n      return this.getLogFilterChanges(id);\n    } else if (this.blockFilters.has(id)) {\n      return this.getBlockFilterChanges(id);\n    } else if (this.pendingTransactionFilters.has(id)) {\n      return this.getPendingTransactionFilterChanges(id);\n    }\n\n    return Promise.resolve(filterNotFoundError());\n  }\n\n  async getFilterLogs(filterId) {\n    const id = util_1.intNumberFromHexString(filterId);\n    const filter = this.logFilters.get(id);\n\n    if (!filter) {\n      return filterNotFoundError();\n    }\n\n    return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n      method: \"eth_getLogs\",\n      params: [paramFromFilter(filter)]\n    }));\n  }\n\n  makeFilterId() {\n    return types_1.IntNumber(++this.nextFilterId);\n  }\n\n  sendAsyncPromise(request) {\n    return new Promise((resolve, reject) => {\n      this.provider.sendAsync(request, (err, response) => {\n        if (err) {\n          return reject(err);\n        }\n\n        if (Array.isArray(response) || response == null) {\n          return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));\n        }\n\n        resolve(response);\n      });\n    });\n  }\n\n  deleteFilter(id) {\n    console.log(`Deleting filter (${id})`);\n    this.logFilters.delete(id);\n    this.blockFilters.delete(id);\n    this.pendingTransactionFilters.delete(id);\n    this.cursors.delete(id);\n    this.timeouts.delete(id);\n  }\n\n  async getLogFilterChanges(id) {\n    const filter = this.logFilters.get(id);\n    const cursorPosition = this.cursors.get(id);\n\n    if (!cursorPosition || !filter) {\n      return filterNotFoundError();\n    }\n\n    const currentBlockHeight = await this.getCurrentBlockHeight();\n    const toBlock = filter.toBlock === \"latest\" ? currentBlockHeight : filter.toBlock;\n\n    if (cursorPosition > currentBlockHeight) {\n      return emptyResult();\n    }\n\n    if (cursorPosition > filter.toBlock) {\n      return emptyResult();\n    }\n\n    console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id}`);\n    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n      method: \"eth_getLogs\",\n      params: [paramFromFilter(Object.assign(Object.assign({}, filter), {\n        fromBlock: cursorPosition,\n        toBlock\n      }))]\n    }));\n\n    if (Array.isArray(response.result)) {\n      const blocks = response.result.map(log => util_1.intNumberFromHexString(log.blockNumber || \"0x0\"));\n      const highestBlock = Math.max(...blocks);\n\n      if (highestBlock && highestBlock > cursorPosition) {\n        const newCursorPosition = types_1.IntNumber(highestBlock + 1);\n        console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);\n        this.cursors.set(id, newCursorPosition);\n      }\n    }\n\n    return response;\n  }\n\n  async getBlockFilterChanges(id) {\n    const cursorPosition = this.cursors.get(id);\n\n    if (!cursorPosition) {\n      return filterNotFoundError();\n    }\n\n    const currentBlockHeight = await this.getCurrentBlockHeight();\n\n    if (cursorPosition > currentBlockHeight) {\n      return emptyResult();\n    }\n\n    console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id})`);\n    const blocks = (await Promise.all(util_1.range(cursorPosition, currentBlockHeight + 1).map(i => this.getBlockHashByNumber(types_1.IntNumber(i))))).filter(hash => !!hash);\n    const newCursorPosition = types_1.IntNumber(cursorPosition + blocks.length);\n    console.log(`Moving cursor position for filter (${id}) from ${cursorPosition} to ${newCursorPosition}`);\n    this.cursors.set(id, newCursorPosition);\n    return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n      result: blocks\n    });\n  }\n\n  async getPendingTransactionFilterChanges(_id) {\n    // pending transaction filters are not supported\n    return Promise.resolve(emptyResult());\n  }\n\n  async setInitialCursorPosition(id, startBlock) {\n    const currentBlockHeight = await this.getCurrentBlockHeight();\n    const initialCursorPosition = typeof startBlock === \"number\" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;\n    this.cursors.set(id, initialCursorPosition);\n    return initialCursorPosition;\n  }\n\n  setFilterTimeout(id) {\n    const existing = this.timeouts.get(id);\n\n    if (existing) {\n      window.clearTimeout(existing);\n    }\n\n    const timeout = window.setTimeout(() => {\n      console.log(`Filter (${id}) timed out`);\n      this.deleteFilter(id);\n    }, TIMEOUT);\n    this.timeouts.set(id, timeout);\n  }\n\n  async getCurrentBlockHeight() {\n    const {\n      result\n    } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n      method: \"eth_blockNumber\",\n      params: []\n    }));\n    return util_1.intNumberFromHexString(util_1.ensureHexString(result));\n  }\n\n  async getBlockHashByNumber(blockNumber) {\n    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n      method: \"eth_getBlockByNumber\",\n      params: [util_1.hexStringFromIntNumber(blockNumber), false]\n    }));\n\n    if (response.result && typeof response.result.hash === \"string\") {\n      return util_1.ensureHexString(response.result.hash);\n    }\n\n    return null;\n  }\n\n}\n\nexports.FilterPolyfill = FilterPolyfill;\n\nfunction filterFromParam(param) {\n  return {\n    fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),\n    toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),\n    addresses: param.address === undefined ? null : Array.isArray(param.address) ? param.address : [param.address],\n    topics: param.topics || []\n  };\n}\n\nexports.filterFromParam = filterFromParam;\n\nfunction paramFromFilter(filter) {\n  const param = {\n    fromBlock: hexBlockHeightFromIntBlockHeight(filter.fromBlock),\n    toBlock: hexBlockHeightFromIntBlockHeight(filter.toBlock),\n    topics: filter.topics\n  };\n\n  if (filter.addresses !== null) {\n    param.address = filter.addresses;\n  }\n\n  return param;\n}\n\nfunction intBlockHeightFromHexBlockHeight(value) {\n  if (value === undefined || value === \"latest\" || value === \"pending\") {\n    return \"latest\";\n  } else if (value === \"earliest\") {\n    return types_1.IntNumber(0);\n  } else if (util_1.isHexString(value)) {\n    return util_1.intNumberFromHexString(value);\n  }\n\n  throw new Error(`Invalid block option: ${value}`);\n}\n\nfunction hexBlockHeightFromIntBlockHeight(value) {\n  if (value === \"latest\") {\n    return value;\n  }\n\n  return util_1.hexStringFromIntNumber(value);\n}\n\nfunction filterNotFoundError() {\n  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n    error: {\n      code: -32000,\n      message: \"filter not found\"\n    }\n  });\n}\n\nfunction emptyResult() {\n  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), {\n    result: []\n  });\n}","map":null,"metadata":{},"sourceType":"script"}