{"ast":null,"code":"import _typeof from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/typeof\";import _objectSpread from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{ANJMovement as anjMovementTypes,ANJBalance as anjBalanceTypes,movementDirection,STAKE_ACTIVATION_MOVEMENT}from'../types/anj-types';import{bigNum}from'../lib/math-utils';/**\n * Function intended to group Stake and Activation movements that were created at the same time\n *  into one StakeActivation movement\n * This is needed since moving ANJ from wallet to Active Balance, two movements\n *  are performed (Wallet (stake) => InactiveBalance; Inactive balance (activate) => Active balance)\n * @param {Array} movements Array of original movements\n * @returns {Array} Resuling array of movements grouped by the logic described above\n */export var groupMovements=function groupMovements(movements){// If the juror is activating from the wallet we need to just show an incoming movement in the Active balance\n// and an outgoing movement in the Wallet balance\nreturn movements.reduce(function(movements,currentMovement,index,prevMovements){var prevMovement=prevMovements[index-1];if(index>0&&anjMovementTypes[prevMovement.type]===anjMovementTypes.Activation&&anjMovementTypes[currentMovement.type]===anjMovementTypes.Stake&&prevMovement.createdAt===currentMovement.createdAt){movements[movements.length-1].type=STAKE_ACTIVATION_MOVEMENT;return movements;}movements.push(_objectSpread({},currentMovement,{effectiveTermId:currentMovement.effectiveTermId?parseInt(currentMovement.effectiveTermId,10):null,amount:bigNum(currentMovement.amount)}));return movements;},[]);};// The intention here is to know which movements types should correspond with each balance\nexport var acceptedMovementsPerBalance=new Map([[anjBalanceTypes.Wallet,[{type:anjMovementTypes.Stake,direction:movementDirection.Outgoing},{type:anjMovementTypes.Unstake,direction:movementDirection.Incoming},{type:anjMovementTypes.StakeActivation,direction:movementDirection.Outgoing}]],[anjBalanceTypes.Inactive,[{type:anjMovementTypes.Stake,direction:movementDirection.Incoming},{type:anjMovementTypes.Unstake,direction:movementDirection.Outgoing},{type:anjMovementTypes.Reward,direction:movementDirection.Incoming},{type:anjMovementTypes.Activation,direction:movementDirection.Outgoing},{type:anjMovementTypes.Deactivation,direction:movementDirection.Incoming}]],[anjBalanceTypes.Active,[{type:anjMovementTypes.StakeActivation,direction:movementDirection.Incoming},{type:anjMovementTypes.Activation,direction:movementDirection.Incoming},{type:anjMovementTypes.Deactivation,direction:movementDirection.Outgoing},{type:anjMovementTypes.DeactivationProcess,direction:movementDirection.Locked},{type:anjMovementTypes.Lock,direction:movementDirection.Locked},{type:anjMovementTypes.Unlock,direction:movementDirection.Incoming},{type:anjMovementTypes.Slash,direction:movementDirection.Outgoing}]]]);export function isMovementOf(movements,movementType){return movements.some(function(movement){return movement.type===movementType;});}/**\n * Gets the direction of a movement [Incoming, Outgoing, Locked]\n * @param {Array} acceptedMovements Array of movements accepted for `movementType`\n * @param {Symbol} movementType type of movement\n * @returns {Symbol} The direction of the movement\n */export function getMovementDirection(acceptedMovements,movementType){var _acceptedMovements$fi=acceptedMovements.find(function(elem){return elem.type===movementType;}),direction=_acceptedMovements$fi.direction;return direction;}/**\n * Tells whether a movement is effective or not\n * @param {Object} movement Movement to check effectiveness of\n * @param {Number} currentTermId Id of the current term\n * @returns {Boolean} True if the movement is effective\n */export function isMovementEffective(movement,currentTermId){if(!movement.effectiveTermId)return true;return movement.effectiveTermId<=currentTermId;}export function getAmountNotEffectiveByMovement(movements,movementType){return movements.filter(function(mov){return!mov.isEffective&&anjMovementTypes[mov.type]===movementType;}).reduce(function(acc,mov){return acc.add(mov.amount);},bigNum(0));}/**\n * Gets the total amount not yet effective for a given type of balance\n * @param {Array} movements Array of movements to get the total not effective from\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\n * @returns {BigNum} Total amount not yet effective\n */export function getAmountNotEffectiveByBalance(movements,balanceType){// We need to calulate the total not effective amount for the active and inactive balance\n// Note that we don't do this for the wallet balance since all its corresponding movements are done effective inmediately\n// Note that this assumes the termDuration is less than 24hrs\nif(balanceType===anjBalanceTypes.Wallet){return bigNum(0);}var movementType=balanceType===anjBalanceTypes.Active?anjMovementTypes.Activation:anjMovementTypes.Deactivation;return getAmountNotEffectiveByMovement(movements,movementType);}/**\n * gets the latest movement depending on the type of balance\n * @dev Note that for the Active balance, if there are deactivation requests not yet effective\n * we must give them priority over the rest\n *\n * @param {Array} movements Array of movements to get the latest from\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\n * @returns {Object} Latest movement (if any) relative to the type of balance\n */export function getLatestMovementByBalance(movements,balanceType){if(!movements.length){return null;}// We have to give a special treatment to the active balance since\n// deactivation requests that are not yet effective have more priority than the rest\nif(balanceType===anjBalanceTypes.Active){var totalDeactivationsNotEffective=getAmountNotEffectiveByMovement(movements,anjMovementTypes.Deactivation);if(totalDeactivationsNotEffective.gt(0)){return{amount:totalDeactivationsNotEffective,type:anjMovementTypes.DeactivationProcess};}}// Get the latest movement\nvar latestMovement=movements[0];var latestMovementType=anjMovementTypes[latestMovement.type];// If the latest movement for the active or inactive balance is a deactivation, we must check that the deactivation is effective\nif(latestMovementType===anjMovementTypes.Deactivation){if(balanceType===anjBalanceTypes.Inactive&&!latestMovement.isEffective){// In case the deactivation is not effective, we'll get the most recent effective or immediate movement for the inactive balance\n// Note that the array is orderer by most recent desc\nlatestMovement=movements.find(function(movement){return movement.isEffective||movement.isImmediate;});if(!latestMovement||anjMovementTypes[latestMovement.type]!==anjMovementTypes.Deactivation){return latestMovement;}}// We get here if all this conditions are given\n// - Latest movement is a Deactivation\n// - Latest movement is Effective\n// - We are calculating latest movement for Active or Inactive balance\n// In all these cases, we need to get all deactivations\n// done effective on the same term as this latest movement\nreturn _objectSpread({},latestMovement,{amount:getTotalEffectiveAt(movements,anjMovementTypes.Deactivation,latestMovement.effectiveTermId)});}return latestMovement;}/**\n * Calculates the aggregated effective movements amount at term `termId`\n * @param {Array} movements Array of movements\n * @param {Symbol} movementType Type of movement\n * @param {Number} termId Id of the term\n * @returns {BigNum} Total effective movements amount at `termId`\n */function getTotalEffectiveAt(movements,movementType,termId){return movements.filter(function(movement){return anjMovementTypes[movement.type]===movementType&&movement.effectiveTermId===termId;}).reduce(function(acc,movement){return acc.add(movement.amount);},bigNum(0));}export function convertMovement(acceptedMovements,movement){if(!movement)return null;var movementType=_typeof(movement.type)==='symbol'?movement.type:anjMovementTypes[movement.type];var direction=getMovementDirection(acceptedMovements,movementType);return{type:movementType,amount:movement.amount,direction:direction};}export function getUpdatedLockedMovement(lockedBalance,latestMovement){if(!lockedBalance||lockedBalance.eq(0)){return latestMovement;}// In the case that the juror has locked balance, we must update the active balance latest movement\nvar movementTypeLock=anjMovementTypes.Lock;var newLockedAmount=lockedBalance;// If active balance latest movement is a deactivation process, we must update the amount\nif((latestMovement===null||latestMovement===void 0?void 0:latestMovement.type)===anjMovementTypes.DeactivationProcess){newLockedAmount=newLockedAmount.add(latestMovement.amount);}return _objectSpread({},latestMovement,{amount:newLockedAmount,type:movementTypeLock});}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/utils/anj-movement-utils.js"],"names":["ANJMovement","anjMovementTypes","ANJBalance","anjBalanceTypes","movementDirection","STAKE_ACTIVATION_MOVEMENT","bigNum","groupMovements","movements","reduce","currentMovement","index","prevMovements","prevMovement","type","Activation","Stake","createdAt","length","push","effectiveTermId","parseInt","amount","acceptedMovementsPerBalance","Map","Wallet","direction","Outgoing","Unstake","Incoming","StakeActivation","Inactive","Reward","Deactivation","Active","DeactivationProcess","Locked","Lock","Unlock","Slash","isMovementOf","movementType","some","movement","getMovementDirection","acceptedMovements","find","elem","isMovementEffective","currentTermId","getAmountNotEffectiveByMovement","filter","mov","isEffective","acc","add","getAmountNotEffectiveByBalance","balanceType","getLatestMovementByBalance","totalDeactivationsNotEffective","gt","latestMovement","latestMovementType","isImmediate","getTotalEffectiveAt","termId","convertMovement","getUpdatedLockedMovement","lockedBalance","eq","movementTypeLock","newLockedAmount"],"mappings":"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","sourcesContent":["import {\n  ANJMovement as anjMovementTypes,\n  ANJBalance as anjBalanceTypes,\n  movementDirection,\n  STAKE_ACTIVATION_MOVEMENT,\n} from '../types/anj-types'\nimport { bigNum } from '../lib/math-utils'\n\n/**\n * Function intended to group Stake and Activation movements that were created at the same time\n *  into one StakeActivation movement\n * This is needed since moving ANJ from wallet to Active Balance, two movements\n *  are performed (Wallet (stake) => InactiveBalance; Inactive balance (activate) => Active balance)\n * @param {Array} movements Array of original movements\n * @returns {Array} Resuling array of movements grouped by the logic described above\n */\nexport const groupMovements = movements => {\n  // If the juror is activating from the wallet we need to just show an incoming movement in the Active balance\n  // and an outgoing movement in the Wallet balance\n  return movements.reduce(\n    (movements, currentMovement, index, prevMovements) => {\n      const prevMovement = prevMovements[index - 1]\n\n      if (\n        index > 0 &&\n        anjMovementTypes[prevMovement.type] === anjMovementTypes.Activation &&\n        anjMovementTypes[currentMovement.type] === anjMovementTypes.Stake &&\n        prevMovement.createdAt === currentMovement.createdAt\n      ) {\n        movements[movements.length - 1].type = STAKE_ACTIVATION_MOVEMENT\n        return movements\n      }\n\n      movements.push({\n        ...currentMovement,\n        effectiveTermId: currentMovement.effectiveTermId\n          ? parseInt(currentMovement.effectiveTermId, 10)\n          : null,\n        amount: bigNum(currentMovement.amount),\n      })\n\n      return movements\n    },\n    []\n  )\n}\n\n// The intention here is to know which movements types should correspond with each balance\nexport const acceptedMovementsPerBalance = new Map([\n  [\n    anjBalanceTypes.Wallet,\n    [\n      { type: anjMovementTypes.Stake, direction: movementDirection.Outgoing },\n      { type: anjMovementTypes.Unstake, direction: movementDirection.Incoming },\n      {\n        type: anjMovementTypes.StakeActivation,\n        direction: movementDirection.Outgoing,\n      },\n    ],\n  ],\n  [\n    anjBalanceTypes.Inactive,\n    [\n      { type: anjMovementTypes.Stake, direction: movementDirection.Incoming },\n      { type: anjMovementTypes.Unstake, direction: movementDirection.Outgoing },\n      { type: anjMovementTypes.Reward, direction: movementDirection.Incoming },\n      {\n        type: anjMovementTypes.Activation,\n        direction: movementDirection.Outgoing,\n      },\n      {\n        type: anjMovementTypes.Deactivation,\n        direction: movementDirection.Incoming,\n      },\n    ],\n  ],\n  [\n    anjBalanceTypes.Active,\n    [\n      {\n        type: anjMovementTypes.StakeActivation,\n        direction: movementDirection.Incoming,\n      },\n      {\n        type: anjMovementTypes.Activation,\n        direction: movementDirection.Incoming,\n      },\n      {\n        type: anjMovementTypes.Deactivation,\n        direction: movementDirection.Outgoing,\n      },\n      {\n        type: anjMovementTypes.DeactivationProcess,\n        direction: movementDirection.Locked,\n      },\n      { type: anjMovementTypes.Lock, direction: movementDirection.Locked },\n      { type: anjMovementTypes.Unlock, direction: movementDirection.Incoming },\n      { type: anjMovementTypes.Slash, direction: movementDirection.Outgoing },\n    ],\n  ],\n])\n\nexport function isMovementOf(movements, movementType) {\n  return movements.some(movement => movement.type === movementType)\n}\n\n/**\n * Gets the direction of a movement [Incoming, Outgoing, Locked]\n * @param {Array} acceptedMovements Array of movements accepted for `movementType`\n * @param {Symbol} movementType type of movement\n * @returns {Symbol} The direction of the movement\n */\nexport function getMovementDirection(acceptedMovements, movementType) {\n  const { direction } = acceptedMovements.find(\n    elem => elem.type === movementType\n  )\n\n  return direction\n}\n\n/**\n * Tells whether a movement is effective or not\n * @param {Object} movement Movement to check effectiveness of\n * @param {Number} currentTermId Id of the current term\n * @returns {Boolean} True if the movement is effective\n */\nexport function isMovementEffective(movement, currentTermId) {\n  if (!movement.effectiveTermId) return true\n\n  return movement.effectiveTermId <= currentTermId\n}\n\nexport function getAmountNotEffectiveByMovement(movements, movementType) {\n  return movements\n    .filter(\n      mov => !mov.isEffective && anjMovementTypes[mov.type] === movementType\n    )\n    .reduce((acc, mov) => acc.add(mov.amount), bigNum(0))\n}\n\n/**\n * Gets the total amount not yet effective for a given type of balance\n * @param {Array} movements Array of movements to get the total not effective from\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\n * @returns {BigNum} Total amount not yet effective\n */\nexport function getAmountNotEffectiveByBalance(movements, balanceType) {\n  // We need to calulate the total not effective amount for the active and inactive balance\n  // Note that we don't do this for the wallet balance since all its corresponding movements are done effective inmediately\n  // Note that this assumes the termDuration is less than 24hrs\n  if (balanceType === anjBalanceTypes.Wallet) {\n    return bigNum(0)\n  }\n\n  const movementType =\n    balanceType === anjBalanceTypes.Active\n      ? anjMovementTypes.Activation\n      : anjMovementTypes.Deactivation\n\n  return getAmountNotEffectiveByMovement(movements, movementType)\n}\n\n/**\n * gets the latest movement depending on the type of balance\n * @dev Note that for the Active balance, if there are deactivation requests not yet effective\n * we must give them priority over the rest\n *\n * @param {Array} movements Array of movements to get the latest from\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\n * @returns {Object} Latest movement (if any) relative to the type of balance\n */\nexport function getLatestMovementByBalance(movements, balanceType) {\n  if (!movements.length) {\n    return null\n  }\n\n  // We have to give a special treatment to the active balance since\n  // deactivation requests that are not yet effective have more priority than the rest\n  if (balanceType === anjBalanceTypes.Active) {\n    const totalDeactivationsNotEffective = getAmountNotEffectiveByMovement(\n      movements,\n      anjMovementTypes.Deactivation\n    )\n\n    if (totalDeactivationsNotEffective.gt(0)) {\n      return {\n        amount: totalDeactivationsNotEffective,\n        type: anjMovementTypes.DeactivationProcess,\n      }\n    }\n  }\n\n  // Get the latest movement\n  let latestMovement = movements[0]\n  const latestMovementType = anjMovementTypes[latestMovement.type]\n\n  // If the latest movement for the active or inactive balance is a deactivation, we must check that the deactivation is effective\n  if (latestMovementType === anjMovementTypes.Deactivation) {\n    if (\n      balanceType === anjBalanceTypes.Inactive &&\n      !latestMovement.isEffective\n    ) {\n      // In case the deactivation is not effective, we'll get the most recent effective or immediate movement for the inactive balance\n      // Note that the array is orderer by most recent desc\n      latestMovement = movements.find(\n        movement => movement.isEffective || movement.isImmediate\n      )\n\n      if (\n        !latestMovement ||\n        anjMovementTypes[latestMovement.type] !== anjMovementTypes.Deactivation\n      ) {\n        return latestMovement\n      }\n    }\n\n    // We get here if all this conditions are given\n    // - Latest movement is a Deactivation\n    // - Latest movement is Effective\n    // - We are calculating latest movement for Active or Inactive balance\n\n    // In all these cases, we need to get all deactivations\n    // done effective on the same term as this latest movement\n    return {\n      ...latestMovement,\n      amount: getTotalEffectiveAt(\n        movements,\n        anjMovementTypes.Deactivation,\n        latestMovement.effectiveTermId\n      ),\n    }\n  }\n\n  return latestMovement\n}\n\n/**\n * Calculates the aggregated effective movements amount at term `termId`\n * @param {Array} movements Array of movements\n * @param {Symbol} movementType Type of movement\n * @param {Number} termId Id of the term\n * @returns {BigNum} Total effective movements amount at `termId`\n */\nfunction getTotalEffectiveAt(movements, movementType, termId) {\n  return movements\n    .filter(\n      movement =>\n        anjMovementTypes[movement.type] === movementType &&\n        movement.effectiveTermId === termId\n    )\n    .reduce((acc, movement) => acc.add(movement.amount), bigNum(0))\n}\n\nexport function convertMovement(acceptedMovements, movement) {\n  if (!movement) return null\n\n  const movementType =\n    typeof movement.type === 'symbol'\n      ? movement.type\n      : anjMovementTypes[movement.type]\n\n  const direction = getMovementDirection(acceptedMovements, movementType)\n\n  return {\n    type: movementType,\n    amount: movement.amount,\n    direction,\n  }\n}\n\nexport function getUpdatedLockedMovement(lockedBalance, latestMovement) {\n  if (!lockedBalance || lockedBalance.eq(0)) {\n    return latestMovement\n  }\n\n  // In the case that the juror has locked balance, we must update the active balance latest movement\n  const movementTypeLock = anjMovementTypes.Lock\n  let newLockedAmount = lockedBalance\n\n  // If active balance latest movement is a deactivation process, we must update the amount\n  if (latestMovement?.type === anjMovementTypes.DeactivationProcess) {\n    newLockedAmount = newLockedAmount.add(latestMovement.amount)\n  }\n\n  return {\n    ...latestMovement,\n    amount: newLockedAmount,\n    type: movementTypeLock,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}