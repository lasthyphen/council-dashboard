{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _types = _interopRequireDefault(require(\"../types\"));\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.scan = scan, exports.Scanner = void 0;\n/**\n* @module radspec/scanner\n*/\n\n/**\n* Enum for scanner state.\n*\n* @readonly\n* @enum {string}\n*/\n\nvar SCANNER_STATE = {\n  OK: \"OK\",\n  ERROR: \"ERROR\"\n};\n/**\n* A scanner that identifies tokens in a source string.\n*\n* @class Scanner\n* @param {string} source The source code\n* @property {string} state The state of the parser (`OK` or `ERROR`)\n* @property {string} source The source code\n* @property {number} cursor\n* @property {Array<Token>} tokens The currently identified tokens\n*/\n\nvar Scanner =\n/*#__PURE__*/\nfunction () {\n  function Scanner(source) {\n    _classCallCheck(this, Scanner);\n\n    this.state = SCANNER_STATE.OK, this.isInExpression = !1, this.source = source, this.cursor = 0, this.tokens = [];\n  }\n  /**\n  * Scans a single token from source and pushes it to `Scanner.tokens`.\n  *\n  * @return {void}\n  */\n\n\n  _createClass(Scanner, [{\n    key: \"scanToken\",\n    value: function scanToken() {\n      var current = this.consume();\n      if (\"`\" === current) return this.isInExpression = !this.isInExpression, void this.emitToken(\"TICK\"); // We haven't hit a tick yet, so we're not in an expression\n\n      if (!this.isInExpression) {\n        // Scan until tick\n        var monologue = current;\n\n        for (; \"`\" !== this.peek() && !this.eof();) {\n          monologue += this.consume();\n        }\n\n        return void this.emitToken(\"MONOLOGUE\", monologue);\n      }\n\n      switch (current) {\n        // Single character tokens\n        case \"(\":\n          this.emitToken(\"LEFT_PAREN\");\n          break;\n\n        case \")\":\n          this.emitToken(\"RIGHT_PAREN\");\n          break;\n\n        case \",\":\n          this.emitToken(\"COMMA\");\n          break;\n\n        case \".\":\n          this.emitToken(\"DOT\");\n          break;\n\n        case \":\":\n          this.emitToken(\"COLON\");\n          break;\n\n        case \"-\":\n          this.emitToken(\"MINUS\");\n          break;\n\n        case \"+\":\n          this.emitToken(\"PLUS\");\n          break;\n\n        case \"^\":\n          this.emitToken(\"POWER\");\n          break;\n\n        case \"*\":\n          this.emitToken(\"STAR\");\n          break;\n\n        case \"/\":\n          this.emitToken(\"SLASH\");\n          break;\n\n        case \"%\":\n          this.emitToken(\"MODULO\");\n          break;\n\n        case \"?\":\n          this.emitToken(\"QUESTION_MARK\");\n          break;\n\n        case \"@\":\n          this.emitToken(\"AT\");\n          break;\n        // One or two character tokens\n\n        case \"!\":\n          this.emitToken(this.matches(\"=\") ? \"BANG_EQUAL\" : \"BANG\");\n          break;\n\n        case \"=\":\n          this.emitToken(this.matches(\"=\") ? \"EQUAL_EQUAL\" : \"EQUAL\");\n          break;\n\n        case \"<\":\n          this.emitToken(this.matches(\"=\") ? \"LESS_EQUAL\" : \"LESS\");\n          break;\n\n        case \">\":\n          this.emitToken(this.matches(\"=\") ? \"GREATER_EQUAL\" : \"GREATER\");\n          break;\n        // Two character tokens\n\n        case \"|\":\n          this.matches(\"|\") ? this.emitToken(\"DOUBLE_VERTICAL_BAR\") : this.report(\"Unexpected single \\\"|\\\" (expecting two)\");\n          break;\n        // Whitespace\n\n        case \" \":\n        case \"\\r\":\n        case \"\\n\":\n        case \"\\t\":\n          break;\n        // Multi-character tokens\n\n        default:\n          var NUMBERS = /[0-9]/;\n\n          if (NUMBERS.test(current)) {\n            var number = current,\n                type = \"NUMBER\"; // Detect hexadecimals\n\n            if (\"0\" === current && \"x\" === this.peek()) for (type = \"HEXADECIMAL\", number += this.consume(); /[0-9a-f]/i.test(this.peek());) {\n              number += this.consume();\n            } else for (; NUMBERS.test(this.peek());) {\n              number += this.consume();\n            }\n            this.emitToken(type, number);\n            break;\n          }\n\n          var IDENTIFIERS = /[_$a-z0-9]/i;\n\n          if (IDENTIFIERS.test(current)) {\n            var identifier = current;\n\n            for (; IDENTIFIERS.test(this.peek());) {\n              identifier += this.consume();\n            }\n\n            if (\"true\" === identifier || \"false\" === identifier) {\n              this.emitToken(\"BOOLEAN\", identifier);\n              break;\n            }\n\n            _types.default.isType(identifier) ? this.emitToken(\"TYPE\", identifier) : this.emitToken(\"IDENTIFIER\", identifier);\n            break;\n          }\n\n          if (\"'\" === current || \"\\\"\" === current) {\n            var string = \"\";\n\n            for (; !this.matches(\"'\") && !this.matches(\"\\\"\");) {\n              string += this.consume();\n            }\n\n            this.emitToken(\"STRING\", string);\n            break;\n          }\n\n          this.report(\"Unexpected character \\\"\".concat(current, \"\\\"\"));\n      }\n    }\n    /**\n    * Push a token to `Scanner.tokens`\n    *\n    * @param {string} type The token type\n    * @param {string?} value The token value\n    * @return {void}\n    */\n\n  }, {\n    key: \"emitToken\",\n    value: function emitToken(type, value) {\n      var token = {\n        type: type\n      };\n      value && (token.value = value), this.tokens.push(token);\n    }\n    /**\n    * Get the current character and increase the cursor by 1\n    *\n    * @return {string}\n    */\n\n  }, {\n    key: \"consume\",\n    value: function consume() {\n      return this.cursor++, this.source[this.cursor - 1];\n    }\n    /**\n    * Get the character under the cursor without consuming it.\n    *\n    * @return {string}\n    */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.source[this.cursor];\n    }\n    /**\n    * Checks if the next character matches an expected one.\n    *\n    * Increases the cursor by 1 if the character matches.\n    *\n    * @param {string} expected The character to expect\n    * @return {boolean} True if the next character matches, otherise false\n    */\n\n  }, {\n    key: \"matches\",\n    value: function matches(expected) {\n      return !this.eof() && !(this.peek() !== expected) && (this.cursor++, !0);\n    }\n    /**\n    * Scans source and returns a list of tokens.\n    *\n    * @return {Array<Token>}\n    */\n\n  }, {\n    key: \"scan\",\n    value: function () {\n      var _scan = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                for (; !this.eof();) {\n                  this.scanToken();\n                }\n\n                return _context.abrupt(\"return\", this.state === SCANNER_STATE.ERROR ? void console.error(\"Errors encountered while scanning source\") : this.tokens);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function scan() {\n        return _scan.apply(this, arguments);\n      }\n\n      return scan;\n    }()\n    /**\n    * Returns true if we've reached the end of source, otherwise false.\n    *\n    * @return {boolean}\n    */\n\n  }, {\n    key: \"eof\",\n    value: function eof() {\n      return this.cursor >= this.source.length;\n    }\n    /**\n    * Prints an error with location information to `stderr`\n    * and sets the scanner state to `SCANNER_STATE.ERROR`\n    *\n    * @param {string} error\n    * @return {void}\n    */\n\n  }, {\n    key: \"report\",\n    value: function report(error) {\n      this.state = SCANNER_STATE.ERROR, console.error(\"Error (\".concat(this.cursor, \"): \").concat(error));\n    }\n  }]);\n\n  return Scanner;\n}();\n/**\n* Scans source and returns a list of tokens.\n*\n* @memberof radspec/scanner\n* @param  {string} source\n* @return {Array<Token>}\n*/\n\n\nexports.Scanner = Scanner;\n\nfunction scan(source) {\n  return new Scanner(source).scan();\n}","map":null,"metadata":{},"sourceType":"script"}