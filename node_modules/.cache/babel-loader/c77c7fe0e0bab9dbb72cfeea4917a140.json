{"ast":null,"code":"import _styled from \"styled-components\";\nvar _jsxFileName = \"/Users/saleemfareed/oneds/court-dashboard/src/components/Disputes/DisputeAutoReveal.js\";\nimport React, { useCallback, useEffect, useState } from 'react';\nimport { Button, GU, Info } from '@aragon/ui';\nimport { useWallet } from '../../providers/Wallet';\nimport { getAutoRevealRequest } from '../../services/autoReveal';\nimport { getAutoRevealPreference, getCodeFromLocalStorage, getOutcomeFromCommitment, getVoteId } from '../../utils/crvoting-utils';\n\nfunction DisputeAutoReveal({\n  commitment,\n  disputeId,\n  onAutoReveal,\n  roundId\n}) {\n  const {\n    account\n  } = useWallet(); // We need to poll for the auto reveal request as we are using the request queue processor for processing juror's request to re-register\n  // to the service and since the request flow is asynchronous, we can't ensure whether it was succesful or not.\n\n  const [autoRevealRequested, loading] = useAutoRevealPolling(account, disputeId, roundId);\n\n  if (loading) {\n    return null;\n  } // Juror already requested the auto reveal service for this dispute\n\n\n  if (autoRevealRequested) {\n    return React.createElement(Info, {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 30\n      },\n      __self: this\n    }, \"Auto reveal requested!\");\n  } // Juror requested the auto reveal service and failed or juror didn't request the service at all.\n  // For the later case it's still useful to give the juror the option to do so.\n\n\n  return React.createElement(RequestAutoReveal, {\n    commitment: commitment,\n    disputeId: disputeId,\n    onAutoReveal: onAutoReveal,\n    roundId: roundId,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 36\n    },\n    __self: this\n  });\n}\n\nvar _StyledInfo = _styled(Info).withConfig({\n  displayName: \"DisputeAutoReveal___StyledInfo\",\n  componentId: \"f0ndr2-0\"\n})([\"margin-top:\", \"px;\"], p => p._css);\n\nfunction RequestAutoReveal({\n  commitment,\n  disputeId,\n  onAutoReveal,\n  roundId\n}) {\n  const {\n    account\n  } = useWallet();\n  const voteId = getVoteId(disputeId, roundId);\n  const autoRevealPreviouslyRequested = getAutoRevealPreference(account, voteId);\n  const handleSubmit = useCallback(event => {\n    event.preventDefault();\n    const password = getCodeFromLocalStorage(account, disputeId);\n    const outcome = getOutcomeFromCommitment(commitment, password);\n    onAutoReveal(account, disputeId, roundId, outcome, password);\n  }, [account, commitment, disputeId, onAutoReveal, roundId]);\n  return React.createElement(\"form\", {\n    onSubmit: handleSubmit,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63\n    },\n    __self: this\n  }, React.createElement(Button, {\n    label: \"Reveal your vote with auto-reveal service\",\n    mode: \"strong\",\n    type: \"submit\",\n    wide: true,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64\n    },\n    __self: this\n  }), autoRevealPreviouslyRequested && React.createElement(_StyledInfo, {\n    mode: \"warning\",\n    _css: 2 * GU,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 71\n    },\n    __self: this\n  }, \"Your previous request to enable the auto-reveal service for this vote failed.\"));\n}\n\nfunction useAutoRevealPolling(account, disputeId, roundId) {\n  const [autoRevealRequested, setAutoRevealRequested] = useState(false);\n  const [loading, setLoading] = useState(true);\n  const timer = 3000;\n  useEffect(() => {\n    if (autoRevealRequested) {\n      return;\n    }\n\n    let cancelled = false; // Assumes jurorDraft exists\n\n    const pollAutoReveal = async () => {\n      try {\n        const reveal = await getAutoRevealRequest(account, disputeId, roundId);\n\n        if (!cancelled) {\n          setAutoRevealRequested(Boolean(reveal));\n        }\n      } catch (err) {\n        console.error(`Error fetching auto reveal: ${err} retryingâ€¦`);\n      }\n\n      if (!cancelled) {\n        setLoading(false); // Stop the polling once we know the juror successfully requested the auto reveal\n\n        if (!autoRevealRequested) {\n          setTimeout(pollAutoReveal, timer);\n        }\n      }\n    };\n\n    pollAutoReveal();\n    return () => {\n      cancelled = true;\n    };\n  }, [account, autoRevealRequested, disputeId, roundId]);\n  return [autoRevealRequested, loading];\n}\n\nexport default DisputeAutoReveal;","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/components/Disputes/DisputeAutoReveal.js"],"names":["React","useCallback","useEffect","useState","Button","GU","Info","useWallet","getAutoRevealRequest","getAutoRevealPreference","getCodeFromLocalStorage","getOutcomeFromCommitment","getVoteId","DisputeAutoReveal","commitment","disputeId","onAutoReveal","roundId","account","autoRevealRequested","loading","useAutoRevealPolling","RequestAutoReveal","voteId","autoRevealPreviouslyRequested","handleSubmit","event","preventDefault","password","outcome","setAutoRevealRequested","setLoading","timer","cancelled","pollAutoReveal","reveal","Boolean","err","console","error","setTimeout"],"mappings":"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","sourcesContent":["import React, { useCallback, useEffect, useState } from 'react'\nimport { Button, GU, Info } from '@aragon/ui'\nimport { useWallet } from '../../providers/Wallet'\n\nimport { getAutoRevealRequest } from '../../services/autoReveal'\nimport {\n  getAutoRevealPreference,\n  getCodeFromLocalStorage,\n  getOutcomeFromCommitment,\n  getVoteId,\n} from '../../utils/crvoting-utils'\n\nfunction DisputeAutoReveal({ commitment, disputeId, onAutoReveal, roundId }) {\n  const { account } = useWallet()\n\n  // We need to poll for the auto reveal request as we are using the request queue processor for processing juror's request to re-register\n  // to the service and since the request flow is asynchronous, we can't ensure whether it was succesful or not.\n  const [autoRevealRequested, loading] = useAutoRevealPolling(\n    account,\n    disputeId,\n    roundId\n  )\n\n  if (loading) {\n    return null\n  }\n\n  // Juror already requested the auto reveal service for this dispute\n  if (autoRevealRequested) {\n    return <Info>Auto reveal requested!</Info>\n  }\n\n  // Juror requested the auto reveal service and failed or juror didn't request the service at all.\n  // For the later case it's still useful to give the juror the option to do so.\n  return (\n    <RequestAutoReveal\n      commitment={commitment}\n      disputeId={disputeId}\n      onAutoReveal={onAutoReveal}\n      roundId={roundId}\n    />\n  )\n}\n\nfunction RequestAutoReveal({ commitment, disputeId, onAutoReveal, roundId }) {\n  const { account } = useWallet()\n  const voteId = getVoteId(disputeId, roundId)\n  const autoRevealPreviouslyRequested = getAutoRevealPreference(account, voteId)\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault()\n\n      const password = getCodeFromLocalStorage(account, disputeId)\n      const outcome = getOutcomeFromCommitment(commitment, password)\n\n      onAutoReveal(account, disputeId, roundId, outcome, password)\n    },\n    [account, commitment, disputeId, onAutoReveal, roundId]\n  )\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <Button\n        label=\"Reveal your vote with auto-reveal service\"\n        mode=\"strong\"\n        type=\"submit\"\n        wide\n      />\n      {autoRevealPreviouslyRequested && (\n        <Info\n          mode=\"warning\"\n          css={`\n            margin-top: ${2 * GU}px;\n          `}\n        >\n          Your previous request to enable the auto-reveal service for this vote\n          failed.\n        </Info>\n      )}\n    </form>\n  )\n}\n\nfunction useAutoRevealPolling(account, disputeId, roundId) {\n  const [autoRevealRequested, setAutoRevealRequested] = useState(false)\n  const [loading, setLoading] = useState(true)\n  const timer = 3000\n\n  useEffect(() => {\n    if (autoRevealRequested) {\n      return\n    }\n\n    let cancelled = false\n\n    // Assumes jurorDraft exists\n    const pollAutoReveal = async () => {\n      try {\n        const reveal = await getAutoRevealRequest(account, disputeId, roundId)\n        if (!cancelled) {\n          setAutoRevealRequested(Boolean(reveal))\n        }\n      } catch (err) {\n        console.error(`Error fetching auto reveal: ${err} retryingâ€¦`)\n      }\n\n      if (!cancelled) {\n        setLoading(false)\n\n        // Stop the polling once we know the juror successfully requested the auto reveal\n        if (!autoRevealRequested) {\n          setTimeout(pollAutoReveal, timer)\n        }\n      }\n    }\n\n    pollAutoReveal()\n\n    return () => {\n      cancelled = true\n    }\n  }, [account, autoRevealRequested, disputeId, roundId])\n\n  return [autoRevealRequested, loading]\n}\n\nexport default DisputeAutoReveal\n"]},"metadata":{},"sourceType":"module"}