{"ast":null,"code":"import _regeneratorRuntime from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import env from'../environment';import{providers as Providers,utils}from'ethers';import{InvalidURI,InvalidNetworkType,NoConnection}from'../errors';import{validHttpFormat}from'./uri-utils';var keccak256=utils.id,soliditySha3=utils.solidityKeccak256,toUtf8String=utils.toUtf8String;export var DEFAULT_LOCAL_CHAIN='private';export var ETH_FAKE_ADDRESS=\"0x\".concat(''.padEnd(40,'0'));var ETH_ADDRESS_SPLIT_REGEX=/(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g;var ETH_ADDRESS_TEST_REGEX=/(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g;export function getFunctionSignature(func){return keccak256(func).slice(0,10);}export function getUseWalletProviders(){var providers=[{id:'injected'}];if(env('FORTMATIC_API_KEY')){providers.push({id:'fortmatic',useWalletConf:{apiKey:env('FORTMATIC_API_KEY')}});}if(env('PORTIS_DAPP_ID')){providers.push({id:'portis',useWalletConf:{dAppId:env('PORTIS_DAPP_ID')}});}return providers;}export function getUseWalletConnectors(){return getUseWalletProviders().reduce(function(connectors,provider){if(provider.useWalletConf){connectors[provider.id]=provider.useWalletConf;}return connectors;},{});}function toChecksumAddress(address){if(!/^(0x)?[0-9a-f]{40}$/i.test(address)){throw new Error('Given address \"'+address+'\" is not a valid Ethereum address.');}address=address.toLowerCase().replace(/^0x/i,'');var addressHash=keccak256(address).replace(/^0x/i,'');var checksumAddress='0x';for(var i=0;i<address.length;i++){// If ith character is 9 to f then make it uppercase\nif(parseInt(addressHash[i],16)>7){checksumAddress+=address[i].toUpperCase();}else{checksumAddress+=address[i];}}return checksumAddress;}// Check address equality with checksums\nexport function addressesEqual(first,second){first=first&&toChecksumAddress(first);second=second&&toChecksumAddress(second);return first===second;}export var addressPattern='(0x)?[0-9a-fA-F]{40}';/**\n * Shorten an Ethereum address. `charsLength` allows to change the number of\n * characters on both sides of the ellipsis.\n *\n * Examples:\n *   shortenAddress('0x19731977931271')    // 0x1973…1271\n *   shortenAddress('0x19731977931271', 2) // 0x19…71\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\n *\n * @param {string} address The address to shorten\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\n * @returns {string} The shortened address\n */export function shortenAddress(address){var charsLength=arguments.length>1&&arguments[1]!==undefined?arguments[1]:4;var prefixLength=2;// \"0x\"\nif(!address){return'';}if(address.length<charsLength*2+prefixLength){return address;}return address.slice(0,charsLength+prefixLength)+'…'+address.slice(-charsLength);}export function getNetworkType(){var chainId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:env('CHAIN_ID');chainId=String(chainId);if(chainId==='1')return'main';if(chainId==='3')return'ropsten';if(chainId==='4')return'rinkeby';if(chainId==='43112')return'dijets';return DEFAULT_LOCAL_CHAIN;}export function getNetworkName(){var chainId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:env('CHAIN_ID');chainId=String(chainId);if(chainId==='1')return'Mainnet';if(chainId==='3')return'Ropsten';if(chainId==='4')return'Rinkeby';if(chainId==='43112')return'Dijets';return'unknown';}export function sanitizeNetworkType(networkType){if(networkType==='private'){return'dijets';}else if(networkType==='dijets'){return'dijets';}return networkType;}export function isLocalOrUnknownNetwork(){var chainId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:env('CHAIN_ID');return getNetworkType(chainId)===DEFAULT_LOCAL_CHAIN;}// Detect Ethereum addresses in a string and transform each part.\n//\n// `callback` is called on every part with two params:\n//   - The string of the current part.\n//   - A boolean indicating if it is an address.\n//\nexport function transformAddresses(str,callback){return str.split(ETH_ADDRESS_SPLIT_REGEX).map(function(part,index){return callback(part,ETH_ADDRESS_TEST_REGEX.test(part),index);});}/**\n * Check if the ETH node at the given URI is compatible for the current environment\n * @param {string} uri URI of the ETH node.\n * @param {string} expectedNetworkType The expected network type of the ETH node.\n * @returns {Promise} Resolves if the ETH node is compatible, otherwise throws:\n *    - InvalidURI: URI given is not compatible (e.g. must be WebSockets)\n *    - InvalidNetworkType: ETH node connected to wrong network\n *    - NoConnection: Couldn't connect to URI\n */export function checkValidEthNode(_x){return _checkValidEthNode.apply(this,arguments);}function _checkValidEthNode(){_checkValidEthNode=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(uri){var isLocalOrUnknown,expectedNetworkType,provider,networkType,networkTypeName;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:isLocalOrUnknown=isLocalOrUnknownNetwork(env('CHAIN_ID'));if(validHttpFormat(uri)){_context.next=3;break;}throw new InvalidURI('The URI must use the HTTP protocol');case 3:_context.prev=3;expectedNetworkType=getNetworkType();_context.next=7;return new Providers.JsonRpcProvider(uri);case 7:provider=_context.sent;_context.next=10;return provider.getNetwork();case 10:networkType=_context.sent;networkTypeName=networkType.name==='homestead'?'main':networkType.name;if(isLocalOrUnknown){_context.next=15;break;}if(!(networkTypeName!==expectedNetworkType)){_context.next=15;break;}throw new InvalidNetworkType();case 15:_context.next=22;break;case 17:_context.prev=17;_context.t0=_context[\"catch\"](3);if(!(_context.t0 instanceof InvalidNetworkType)){_context.next=21;break;}throw _context.t0;case 21:throw new NoConnection();case 22:return _context.abrupt(\"return\",true);case 23:case\"end\":return _context.stop();}}},_callee,null,[[3,17]]);}));return _checkValidEthNode.apply(this,arguments);}export function signMessage(_x2,_x3){return _signMessage.apply(this,arguments);}// ethers utils exports\nfunction _signMessage(){_signMessage=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(wallet,message){var signHash,error;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:error=false;_context2.prev=1;_context2.next=4;return wallet.ethers.getSigner().signMessage(message);case 4:signHash=_context2.sent;_context2.next=10;break;case 7:_context2.prev=7;_context2.t0=_context2[\"catch\"](1);error=_context2.t0;case 10:return _context2.abrupt(\"return\",{signHash:signHash,error:error});case 11:case\"end\":return _context2.stop();}}},_callee2,null,[[1,7]]);}));return _signMessage.apply(this,arguments);}export{keccak256,soliditySha3,toUtf8String};","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/lib/web3-utils.js"],"names":["env","providers","Providers","utils","InvalidURI","InvalidNetworkType","NoConnection","validHttpFormat","keccak256","id","soliditySha3","solidityKeccak256","toUtf8String","DEFAULT_LOCAL_CHAIN","ETH_FAKE_ADDRESS","padEnd","ETH_ADDRESS_SPLIT_REGEX","ETH_ADDRESS_TEST_REGEX","getFunctionSignature","func","slice","getUseWalletProviders","push","useWalletConf","apiKey","dAppId","getUseWalletConnectors","reduce","connectors","provider","toChecksumAddress","address","test","Error","toLowerCase","replace","addressHash","checksumAddress","i","length","parseInt","toUpperCase","addressesEqual","first","second","addressPattern","shortenAddress","charsLength","prefixLength","getNetworkType","chainId","String","getNetworkName","sanitizeNetworkType","networkType","isLocalOrUnknownNetwork","transformAddresses","str","callback","split","map","part","index","checkValidEthNode","uri","isLocalOrUnknown","expectedNetworkType","JsonRpcProvider","getNetwork","networkTypeName","name","signMessage","wallet","message","error","ethers","getSigner","signHash"],"mappings":"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","sourcesContent":["import env from '../environment'\nimport { providers as Providers, utils } from 'ethers'\nimport { InvalidURI, InvalidNetworkType, NoConnection } from '../errors'\nimport { validHttpFormat } from './uri-utils'\n\nconst { id: keccak256, solidityKeccak256: soliditySha3, toUtf8String } = utils\n\nexport const DEFAULT_LOCAL_CHAIN = 'private'\nexport const ETH_FAKE_ADDRESS = `0x${''.padEnd(40, '0')}`\n\nconst ETH_ADDRESS_SPLIT_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\nconst ETH_ADDRESS_TEST_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\n\nexport function getFunctionSignature(func) {\n  return keccak256(func).slice(0, 10)\n}\n\nexport function getUseWalletProviders() {\n  const providers = [{ id: 'injected' }]\n\n  if (env('FORTMATIC_API_KEY')) {\n    providers.push({\n      id: 'fortmatic',\n      useWalletConf: { apiKey: env('FORTMATIC_API_KEY') },\n    })\n  }\n\n  if (env('PORTIS_DAPP_ID')) {\n    providers.push({\n      id: 'portis',\n      useWalletConf: { dAppId: env('PORTIS_DAPP_ID') },\n    })\n  }\n\n  return providers\n}\n\nexport function getUseWalletConnectors() {\n  return getUseWalletProviders().reduce((connectors, provider) => {\n    if (provider.useWalletConf) {\n      connectors[provider.id] = provider.useWalletConf\n    }\n    return connectors\n  }, {})\n}\n\nfunction toChecksumAddress(address) {\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    throw new Error(\n      'Given address \"' + address + '\" is not a valid Ethereum address.'\n    )\n  }\n\n  address = address.toLowerCase().replace(/^0x/i, '')\n\n  const addressHash = keccak256(address).replace(/^0x/i, '')\n  let checksumAddress = '0x'\n\n  for (let i = 0; i < address.length; i++) {\n    // If ith character is 9 to f then make it uppercase\n    if (parseInt(addressHash[i], 16) > 7) {\n      checksumAddress += address[i].toUpperCase()\n    } else {\n      checksumAddress += address[i]\n    }\n  }\n\n  return checksumAddress\n}\n\n// Check address equality with checksums\nexport function addressesEqual(first, second) {\n  first = first && toChecksumAddress(first)\n  second = second && toChecksumAddress(second)\n  return first === second\n}\n\nexport const addressPattern = '(0x)?[0-9a-fA-F]{40}'\n\n/**\n * Shorten an Ethereum address. `charsLength` allows to change the number of\n * characters on both sides of the ellipsis.\n *\n * Examples:\n *   shortenAddress('0x19731977931271')    // 0x1973…1271\n *   shortenAddress('0x19731977931271', 2) // 0x19…71\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\n *\n * @param {string} address The address to shorten\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\n * @returns {string} The shortened address\n */\nexport function shortenAddress(address, charsLength = 4) {\n  const prefixLength = 2 // \"0x\"\n  if (!address) {\n    return ''\n  }\n  if (address.length < charsLength * 2 + prefixLength) {\n    return address\n  }\n  return (\n    address.slice(0, charsLength + prefixLength) +\n    '…' +\n    address.slice(-charsLength)\n  )\n}\n\nexport function getNetworkType(chainId = env('CHAIN_ID')) {\n  chainId = String(chainId)\n\n  if (chainId === '1') return 'main'\n  if (chainId === '3') return 'ropsten'\n  if (chainId === '4') return 'rinkeby'\n  if (chainId === '43112') return 'dijets'\n\n  return DEFAULT_LOCAL_CHAIN\n}\n\nexport function getNetworkName(chainId = env('CHAIN_ID')) {\n  chainId = String(chainId)\n\n  if (chainId === '1') return 'Mainnet'\n  if (chainId === '3') return 'Ropsten'\n  if (chainId === '4') return 'Rinkeby'\n  if (chainId === '43112') return 'Dijets'\n\n  return 'unknown'\n}\n\nexport function sanitizeNetworkType(networkType) {\n  if (networkType === 'private') {\n    return 'dijets'\n  } else if (networkType === 'dijets') {\n    return 'dijets'\n  }\n  return networkType\n}\n\nexport function isLocalOrUnknownNetwork(chainId = env('CHAIN_ID')) {\n  return getNetworkType(chainId) === DEFAULT_LOCAL_CHAIN\n}\n\n// Detect Ethereum addresses in a string and transform each part.\n//\n// `callback` is called on every part with two params:\n//   - The string of the current part.\n//   - A boolean indicating if it is an address.\n//\nexport function transformAddresses(str, callback) {\n  return str\n    .split(ETH_ADDRESS_SPLIT_REGEX)\n    .map((part, index) =>\n      callback(part, ETH_ADDRESS_TEST_REGEX.test(part), index)\n    )\n}\n\n/**\n * Check if the ETH node at the given URI is compatible for the current environment\n * @param {string} uri URI of the ETH node.\n * @param {string} expectedNetworkType The expected network type of the ETH node.\n * @returns {Promise} Resolves if the ETH node is compatible, otherwise throws:\n *    - InvalidURI: URI given is not compatible (e.g. must be WebSockets)\n *    - InvalidNetworkType: ETH node connected to wrong network\n *    - NoConnection: Couldn't connect to URI\n */\nexport async function checkValidEthNode(uri) {\n  const isLocalOrUnknown = isLocalOrUnknownNetwork(env('CHAIN_ID'))\n\n  if (!validHttpFormat(uri)) {\n    throw new InvalidURI('The URI must use the HTTP protocol')\n  }\n\n  try {\n    const expectedNetworkType = getNetworkType()\n    const provider = await new Providers.JsonRpcProvider(uri)\n    const networkType = await provider.getNetwork()\n    const networkTypeName =\n      networkType.name === 'homestead' ? 'main' : networkType.name\n\n    if (!isLocalOrUnknown) {\n      if (networkTypeName !== expectedNetworkType) {\n        throw new InvalidNetworkType()\n      }\n    }\n  } catch (err) {\n    if (err instanceof InvalidNetworkType) {\n      throw err\n    }\n    throw new NoConnection()\n  }\n\n  return true\n}\n\nexport async function signMessage(wallet, message) {\n  let signHash\n  let error = false\n\n  try {\n    signHash = await wallet.ethers.getSigner().signMessage(message)\n  } catch (err) {\n    error = err\n  }\n\n  return { signHash, error }\n}\n\n// ethers utils exports\nexport { keccak256, soliditySha3, toUtf8String }\n"]},"metadata":{},"sourceType":"module"}