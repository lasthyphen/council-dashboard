{"ast":null,"code":"import * as radspec from 'radspec';\nimport { addressesEqual } from '../address';\nimport { findAppMethodFromIntent } from '../app';\n/**\n * Attempt to describe intent via radspec.\n */\n\nexport async function tryEvaluatingRadspec(intent, apps, provider // Decorated intent with description, if one could be made\n) {\n  const app = apps.find(app => addressesEqual(app.address, intent.to)); // If the intent matches an installed app, use only that app to search for a\n  // method match, otherwise fallback to searching all installed apps\n\n  const appsToSearch = app ? [app] : apps;\n  const foundMethod = appsToSearch.reduce((found, app) => {\n    if (found) {\n      return found;\n    }\n\n    const method = findAppMethodFromIntent(app, intent);\n\n    if (method) {\n      return {\n        method,\n        // This is not very nice, but some apps don't have ABIs attached to their function\n        // declarations and so we have to fall back to using their full app ABI\n        // TODO: define a more concrete schema around the artifact.json's `function.abi`\n        abi: method.abi ? [method.abi] : app.abi\n      };\n    }\n  }, undefined);\n  const {\n    abi,\n    method\n  } = foundMethod || {};\n  let evaluatedNotice;\n\n  if (method && method.notice) {\n    try {\n      evaluatedNotice = await radspec.evaluate(method.notice, {\n        abi,\n        transaction: intent\n      }, {\n        provider: provider\n      });\n    } catch (err) {\n      console.error(`Could not evaluate a description for given transaction data: ${intent.data}`, err);\n    }\n  }\n\n  return evaluatedNotice;\n}\nexport { postprocessRadspecDescription } from './postprocess';","map":null,"metadata":{},"sourceType":"module"}