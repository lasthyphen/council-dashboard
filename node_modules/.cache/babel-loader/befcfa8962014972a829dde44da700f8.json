{"ast":null,"code":"import { _ as _extends, C as CombinedError, a as addMetadata, f as formatDocument, c as collectTypesFromResponse, m as makeResult, b as makeErrorResult, t as toSuspenseSource, w as withPromise, d as createRequest } from \"./index-9bb95fa6.js\";\nexport { C as CombinedError, d as createRequest, f as formatDocument, b as makeErrorResult, m as makeResult, s as stringifyVariables } from \"./index-9bb95fa6.js\";\nimport { share, filter, map, tap, merge, mergeMap, takeUntil, make, switchMap, fromValue, interval, makeSubject, publish, take, onStart, onEnd } from \"wonka\";\nimport { print, Kind } from \"graphql\";\n\nvar shouldSkip = function (ref) {\n  var operationName = ref.operationName;\n  return \"subscription\" !== operationName && \"query\" !== operationName;\n};\n\nfunction _ref(x) {\n  return \"\" + x;\n}\n\nvar ssrExchange = function (params) {\n  var data = {};\n\n  var isCached = function (operation) {\n    return !shouldSkip(operation) && void 0 !== data[operation.key];\n  };\n\n  function _ref2(op) {\n    return !isCached(op);\n  }\n\n  function _ref3(op) {\n    return function (operation, result) {\n      var error = result.error;\n      var deserialized = {\n        operation: operation,\n        data: result.data,\n        extensions: void 0,\n        error: void 0\n      };\n\n      if (void 0 !== error) {\n        deserialized.error = new CombinedError({\n          networkError: new Error(error.networkError),\n          graphQLErrors: error.graphQLErrors\n        });\n      }\n\n      return deserialized;\n    }(op, data[op.key]);\n  }\n\n  function _ref4(op) {\n    return isCached(op);\n  }\n\n  function _ref5(result) {\n    var operation = result.operation;\n\n    if (!shouldSkip(operation)) {\n      var serialized = function (ref) {\n        var error = ref.error;\n        var result = {\n          data: ref.data,\n          error: void 0\n        };\n\n        if (void 0 !== error) {\n          result.error = {\n            networkError: \"\" + error.networkError,\n            graphQLErrors: error.graphQLErrors.map(_ref)\n          };\n        }\n\n        return result;\n      }(result);\n\n      data[operation.key] = serialized;\n    }\n  }\n\n  function _ref6(result) {\n    delete data[result.operation.key];\n  }\n\n  var ssr = function (ref) {\n    var client = ref.client;\n    var forward = ref.forward;\n    return function (ops$) {\n      var isClient = params && \"boolean\" == typeof params.isClient ? !!params.isClient : !client.suspense;\n      var sharedOps$ = share(ops$);\n      var forwardedOps$ = forward(filter(_ref2)(sharedOps$));\n      var cachedOps$ = map(_ref3)(filter(_ref4)(sharedOps$));\n\n      if (!isClient) {\n        forwardedOps$ = tap(_ref5)(forwardedOps$);\n      } else {\n        cachedOps$ = tap(_ref6)(cachedOps$);\n      }\n\n      return merge([forwardedOps$, cachedOps$]);\n    };\n  };\n\n  ssr.restoreData = function (restore) {\n    return _extends(data, restore);\n  };\n\n  ssr.extractData = function () {\n    return _extends({}, data);\n  };\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n\nvar shouldSkip$1 = function (ref) {\n  var operationName = ref.operationName;\n  return \"mutation\" !== operationName && \"query\" !== operationName;\n};\n\nfunction _ref$1(operation) {\n  return _extends(_extends({}, operation), {\n    query: formatDocument(operation.query)\n  });\n}\n\nfunction _ref5(op) {\n  return addMetadata(op, {\n    cacheOutcome: \"miss\"\n  });\n}\n\nfunction _ref7(op) {\n  return shouldSkip$1(op);\n}\n\nvar cacheExchange = function (ref) {\n  var forward = ref.forward;\n  var client = ref.client;\n  var resultCache = new Map();\n  var operationCache = Object.create(null);\n  var mapTypeNames = _ref$1;\n  var handleAfterMutation = afterMutation(resultCache, operationCache, client);\n  var handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  var isOperationCached = function (operation) {\n    var requestPolicy = operation.context.requestPolicy;\n    return \"query\" === operation.operationName && \"network-only\" !== requestPolicy && (\"cache-only\" === requestPolicy || resultCache.has(operation.key));\n  };\n\n  function _ref2(operation) {\n    var cachedResult = resultCache.get(operation.key);\n\n    var result = _extends(_extends({}, cachedResult), {\n      operation: addMetadata(operation, {\n        cacheOutcome: cachedResult ? \"hit\" : \"miss\"\n      })\n    });\n\n    if (\"cache-and-network\" === operation.context.requestPolicy) {\n      result.stale = !0;\n      reexecuteOperation(client, operation);\n    }\n\n    return result;\n  }\n\n  function _ref3(op) {\n    return !shouldSkip$1(op) && isOperationCached(op);\n  }\n\n  function _ref4(response) {\n    if (response.operation && \"mutation\" === response.operation.operationName) {\n      handleAfterMutation(response);\n    } else if (response.operation && \"query\" === response.operation.operationName) {\n      handleAfterQuery(response);\n    }\n  }\n\n  function _ref6(op) {\n    return !shouldSkip$1(op) && !isOperationCached(op);\n  }\n\n  return function (ops$) {\n    var sharedOps$ = share(ops$);\n    var cachedOps$ = map(_ref2)(filter(_ref3)(sharedOps$));\n    var forwardedOps$ = tap(_ref4)(forward(map(_ref5)(merge([map(mapTypeNames)(filter(_ref6)(sharedOps$)), filter(_ref7)(sharedOps$)]))));\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\nvar reexecuteOperation = function (client, operation) {\n  return client.reexecuteOperation(_extends(_extends({}, operation), {\n    context: _extends(_extends({}, operation.context), {\n      requestPolicy: \"network-only\"\n    })\n  }));\n};\n\nvar afterMutation = function (resultCache, operationCache, client) {\n  function _ref9(key) {\n    if (resultCache.has(key)) {\n      var operation = resultCache.get(key).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  }\n\n  return function (response) {\n    var pendingOperations = new Set();\n\n    function _ref8(key) {\n      pendingOperations.add(key);\n    }\n\n    collectTypesFromResponse(response.data).forEach(function (typeName) {\n      var operations = operationCache[typeName] || (operationCache[typeName] = new Set());\n      operations.forEach(_ref8);\n      operations.clear();\n    });\n    pendingOperations.forEach(_ref9);\n  };\n};\n\nvar afterQuery = function (resultCache, operationCache) {\n  return function (response) {\n    var operation = response.operation;\n    var data = response.data;\n\n    if (null == data) {\n      return;\n    }\n\n    resultCache.set(operation.key, {\n      operation: operation,\n      data: data,\n      error: response.error\n    });\n    collectTypesFromResponse(response.data).forEach(function (typeName) {\n      (operationCache[typeName] || (operationCache[typeName] = new Set())).add(operation.key);\n    });\n  };\n};\n\nvar isSubscriptionOperation = function (operation) {\n  return \"subscription\" === operation.operationName;\n};\n\nfunction _ref$2(op) {\n  return !isSubscriptionOperation(op);\n}\n\nvar subscriptionExchange = function (ref) {\n  var forwardSubscription = ref.forwardSubscription;\n  return function (ref) {\n    var client = ref.client;\n    var forward = ref.forward;\n    return function (ops$) {\n      var sharedOps$ = share(ops$);\n      var subscriptionResults$ = mergeMap(function (operation) {\n        var key = operation.key;\n        var teardown$ = filter(function (op) {\n          return \"teardown\" === op.operationName && op.key === key;\n        })(sharedOps$);\n        return takeUntil(teardown$)(function (operation) {\n          var observableish = forwardSubscription({\n            key: operation.key.toString(36),\n            query: print(operation.query),\n            variables: operation.variables,\n            context: _extends({}, operation.context)\n          });\n          return make(function (ref) {\n            var next = ref.next;\n            var complete = ref.complete;\n            var isComplete = !1;\n            var sub = observableish.subscribe({\n              next: function (result) {\n                return next(makeResult(operation, result));\n              },\n              error: function (err) {\n                return next(makeErrorResult(operation, err));\n              },\n              complete: function () {\n                if (!isComplete) {\n                  client.reexecuteOperation(_extends(_extends({}, operation), {\n                    operationName: \"teardown\"\n                  }));\n                }\n\n                complete();\n              }\n            });\n            return function () {\n              isComplete = !0;\n              sub.unsubscribe();\n            };\n          });\n        }(operation));\n      })(filter(isSubscriptionOperation)(sharedOps$));\n      var forward$ = forward(filter(_ref$2)(sharedOps$));\n      return merge([subscriptionResults$, forward$]);\n    };\n  };\n};\n\nfunction _ref2(result) {\n  return console.log(\"[Exchange debug]: Completed operation: \", result);\n}\n\nfunction _ref3(op) {\n  return console.log(\"[Exchange debug]: Incoming operation: \", op);\n}\n\nvar debugExchange = function (ref) {\n  var forward = ref.forward;\n\n  if (\"production\" === process.env.NODE_ENV) {\n    return function _ref(ops$) {\n      return forward(ops$);\n    };\n  } else {\n    return function _ref4(ops$) {\n      return tap(_ref2)(forward(tap(_ref3)(ops$)));\n    };\n  }\n};\n\nvar dedupExchange = function (ref) {\n  var forward = ref.forward;\n  var inFlightKeys = new Set();\n\n  var filterIncomingOperation = function (operation) {\n    var key = operation.key;\n    var operationName = operation.operationName;\n\n    if (\"teardown\" === operationName) {\n      inFlightKeys.delete(key);\n      return !0;\n    } else if (\"query\" !== operationName && \"subscription\" !== operationName) {\n      return !0;\n    }\n\n    var isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  var afterOperationResult = function (ref) {\n    inFlightKeys.delete(ref.operation.key);\n  };\n\n  return function (ops$) {\n    var forward$ = filter(filterIncomingOperation)(ops$);\n    return tap(afterOperationResult)(forward(forward$));\n  };\n};\n\nfunction _ref$3(operation) {\n  var operationName = operation.operationName;\n  return \"query\" === operationName || \"mutation\" === operationName;\n}\n\nvar fetchExchange = function (ref) {\n  var forward = ref.forward;\n  var isOperationFetchable = _ref$3;\n\n  function _ref2(op) {\n    return !isOperationFetchable(op);\n  }\n\n  return function (ops$) {\n    var sharedOps$ = share(ops$);\n    var fetchResults$ = mergeMap(function (operation) {\n      var key = operation.key;\n      var teardown$ = filter(function (op) {\n        return \"teardown\" === op.operationName && op.key === key;\n      })(sharedOps$);\n      return takeUntil(teardown$)(createFetchSource(operation));\n    })(filter(isOperationFetchable)(sharedOps$));\n    var forward$ = forward(filter(_ref2)(sharedOps$));\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nfunction _ref3$1(node) {\n  return node.kind === Kind.OPERATION_DEFINITION && node.name;\n}\n\nvar createFetchSource = function (operation) {\n  if (\"production\" !== process.env.NODE_ENV && \"subscription\" === operation.operationName) {\n    throw new Error(\"Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?\");\n  }\n\n  return make(function (ref) {\n    var next = ref.next;\n    var complete = ref.complete;\n    var abortController = \"undefined\" != typeof AbortController ? new AbortController() : void 0;\n    var context = operation.context;\n    var extraOptions = \"function\" == typeof context.fetchOptions ? context.fetchOptions() : context.fetchOptions || {};\n    var operationName = void 0 !== (node = operation.query.definitions.find(_ref3$1)) && node.name ? node.name.value : null;\n    var node;\n    var body = {\n      query: print(operation.query),\n      variables: operation.variables\n    };\n\n    if (null !== operationName) {\n      body.operationName = operationName;\n    }\n\n    var fetchOptions = _extends(_extends({\n      body: JSON.stringify(body),\n      method: \"POST\"\n    }, extraOptions), {\n      headers: _extends({\n        \"content-type\": \"application/json\"\n      }, extraOptions.headers),\n      signal: void 0 !== abortController ? abortController.signal : void 0\n    });\n\n    executeFetch(operation, fetchOptions).then(function (result) {\n      if (void 0 !== result) {\n        next(result);\n      }\n\n      complete();\n    });\n    return function () {\n      if (void 0 !== abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nvar executeFetch = function (operation, opts) {\n  var ref = operation.context;\n  var response;\n  return (ref.fetch || fetch)(ref.url, opts).then(function (res) {\n    var status = res.status;\n    response = res;\n\n    if (status < 200 || status >= (\"manual\" === opts.redirect ? 400 : 300)) {\n      throw new Error(res.statusText);\n    } else {\n      return res.json();\n    }\n  }).then(function (result) {\n    return makeResult(operation, result, response);\n  }).catch(function (err) {\n    if (\"AbortError\" !== err.name) {\n      return makeErrorResult(operation, err, response);\n    }\n  });\n};\n\nfunction _ref$4() {\n  return !1;\n}\n\nfunction _ref2$1(ref) {\n  var operationName = ref.operationName;\n\n  if (\"teardown\" !== operationName && \"production\" !== process.env.NODE_ENV) {\n    console.warn('No exchange has handled operations of type \"' + operationName + \"\\\". Check whether you've added an exchange responsible for these operations.\");\n  }\n}\n\nvar fallbackExchangeIO = function (ops$) {\n  return filter(_ref$4)(tap(_ref2$1)(ops$));\n};\n\nvar composeExchanges = function (exchanges) {\n  if (1 === exchanges.length) {\n    return exchanges[0];\n  }\n\n  return function (payload) {\n    return exchanges.reduceRight(function (forward, exchange) {\n      return exchange({\n        client: payload.client,\n        forward: forward\n      });\n    }, payload.forward);\n  };\n};\n\nvar defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n\nvar createClient = function (opts) {\n  return new Client(opts);\n};\n\nvar Client = function Client(opts) {\n  var this$1 = this;\n  this.activeOperations = Object.create(null);\n\n  this.createOperationContext = function (opts) {\n    return _extends(_extends({\n      url: this$1.url,\n      fetchOptions: this$1.fetchOptions,\n      fetch: this$1.fetch\n    }, opts), {\n      requestPolicy: (opts || {}).requestPolicy || this$1.requestPolicy\n    });\n  };\n\n  this.createRequestOperation = function (type, request, opts) {\n    return {\n      key: request.key,\n      query: request.query,\n      variables: request.variables,\n      operationName: type,\n      context: this$1.createOperationContext(opts)\n    };\n  };\n\n  this.reexecuteOperation = function (operation) {\n    if ((this$1.activeOperations[operation.key] || 0) > 0) {\n      this$1.dispatchOperation(operation);\n    }\n  };\n\n  this.executeQuery = function (query, opts) {\n    var operation = this$1.createRequestOperation(\"query\", query, opts);\n    var response$ = this$1.executeRequestOperation(operation);\n    var pollInterval = operation.context.pollInterval;\n\n    if (pollInterval) {\n      return switchMap(function _ref() {\n        return response$;\n      })(merge([fromValue(0), interval(pollInterval)]));\n    }\n\n    return response$;\n  };\n\n  this.executeSubscription = function (query, opts) {\n    var operation = this$1.createRequestOperation(\"subscription\", query, opts);\n    return this$1.executeRequestOperation(operation);\n  };\n\n  this.executeMutation = function (query, opts) {\n    var operation = this$1.createRequestOperation(\"mutation\", query, opts);\n    return this$1.executeRequestOperation(operation);\n  };\n\n  this.url = opts.url;\n  this.fetchOptions = opts.fetchOptions;\n  this.fetch = opts.fetch;\n  this.suspense = !!opts.suspense;\n  this.requestPolicy = opts.requestPolicy || \"cache-first\";\n  var ref = makeSubject();\n  var nextOperation = ref.next;\n  this.operations$ = ref.source;\n  var queuedOperations = [];\n  var isDispatching = !1;\n\n  this.dispatchOperation = function (operation) {\n    queuedOperations.push(operation);\n\n    if (!isDispatching) {\n      isDispatching = !0;\n      var queued;\n\n      while (void 0 !== (queued = queuedOperations.shift())) {\n        nextOperation(queued);\n      }\n\n      isDispatching = !1;\n    }\n  };\n\n  this.exchange = composeExchanges(void 0 !== opts.exchanges ? opts.exchanges : defaultExchanges);\n  this.results$ = share(this.exchange({\n    client: this,\n    forward: fallbackExchangeIO\n  })(this.operations$));\n  publish(this.results$);\n};\n\nClient.prototype.onOperationStart = function onOperationStart(operation) {\n  var key = operation.key;\n  this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n  this.dispatchOperation(operation);\n};\n\nClient.prototype.onOperationEnd = function onOperationEnd(operation) {\n  var key = operation.key;\n  var prevActive = this.activeOperations[key] || 0;\n\n  if ((this.activeOperations[key] = prevActive <= 0 ? 0 : prevActive - 1) <= 0) {\n    this.dispatchOperation(_extends(_extends({}, operation), {\n      operationName: \"teardown\"\n    }));\n  }\n};\n\nClient.prototype.executeRequestOperation = function executeRequestOperation(operation) {\n  var this$1 = this;\n  var key = operation.key;\n  var operationName = operation.operationName;\n  var operationResults$ = filter(function (res) {\n    return res.operation.key === key;\n  })(this.results$);\n\n  if (\"mutation\" === operationName) {\n    return take(1)(onStart(function _ref2() {\n      return this$1.dispatchOperation(operation);\n    })(operationResults$));\n  }\n\n  var teardown$ = filter(function (op) {\n    return \"teardown\" === op.operationName && op.key === key;\n  })(this.operations$);\n  var result$ = onEnd(function () {\n    this$1.onOperationEnd(operation);\n  })(onStart(function () {\n    this$1.onOperationStart(operation);\n  })(takeUntil(teardown$)(operationResults$)));\n  return !1 !== operation.context.suspense && this.suspense && \"query\" === operationName ? toSuspenseSource(result$) : result$;\n};\n\nClient.prototype.query = function query(query$1, variables, context) {\n  if (!context || \"boolean\" != typeof context.suspense) {\n    context = _extends(_extends({}, context), {\n      suspense: !1\n    });\n  }\n\n  return withPromise(this.executeQuery(createRequest(query$1, variables), context));\n};\n\nClient.prototype.mutation = function mutation(query, variables, context) {\n  return withPromise(this.executeMutation(createRequest(query, variables), context));\n};\n\nexport { Client, cacheExchange, composeExchanges, createClient, debugExchange, dedupExchange, defaultExchanges, fallbackExchangeIO, fetchExchange, ssrExchange, subscriptionExchange };","map":null,"metadata":{},"sourceType":"module"}