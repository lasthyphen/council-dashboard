{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.parse = parse, exports.Parser = void 0;\n/**\n* @module radspec/parser\n*/\n\n/**\n* A token.\n* @typedef {Object} Token\n* @property {string} type The token type\n* @property {*?} value The value of the token\n*/\n\n/**\n* An AST node.\n* @typedef {Object} Node\n* @property {string} type The node type\n*/\n\n/**\n* An AST.\n* @typedef {Object} AST\n* @property {string} type\n* @property {Array<Node>} body The AST nodes\n*/\n\n/**\n* Enum for parser state.\n*\n* @readonly\n* @enum {string}\n*/\n\nconst PARSER_STATE = {\n  OK: \"OK\",\n  ERROR: \"ERROR\"\n};\n/**\n* Parses a token list into an AST.\n*\n* @class Parser\n* @param {Array<Token>} tokens\n* @property {string} state The state of the parser (`OK` or `ERROR`)\n* @property {Array<Token>} tokens\n* @property {number} cursor\n*/\n\nclass Parser {\n  constructor(tokens) {\n    this.state = PARSER_STATE.OK, this.tokens = tokens, this.cursor = 0;\n  }\n  /**\n  * Get the current token and increase the cursor by 1\n  *\n  * @return {Token}\n  */\n\n\n  consume() {\n    return this.cursor++, this.tokens[this.cursor - 1];\n  }\n  /**\n  * Get the previous token.\n  *\n  * @return {Token}\n  */\n\n\n  previous() {\n    return this.tokens[this.cursor - 1];\n  }\n  /**\n  * Get the token under the cursor without consuming it.\n  *\n  * @return {Token}\n  */\n\n\n  peek() {\n    return this.tokens[this.cursor];\n  }\n  /**\n  * Checks if the type of the next token matches any of the expected types.\n  *\n  * Increases the cursor by 1 if the token matches.\n  *\n  * @param {...string} expected The expected types\n  * @return {boolean} True if the next token matches, otherwise false\n  */\n\n\n  matches(...expected) {\n    if (this.eof()) return !1;\n\n    for (let type of expected) if (this.peek().type === type) return this.cursor++, !0;\n\n    return !1;\n  }\n  /**\n  * Try to parse comparison operators.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  comparison(astBody) {\n    let node = this.addition(astBody);\n\n    for (; this.matches(\"GREATER\", \"GREATER_EQUAL\", \"LESS\", \"LESS_EQUAL\", \"EQUAL_EQUAL\", \"BANG_EQUAL\");) {\n      let operator = this.previous().type,\n          right = this.addition(astBody);\n      node = {\n        type: \"ComparisonExpression\",\n        operator,\n        left: node,\n        right\n      };\n    }\n\n    return this.matches(\"QUESTION_MARK\") && (node = {\n      type: \"TernaryExpression\",\n      predicate: node,\n      left: this.comparison(astBody)\n    }, !this.matches(\"COLON\") && this.report(\"Half-baked ternary (expected colon)\"), node.right = this.comparison(astBody)), this.matches(\"DOUBLE_VERTICAL_BAR\") && (node = {\n      left: node,\n      right: this.comparison(),\n      type: \"DefaultExpression\"\n    }), node;\n  }\n  /**\n  * Try to parse arithmetic operators.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  addition(astBody) {\n    let node = this.multiplication(astBody);\n\n    for (; this.matches(\"MINUS\", \"PLUS\");) {\n      let operator = this.previous().type,\n          right = this.multiplication(astBody);\n      node = {\n        type: \"BinaryExpression\",\n        operator,\n        left: node,\n        right\n      };\n    }\n\n    return node;\n  }\n  /**\n  * Try to parse binary operators.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  multiplication(astBody) {\n    let node = this.power(astBody);\n\n    for (; this.matches(\"SLASH\", \"STAR\", \"MODULO\");) {\n      let operator = this.previous().type,\n          right = this.power(astBody);\n      node = {\n        type: \"BinaryExpression\",\n        operator,\n        left: node,\n        right\n      };\n    }\n\n    return node;\n  }\n  /**\n  * Try to parse exponential operators.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  power(astBody) {\n    let node = this.unary(astBody);\n\n    for (; this.matches(\"POWER\");) {\n      let operator = this.previous().type,\n          right = this.unary(astBody);\n      node = {\n        type: \"BinaryExpression\",\n        operator,\n        left: node,\n        right\n      };\n    }\n\n    return node;\n  }\n  /**\n  * Try to parse unary operators.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  unary(astBody) {\n    if (this.matches(\"BANG\", \"MINUS\")) {\n      let operator = this.previous().type,\n          right = this.unary(astBody);\n      return {\n        type: \"UnaryExpression\",\n        operator,\n        right: right\n      };\n    }\n\n    return this.identifier(astBody);\n  }\n  /**\n  * Try to parse identifiers and call expressions.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  identifier(astBody) {\n    let node;\n\n    if (this.matches(\"IDENTIFIER\") && (node = {\n      type: \"Identifier\",\n      value: this.previous().value\n    }), !node) {\n      const previousNode = astBody.length && astBody[astBody.length - 1];\n      previousNode && (\"Identifier\" === previousNode.type || \"GroupedExpression\" === previousNode.type || \"CallExpression\" === previousNode.type) && (node = previousNode, astBody.pop());\n    }\n\n    if (node) {\n      for (; this.matches(\"DOT\");) {\n        let property = this.consume().value;\n        node = {\n          type: \"PropertyAccessExpression\",\n          target: node,\n          property\n        };\n      }\n\n      return this.matches(\"LEFT_PAREN\") && (node = {\n        type: \"CallExpression\",\n        target: node.target,\n        callee: node.property,\n        inputs: this.functionInputs(astBody),\n        outputs: []\n      }, this.eof() && this.report(\"Unterminated call expression\"), node.outputs = this.typeList()), node;\n    }\n\n    return this.helper(astBody);\n  }\n  /**\n  * Try to parse helper functions\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  helper(astBody) {\n    if (this.matches(\"AT\")) {\n      const identifier = this.consume(),\n            name = identifier.value;\n      \"IDENTIFIER\" !== identifier.type && this.report(`Invalid helper function name '${name}' provided after @`);\n      const node = {\n        type: \"HelperFunction\",\n        name: name\n      };\n      return this.matches(\"LEFT_PAREN\") ? node.inputs = this.functionInputs(astBody) : this.report(`Expected '(' for executing helper function`), node;\n    }\n\n    return this.primary(astBody);\n  }\n  /**\n  * Try to parse primaries (literals).\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  primary() {\n    if (this.matches(\"NUMBER\", \"STRING\", \"HEXADECIMAL\", \"BOOLEAN\")) {\n      let type = {\n        NUMBER: \"NumberLiteral\",\n        STRING: \"StringLiteral\",\n        HEXADECIMAL: \"BytesLiteral\",\n        BOOLEAN: \"BoolLiteral\"\n      }[this.previous().type];\n      return {\n        type,\n        value: this.previous().value\n      };\n    }\n\n    if (this.matches(\"LEFT_PAREN\")) {\n      let expression;\n\n      do // Keep munching expressions in the context of the current expression\n      expression = this.comparison(expression ? [expression] : []); while (!this.eof() && !this.matches(\"RIGHT_PAREN\"));\n\n      return this.eof() && this.report(\"Unterminated grouping\"), {\n        type: \"GroupedExpression\",\n        body: expression\n      };\n    }\n\n    this.report(`Unknown token \"${this.consume().type}\"`);\n  }\n  /**\n  * Try to parse a type.\n  *\n  * @return {string} The type\n  */\n\n\n  type() {\n    return this.matches(\"COLON\") || \"TYPE\" === this.peek().type || this.report(`Expected a type, got \"${this.peek().type}\"`), this.consume().value;\n  }\n  /**\n  * Try to parse a type list.\n  *\n  * @return {Array<string>} The list of types\n  */\n\n\n  typeList() {\n    // We just have a single type\n    if (this.matches(\"COLON\") || \"TYPE\" === this.peek().type && \"LEFT_PAREN\" === this.peek().type || this.report(`Expected a type or a list of types, got \"${this.peek().type}\"`), !this.matches(\"LEFT_PAREN\")) return [{\n      type: this.consume().value,\n      selected: !0\n    }];\n    let typeList = [];\n\n    for (; !this.eof() && !this.matches(\"RIGHT_PAREN\");) {\n      // Check if the type is preceded by a < to denote\n      // that this is the type of the return value we want.\n      let selected = this.matches(\"LESS\");\n      \"TYPE\" === !this.peek().type && this.report(`Unexpected identifier in type list, expected type, got \"${this.peek().type}\"`), typeList.push({\n        type: this.consume().value,\n        selected\n      }), selected && !this.matches(\"GREATER\") && this.report(`Unclosed selected type`), this.matches(\"COMMA\") || \"RIGHT_PAREN\" === this.peek().type || this.report(\"Undelimited parameter type (expected comma delimiter or closing brace)\");\n    }\n\n    this.eof() && this.report(`Unclosed type list`); // Verify that at least one type in the type list has been selected\n    // as the type of the return value.\n    //\n    // If no type has been selected, and the number of types in the type\n    // list is exactly 1, then we assume that that type should be\n    // marked as selected.\n\n    const hasSelectedTypeInList = !!typeList.find(item => item.selected);\n    return hasSelectedTypeInList || 1 !== typeList.length ? !hasSelectedTypeInList && this.report(`Type list has no selected type`) : typeList[0].selected = !0, typeList;\n  }\n  /**\n  * Try to parse function arguments.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Array<Node>}\n  */\n\n\n  functionInputs(astBody) {\n    const inputs = [];\n\n    for (; !this.eof() && !this.matches(\"RIGHT_PAREN\");) {\n      const input = this.comparison(astBody);\n      input.type ? this.matches(\"COLON\") && this.report(`Unexpected type (already inferred type of parameter)`) : input.type = this.type(), inputs.push(input), this.matches(\"COMMA\") || \"RIGHT_PAREN\" === this.peek().type || this.report(\"Undelimited parameter type (expected comma delimiter or closing brace)\");\n    }\n\n    return inputs;\n  }\n  /**\n  * Walk all possible paths and try to parse a single node\n  * from the list of tokens.\n  *\n  * @param  {Array<Node>} astBody Subtree of AST being walked\n  * @return {Node}\n  */\n\n\n  walk(astBody) {\n    let token = this.peek();\n    if (\"MONOLOGUE\" === token.type) return {\n      type: \"MonologueStatement\",\n      value: this.consume().value\n    };\n\n    if (\"TICK\" === token.type) {\n      let node = {\n        type: \"ExpressionStatement\",\n        body: []\n      };\n\n      for (this.matches(\"TICK\"); !this.eof() && \"TICK\" !== this.peek().type;) node.body.push(this.walk(node.body));\n\n      return this.eof() && this.report(\"Unterminated expression\"), this.matches(\"TICK\"), node;\n    }\n\n    return this.comparison(astBody);\n  }\n  /**\n  * Walks the token list and returns an AST.\n  *\n  * @return {AST} The AST\n  */\n\n\n  async parse() {\n    let ast = {\n      type: \"Program\",\n      body: []\n    };\n\n    for (; !this.eof();) ast.body.push(this.walk(ast.body));\n\n    return this.state === PARSER_STATE.ERROR ? (console.error(`Errors encountered while parsing source`), ast) : ast;\n  }\n  /**\n  * Returns true if we've reached the end of the token list, otherwise false.\n  *\n  * @return {boolean}\n  */\n\n\n  eof() {\n    return this.cursor >= this.tokens.length;\n  }\n  /**\n  * Prints an error with location information to `stderr`\n  * and sets the parser state to `PARSER_STATE.ERROR`\n  *\n  * @param {string} error\n  * @return {void}\n  */\n\n\n  report(error) {\n    this.state = PARSER_STATE.ERROR, console.error(`Error (${this.cursor}): ${error}`);\n  }\n\n}\n/**\n* Walks token list and returns an AST.\n*\n* @memberof radspec/parser\n* @param  {Array<Token>} tokens\n* @return {AST} The AST\n*/\n\n\nexports.Parser = Parser;\n\nfunction parse(tokens) {\n  return new Parser(tokens).parse();\n}","map":null,"metadata":{},"sourceType":"script"}