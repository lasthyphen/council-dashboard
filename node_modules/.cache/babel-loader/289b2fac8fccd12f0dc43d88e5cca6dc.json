{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _types = _interopRequireDefault(require(\"../types\"));\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.scan = scan, exports.Scanner = void 0;\n/**\n* @module radspec/scanner\n*/\n\n/**\n* Enum for scanner state.\n*\n* @readonly\n* @enum {string}\n*/\n\nconst SCANNER_STATE = {\n  OK: \"OK\",\n  ERROR: \"ERROR\"\n};\n/**\n* A scanner that identifies tokens in a source string.\n*\n* @class Scanner\n* @param {string} source The source code\n* @property {string} state The state of the parser (`OK` or `ERROR`)\n* @property {string} source The source code\n* @property {number} cursor\n* @property {Array<Token>} tokens The currently identified tokens\n*/\n\nclass Scanner {\n  constructor(source) {\n    this.state = SCANNER_STATE.OK, this.isInExpression = !1, this.source = source, this.cursor = 0, this.tokens = [];\n  }\n  /**\n  * Scans a single token from source and pushes it to `Scanner.tokens`.\n  *\n  * @return {void}\n  */\n\n\n  scanToken() {\n    const current = this.consume();\n    if (\"`\" === current) return this.isInExpression = !this.isInExpression, void this.emitToken(\"TICK\"); // We haven't hit a tick yet, so we're not in an expression\n\n    if (!this.isInExpression) {\n      // Scan until tick\n      let monologue = current;\n\n      for (; \"`\" !== this.peek() && !this.eof();) monologue += this.consume();\n\n      return void this.emitToken(\"MONOLOGUE\", monologue);\n    }\n\n    switch (current) {\n      // Single character tokens\n      case \"(\":\n        this.emitToken(\"LEFT_PAREN\");\n        break;\n\n      case \")\":\n        this.emitToken(\"RIGHT_PAREN\");\n        break;\n\n      case \",\":\n        this.emitToken(\"COMMA\");\n        break;\n\n      case \".\":\n        this.emitToken(\"DOT\");\n        break;\n\n      case \":\":\n        this.emitToken(\"COLON\");\n        break;\n\n      case \"-\":\n        this.emitToken(\"MINUS\");\n        break;\n\n      case \"+\":\n        this.emitToken(\"PLUS\");\n        break;\n\n      case \"^\":\n        this.emitToken(\"POWER\");\n        break;\n\n      case \"*\":\n        this.emitToken(\"STAR\");\n        break;\n\n      case \"/\":\n        this.emitToken(\"SLASH\");\n        break;\n\n      case \"%\":\n        this.emitToken(\"MODULO\");\n        break;\n\n      case \"?\":\n        this.emitToken(\"QUESTION_MARK\");\n        break;\n\n      case \"@\":\n        this.emitToken(\"AT\");\n        break;\n      // One or two character tokens\n\n      case \"!\":\n        this.emitToken(this.matches(\"=\") ? \"BANG_EQUAL\" : \"BANG\");\n        break;\n\n      case \"=\":\n        this.emitToken(this.matches(\"=\") ? \"EQUAL_EQUAL\" : \"EQUAL\");\n        break;\n\n      case \"<\":\n        this.emitToken(this.matches(\"=\") ? \"LESS_EQUAL\" : \"LESS\");\n        break;\n\n      case \">\":\n        this.emitToken(this.matches(\"=\") ? \"GREATER_EQUAL\" : \"GREATER\");\n        break;\n      // Two character tokens\n\n      case \"|\":\n        this.matches(\"|\") ? this.emitToken(\"DOUBLE_VERTICAL_BAR\") : this.report(`Unexpected single \"|\" (expecting two)`);\n        break;\n      // Whitespace\n\n      case \" \":\n      case \"\\r\":\n      case \"\\n\":\n      case \"\\t\":\n        break;\n      // Multi-character tokens\n\n      default:\n        const NUMBERS = /[0-9]/;\n\n        if (NUMBERS.test(current)) {\n          let number = current,\n              type = \"NUMBER\"; // Detect hexadecimals\n\n          if (\"0\" === current && \"x\" === this.peek()) for (type = \"HEXADECIMAL\", number += this.consume(); /[0-9a-f]/i.test(this.peek());) number += this.consume();else for (; NUMBERS.test(this.peek());) number += this.consume();\n          this.emitToken(type, number);\n          break;\n        }\n\n        const IDENTIFIERS = /[_$a-z0-9]/i;\n\n        if (IDENTIFIERS.test(current)) {\n          let identifier = current;\n\n          for (; IDENTIFIERS.test(this.peek());) identifier += this.consume();\n\n          if (\"true\" === identifier || \"false\" === identifier) {\n            this.emitToken(\"BOOLEAN\", identifier);\n            break;\n          }\n\n          _types.default.isType(identifier) ? this.emitToken(\"TYPE\", identifier) : this.emitToken(\"IDENTIFIER\", identifier);\n          break;\n        }\n\n        if (`'` === current || `\"` === current) {\n          let string = \"\";\n\n          for (; !this.matches(`'`) && !this.matches(`\"`);) string += this.consume();\n\n          this.emitToken(\"STRING\", string);\n          break;\n        }\n\n        this.report(`Unexpected character \"${current}\"`);\n    }\n  }\n  /**\n  * Push a token to `Scanner.tokens`\n  *\n  * @param {string} type The token type\n  * @param {string?} value The token value\n  * @return {void}\n  */\n\n\n  emitToken(type, value) {\n    let token = {\n      type\n    };\n    value && (token.value = value), this.tokens.push(token);\n  }\n  /**\n  * Get the current character and increase the cursor by 1\n  *\n  * @return {string}\n  */\n\n\n  consume() {\n    return this.cursor++, this.source[this.cursor - 1];\n  }\n  /**\n  * Get the character under the cursor without consuming it.\n  *\n  * @return {string}\n  */\n\n\n  peek() {\n    return this.source[this.cursor];\n  }\n  /**\n  * Checks if the next character matches an expected one.\n  *\n  * Increases the cursor by 1 if the character matches.\n  *\n  * @param {string} expected The character to expect\n  * @return {boolean} True if the next character matches, otherise false\n  */\n\n\n  matches(expected) {\n    return !this.eof() && !(this.peek() !== expected) && (this.cursor++, !0);\n  }\n  /**\n  * Scans source and returns a list of tokens.\n  *\n  * @return {Array<Token>}\n  */\n\n\n  async scan() {\n    for (; !this.eof();) this.scanToken();\n\n    return this.state === SCANNER_STATE.ERROR ? void console.error(`Errors encountered while scanning source`) : this.tokens;\n  }\n  /**\n  * Returns true if we've reached the end of source, otherwise false.\n  *\n  * @return {boolean}\n  */\n\n\n  eof() {\n    return this.cursor >= this.source.length;\n  }\n  /**\n  * Prints an error with location information to `stderr`\n  * and sets the scanner state to `SCANNER_STATE.ERROR`\n  *\n  * @param {string} error\n  * @return {void}\n  */\n\n\n  report(error) {\n    this.state = SCANNER_STATE.ERROR, console.error(`Error (${this.cursor}): ${error}`);\n  }\n\n}\n/**\n* Scans source and returns a list of tokens.\n*\n* @memberof radspec/scanner\n* @param  {string} source\n* @return {Array<Token>}\n*/\n\n\nexports.Scanner = Scanner;\n\nfunction scan(source) {\n  return new Scanner(source).scan();\n}","map":null,"metadata":{},"sourceType":"script"}