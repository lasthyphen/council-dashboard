{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\")),\n    _ethers = require(\"ethers\"),\n    _methodRegistry = _interopRequireDefault(require(\"./lib/methodRegistry\")),\n    _lib = require(\"../lib/\"),\n    _data = require(\"../data/\"),\n    _defaults = require(\"../defaults\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n    (0, _defineProperty2.default)(target, key, source[key]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n  });\n\n  return target;\n}\n\nconst makeUnknownFunctionNode = methodId => ({\n  type: \"string\",\n  value: `Unknown function (${methodId})`\n}),\n      parse = signature => {\n  const fragment = _ethers.ethers.utils.FunctionFragment.from(signature);\n\n  return {\n    name: fragment.name.charAt(0).toUpperCase() + fragment.name.slice(1).split(/(?=[A-Z])/).join(\" \"),\n    args: fragment.inputs.map(input => ({\n      type: input.type\n    }))\n  };\n},\n      getSigHah = sig => _ethers.ethers.utils.hexDataSlice(_ethers.ethers.utils.id(sig), 0, 4),\n      processFunctions = functions => Object.keys(functions).reduce((acc, key) => {\n  const fragment = _ethers.ethers.utils.FunctionFragment.from(key);\n\n  return _objectSpread({\n    [getSigHah(fragment.format())]: {\n      source: functions[key],\n      fragment\n    }\n  }, acc);\n}, {});\n\nvar _default = (provider, evaluator) =>\n/**\n* Interpret calldata using radspec recursively. If the function signature is not in the package's known\n* functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n*\n* @param {address} addr The target address of the call\n* @param {bytes} data The calldata of the call\n* @param {string} [registryAddress] The registry address to lookup descriptions\n* @return {Promise<radspec/evaluator/TypedValue>}\n*/\nasync (addr, data, registryAddress) => {\n  const functions = processFunctions(_data.knownFunctions);\n  if (10 > data.length) return makeUnknownFunctionNode(data); // Get method ID\n\n  const methodId = data.substr(0, 10),\n        fn = functions[methodId]; // If function is not a known function\n\n  if (!fn) try {\n    // Try checking on-chain signature registry\n    const registry = new _methodRegistry.default({\n      registryAddress,\n      provider,\n      network: registryAddress ? void 0 : (await provider.getNetwork()).chainId\n    }),\n          result = await registry.lookup(methodId),\n          {\n      name\n    } = parse(result);\n    return {\n      type: \"string\",\n      value: name // TODO: should we decode and print the arguments as well?\n\n    };\n  } catch {\n    // Try fetching 4bytes API\n    const {\n      results\n    } = await _ethers.ethers.utils.fetchJson(`${_defaults.DEFAULT_API_4BYTES}?hex_signature=${methodId}`);\n\n    if (Array.isArray(results) && 0 < results.length) {\n      const {\n        name\n      } = parse(results[0].text_signature);\n      return {\n        type: \"string\",\n        value: name\n      };\n    } // Fallback to unknown function\n\n\n    return makeUnknownFunctionNode(methodId);\n  } // If the function was found in local radspec registry. Decode and evaluate.\n\n  const {\n    source,\n    fragment\n  } = fn,\n        ethersInterface = new _ethers.ethers.utils.Interface([fragment]),\n        args = ethersInterface.decodeFunctionData(fragment.name, data),\n        parameters = fragment.inputs.reduce((parameters, input, index) => _objectSpread({\n    [`$${index + 1}`]: {\n      type: input.type,\n      value: args[index]\n    }\n  }, parameters), {});\n  return {\n    type: \"string\",\n    value: await (0, _lib.evaluateRaw)(source, parameters, {\n      provider,\n      availableHelpers: evaluator.helpers.getHelpers(),\n      to: addr\n    })\n  };\n};\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}