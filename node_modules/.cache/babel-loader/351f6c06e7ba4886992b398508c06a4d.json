{"ast":null,"code":"import { h as e } from \"./index-ae10dbe8.js\";\nimport { a as t } from \"./subscriptionManager-39f2bcea.js\";\nvar a = {\n  v: 5e3,\n  d: \"Gas limit of the Genesis block.\"\n},\n    i = {\n  v: 17179869184,\n  d: \"Difficulty of the Genesis block.\"\n},\n    s = {\n  v: \"0x0000000000000042\",\n  d: \"the geneis nonce\"\n},\n    o = {\n  v: \"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\",\n  d: \"extra data \"\n},\n    r = {\n  v: \"0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\",\n  d: \"genesis hash\"\n},\n    n = {\n  v: \"0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544\",\n  d: \"the genesis state root\"\n},\n    d = {\n  v: 5e3,\n  d: \"Minimum the gas limit may ever be.\"\n},\n    f = {\n  v: 1024,\n  d: \"The bound divisor of the gas limit, used in update calculations.\"\n},\n    c = {\n  v: 131072,\n  d: \"The minimum that the difficulty may ever be.\"\n},\n    h = {\n  v: 2048,\n  d: \"The bound divisor of the difficulty, used in the update calculations.\"\n},\n    l = {\n  v: 13,\n  d: \"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not.\"\n},\n    u = {\n  v: 32,\n  d: \"Maximum size extra data may be after Genesis.\"\n},\n    m = {\n  v: 3e4,\n  d: \"Duration between proof-of-work epochs.\"\n},\n    p = {\n  v: 1024,\n  d: \"Maximum size of VM stack allowed.\"\n},\n    v = {\n  v: 1024,\n  d: \"Maximum depth of call/create stack.\"\n},\n    g = {\n  v: [0, 2, 3, 5, 8, 10, 20],\n  d: \"Once per operation, for a selection of them.\"\n},\n    G = {\n  v: 10,\n  d: \"Once per EXP instuction.\"\n},\n    b = {\n  v: 10,\n  d: \"Times ceil(log256(exponent)) for the EXP instruction.\"\n},\n    y = {\n  v: 30,\n  d: \"Once per SHA3 operation.\"\n},\n    w = {\n  v: 6,\n  d: \"Once per word of the SHA3 operation's data.\"\n},\n    x = {\n  v: 50,\n  d: \"Once per SLOAD operation.\"\n},\n    L = {\n  v: 2e4,\n  d: \"Once per SSTORE operation if the zeroness changes from zero.\"\n},\n    D = {\n  v: 5e3,\n  d: \"Once per SSTORE operation if the zeroness does not change from zero.\"\n},\n    S = {\n  v: 15e3,\n  d: \"Once per SSTORE operation if the zeroness changes to zero.\"\n},\n    O = {\n  v: 1,\n  d: \"Refunded gas, once per SSTORE operation if the zeroness changes to zero.\"\n},\n    T = {\n  v: 375,\n  d: \"Per LOG* operation.\"\n},\n    P = {\n  v: 8,\n  d: \"Per byte in a LOG* operation's data.\"\n},\n    R = {\n  v: 375,\n  d: \"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas.\"\n},\n    _ = {\n  v: 32e3,\n  d: \"Once per CREATE operation & contract-creation transaction.\"\n},\n    k = {\n  v: 40,\n  d: \"Once per CALL operation & message call transaction.\"\n},\n    B = {\n  v: 2300,\n  d: \"Free gas given at beginning of call.\"\n},\n    E = {\n  v: 9e3,\n  d: \"Paid for CALL when the value transfor is non-zero.\"\n},\n    N = {\n  v: 25e3,\n  d: \"Paid for CALL when the destination address didn't exist prior.\"\n},\n    C = {\n  v: 24e3,\n  d: \"Refunded following a suicide operation.\"\n},\n    z = {\n  v: 3,\n  d: \"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL.\"\n},\n    A = {\n  v: 512,\n  d: \"Divisor for the quadratic particle of the memory cost equation.\"\n},\n    I = {\n  v: 200,\n  d: \"\"\n},\n    Z = {\n  v: 21e3,\n  d: \"Per transaction. NOTE: Not payable on data of calls between transactions.\"\n},\n    F = {\n  v: 32e3,\n  d: \"the cost of creating a contract via tx\"\n},\n    M = {\n  v: 4,\n  d: \"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions.\"\n},\n    j = {\n  v: 68,\n  d: \"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions.\"\n},\n    W = {\n  v: 3,\n  d: \"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.\"\n},\n    K = {\n  v: 3e3,\n  d: \"\"\n},\n    q = {\n  v: 60,\n  d: \"\"\n},\n    H = {\n  v: 12,\n  d: \"\"\n},\n    V = {\n  v: 600,\n  d: \"\"\n},\n    U = {\n  v: 120,\n  d: \"\"\n},\n    X = {\n  v: 15,\n  d: \"\"\n},\n    Y = {\n  v: 3,\n  d: \"\"\n},\n    J = {\n  v: \"5000000000000000000\",\n  d: \"the amount a miner get rewarded for mining a block\"\n},\n    Q = {\n  v: \"625000000000000000\",\n  d: \"The amount of wei a miner of an uncle block gets for being inculded in the blockchain\"\n},\n    $ = {\n  v: \"156250000000000000\",\n  d: \"the amount a miner gets for inculding a uncle\"\n},\n    ee = {\n  v: 115e4,\n  d: \"the block that the Homestead fork started at\"\n},\n    te = {\n  v: 2463e3,\n  d: \"the block that the Homestead Reprice (EIP150) fork started at\"\n},\n    ae = {\n  v: 1e5,\n  d: \"Exponential difficulty timebomb period\"\n},\n    ie = {\n  v: 2\n},\n    se = {\n  genesisGasLimit: a,\n  genesisDifficulty: i,\n  genesisNonce: s,\n  genesisExtraData: o,\n  genesisHash: r,\n  genesisStateRoot: n,\n  minGasLimit: d,\n  gasLimitBoundDivisor: f,\n  minimumDifficulty: c,\n  difficultyBoundDivisor: h,\n  durationLimit: l,\n  maximumExtraDataSize: u,\n  epochDuration: m,\n  stackLimit: p,\n  callCreateDepth: v,\n  tierStepGas: g,\n  expGas: G,\n  expByteGas: b,\n  sha3Gas: y,\n  sha3WordGas: w,\n  sloadGas: x,\n  sstoreSetGas: L,\n  sstoreResetGas: D,\n  sstoreRefundGas: S,\n  jumpdestGas: O,\n  logGas: T,\n  logDataGas: P,\n  logTopicGas: R,\n  createGas: _,\n  callGas: k,\n  callStipend: B,\n  callValueTransferGas: E,\n  callNewAccountGas: N,\n  suicideRefundGas: C,\n  memoryGas: z,\n  quadCoeffDiv: A,\n  createDataGas: I,\n  txGas: Z,\n  txCreation: F,\n  txDataZeroGas: M,\n  txDataNonZeroGas: j,\n  copyGas: W,\n  ecrecoverGas: K,\n  sha256Gas: q,\n  sha256WordGas: H,\n  ripemd160Gas: V,\n  ripemd160WordGas: U,\n  identityGas: X,\n  identityWordGas: Y,\n  minerReward: J,\n  ommerReward: Q,\n  niblingReward: $,\n  homeSteadForkNumber: ee,\n  homesteadRepriceForkNumber: te,\n  timebombPeriod: ae,\n  freeBlockPeriod: ie\n},\n    oe = e(Object.freeze({\n  __proto__: null,\n  genesisGasLimit: a,\n  genesisDifficulty: i,\n  genesisNonce: s,\n  genesisExtraData: o,\n  genesisHash: r,\n  genesisStateRoot: n,\n  minGasLimit: d,\n  gasLimitBoundDivisor: f,\n  minimumDifficulty: c,\n  difficultyBoundDivisor: h,\n  durationLimit: l,\n  maximumExtraDataSize: u,\n  epochDuration: m,\n  stackLimit: p,\n  callCreateDepth: v,\n  tierStepGas: g,\n  expGas: G,\n  expByteGas: b,\n  sha3Gas: y,\n  sha3WordGas: w,\n  sloadGas: x,\n  sstoreSetGas: L,\n  sstoreResetGas: D,\n  sstoreRefundGas: S,\n  jumpdestGas: O,\n  logGas: T,\n  logDataGas: P,\n  logTopicGas: R,\n  createGas: _,\n  callGas: k,\n  callStipend: B,\n  callValueTransferGas: E,\n  callNewAccountGas: N,\n  suicideRefundGas: C,\n  memoryGas: z,\n  quadCoeffDiv: A,\n  createDataGas: I,\n  txGas: Z,\n  txCreation: F,\n  txDataZeroGas: M,\n  txDataNonZeroGas: j,\n  copyGas: W,\n  ecrecoverGas: K,\n  sha256Gas: q,\n  sha256WordGas: H,\n  ripemd160Gas: V,\n  ripemd160WordGas: U,\n  identityGas: X,\n  identityWordGas: Y,\n  minerReward: J,\n  ommerReward: Q,\n  niblingReward: $,\n  homeSteadForkNumber: ee,\n  homesteadRepriceForkNumber: te,\n  timebombPeriod: ae,\n  freeBlockPeriod: ie,\n  default: se\n}));\n\nvar re = t.BN,\n    ne = new re(\"7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0\", 16),\n    de = function () {\n  function e(a) {\n    !function (e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }(this, e), a = a || {};\n    var i = [{\n      name: \"nonce\",\n      length: 32,\n      allowLess: !0,\n      default: new Buffer([])\n    }, {\n      name: \"gasPrice\",\n      length: 32,\n      allowLess: !0,\n      default: new Buffer([])\n    }, {\n      name: \"gasLimit\",\n      alias: \"gas\",\n      length: 32,\n      allowLess: !0,\n      default: new Buffer([])\n    }, {\n      name: \"to\",\n      allowZero: !0,\n      length: 20,\n      default: new Buffer([])\n    }, {\n      name: \"value\",\n      length: 32,\n      allowLess: !0,\n      default: new Buffer([])\n    }, {\n      name: \"data\",\n      alias: \"input\",\n      allowZero: !0,\n      default: new Buffer([])\n    }, {\n      name: \"v\",\n      allowZero: !0,\n      default: new Buffer([28])\n    }, {\n      name: \"r\",\n      length: 32,\n      allowZero: !0,\n      allowLess: !0,\n      default: new Buffer([])\n    }, {\n      name: \"s\",\n      length: 32,\n      allowZero: !0,\n      allowLess: !0,\n      default: new Buffer([])\n    }];\n    t.defineProperties(this, i, a), Object.defineProperty(this, \"from\", {\n      enumerable: !0,\n      configurable: !0,\n      get: this.getSenderAddress.bind(this)\n    });\n    var s = t.bufferToInt(this.v),\n        o = Math.floor((s - 35) / 2);\n    o < 0 && (o = 0), this._chainId = o || a.chainId || 0, this._homestead = !0;\n  }\n\n  return e.prototype.toCreationAddress = function () {\n    return \"\" === this.to.toString(\"hex\");\n  }, e.prototype.hash = function (e) {\n    void 0 === e && (e = !0);\n    var a = void 0;\n    if (e) a = this.raw;else if (this._chainId > 0) {\n      var i = this.raw.slice();\n      this.v = this._chainId, this.r = 0, this.s = 0, a = this.raw, this.raw = i;\n    } else a = this.raw.slice(0, 6);\n    return t.rlphash(a);\n  }, e.prototype.getChainId = function () {\n    return this._chainId;\n  }, e.prototype.getSenderAddress = function () {\n    if (this._from) return this._from;\n    var e = this.getSenderPublicKey();\n    return this._from = t.publicToAddress(e), this._from;\n  }, e.prototype.getSenderPublicKey = function () {\n    if (!(this._senderPubKey && this._senderPubKey.length || this.verifySignature())) throw new Error(\"Invalid Signature\");\n    return this._senderPubKey;\n  }, e.prototype.verifySignature = function () {\n    var e = this.hash(!1);\n    if (this._homestead && 1 === new re(this.s).cmp(ne)) return !1;\n\n    try {\n      var a = t.bufferToInt(this.v);\n      this._chainId > 0 && (a -= 2 * this._chainId + 8), this._senderPubKey = t.ecrecover(e, a, this.r, this.s);\n    } catch (e) {\n      return !1;\n    }\n\n    return !!this._senderPubKey;\n  }, e.prototype.sign = function (e) {\n    var a = this.hash(!1),\n        i = t.ecsign(a, e);\n    this._chainId > 0 && (i.v += 2 * this._chainId + 8), Object.assign(this, i);\n  }, e.prototype.getDataFee = function () {\n    for (var e = this.raw[5], t = new re(0), a = 0; a < e.length; a++) 0 === e[a] ? t.iaddn(oe.txDataZeroGas.v) : t.iaddn(oe.txDataNonZeroGas.v);\n\n    return t;\n  }, e.prototype.getBaseFee = function () {\n    var e = this.getDataFee().iaddn(oe.txGas.v);\n    return this._homestead && this.toCreationAddress() && e.iaddn(oe.txCreation.v), e;\n  }, e.prototype.getUpfrontCost = function () {\n    return new re(this.gasLimit).imul(new re(this.gasPrice)).iadd(new re(this.value));\n  }, e.prototype.validate = function (e) {\n    var t = [];\n    return this.verifySignature() || t.push(\"Invalid Signature\"), this.getBaseFee().cmp(new re(this.gasLimit)) > 0 && t.push([\"gas limit is too low. Need at least \" + this.getBaseFee()]), void 0 === e || !1 === e ? 0 === t.length : t.join(\" \");\n  }, e;\n}();\n\nexport { de as T };","map":null,"metadata":{},"sourceType":"module"}