{"ast":null,"code":"\"use strict\";\n\nvar e = require(\"@web3-react/abstract-connector\");\n\nfunction t() {\n  return (t = Object.assign || function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n\n      for (var n in r) {\n        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n      }\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nfunction r(e, t) {\n  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;\n}\n\nfunction n(e) {\n  return (n = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n    return e.__proto__ || Object.getPrototypeOf(e);\n  })(e);\n}\n\nfunction o(e, t) {\n  return (o = Object.setPrototypeOf || function (e, t) {\n    return e.__proto__ = t, e;\n  })(e, t);\n}\n\nfunction i() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (e) {\n    return !1;\n  }\n}\n\nfunction c(e, t, r) {\n  return (c = i() ? Reflect.construct : function (e, t, r) {\n    var n = [null];\n    n.push.apply(n, t);\n    var i = new (Function.bind.apply(e, n))();\n    return r && o(i, r.prototype), i;\n  }).apply(null, arguments);\n}\n\nfunction u(e) {\n  var t = \"function\" == typeof Map ? new Map() : void 0;\n  return (u = function u(e) {\n    if (null === e || -1 === Function.toString.call(e).indexOf(\"[native code]\")) return e;\n    if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== t) {\n      if (t.has(e)) return t.get(e);\n      t.set(e, r);\n    }\n\n    function r() {\n      return c(e, arguments, n(this).constructor);\n    }\n\n    return r.prototype = Object.create(e.prototype, {\n      constructor: {\n        value: r,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), o(r, e);\n  })(e);\n}\n\nfunction a(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction h(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nfunction s(e) {\n  return e.hasOwnProperty(\"result\") ? e.result : e;\n}\n\nrequire(\"tiny-warning\"), \"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")));\n\nvar d = function (e) {\n  function t() {\n    var t;\n    return (t = e.call(this) || this).name = t.constructor.name, t.message = \"No Ethereum provider was passed to the constructor or found on window.ethereum.\", t;\n  }\n\n  return r(t, e), t;\n}(u(Error)),\n    f = function (e) {\n  function t() {\n    var t;\n    return (t = e.call(this) || this).name = t.constructor.name, t.message = \"The user rejected the request.\", t;\n  }\n\n  return r(t, e), t;\n}(u(Error)),\n    p = function (e) {\n  function n(t) {\n    var r,\n        n = t.provider,\n        o = void 0 === n ? window.ethereum : n;\n    return (r = e.call(this, {\n      supportedChainIds: t.supportedChainIds\n    }) || this).provider = o, r.handleNetworkChanged = r.handleNetworkChanged.bind(a(r)), r.handleChainChanged = r.handleChainChanged.bind(a(r)), r.handleAccountsChanged = r.handleAccountsChanged.bind(a(r)), r.handleClose = r.handleClose.bind(a(r)), r;\n  }\n\n  r(n, e);\n  var o = n.prototype;\n  return o.handleChainChanged = function (e) {\n    this.emitUpdate({\n      chainId: e,\n      provider: this.provider\n    });\n  }, o.handleAccountsChanged = function (e) {\n    0 === e.length ? this.emitDeactivate() : this.emitUpdate({\n      account: e[0]\n    });\n  }, o.handleClose = function (e, t) {\n    this.emitDeactivate();\n  }, o.handleNetworkChanged = function (e) {\n    this.emitUpdate({\n      chainId: e,\n      provider: this.provider\n    });\n  }, o.activate = function () {\n    try {\n      var e,\n          r = function r(_r) {\n        if (n) return _r;\n\n        function i() {\n          return t({\n            provider: o.provider\n          }, e ? {\n            account: e\n          } : {});\n        }\n\n        var c = function () {\n          if (!e) return Promise.resolve(o.provider.enable().then(function (e) {\n            return e && s(e)[0];\n          })).then(function (t) {\n            e = t;\n          });\n        }();\n\n        return c && c.then ? c.then(i) : i();\n      },\n          n = !1,\n          o = this;\n\n      if (!o.provider) throw new d();\n      o.provider.on && (o.provider.on(\"chainChanged\", o.handleChainChanged), o.provider.on(\"accountsChanged\", o.handleAccountsChanged), o.provider.on(\"close\", o.handleClose), o.provider.on(\"networkChanged\", o.handleNetworkChanged)), o.provider.isMetaMask && (o.provider.autoRefreshOnNetworkChange = !1);\n      var i = h(function () {\n        return Promise.resolve(o.provider.send(\"eth_requestAccounts\").then(function (e) {\n          return s(e)[0];\n        })).then(function (t) {\n          e = t;\n        });\n      }, function (e) {\n        if (4001 === e.code) throw new f();\n      });\n      return Promise.resolve(i && i.then ? i.then(r) : r(i));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.provider);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, o.getChainId = function () {\n    try {\n      var e,\n          t = function t() {\n        function t() {\n          if (!e) try {\n            e = s(r.provider.send({\n              method: \"net_version\"\n            }));\n          } catch (e) {}\n          return e || (e = r.provider.isDapper ? s(r.provider.cachedResults.net_version) : r.provider.chainId || r.provider.networkVersion || r.provider._chainId), e;\n        }\n\n        var n = function () {\n          if (!e) {\n            var t = h(function () {\n              return Promise.resolve(r.provider.send(\"net_version\").then(s)).then(function (t) {\n                e = t;\n              });\n            }, function () {});\n            if (t && t.then) return t.then(function () {});\n          }\n        }();\n\n        return n && n.then ? n.then(t) : t();\n      },\n          r = this;\n\n      if (!r.provider) throw new d();\n      var n = h(function () {\n        return Promise.resolve(r.provider.send(\"eth_chainId\").then(s)).then(function (t) {\n          e = t;\n        });\n      }, function () {});\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, o.getAccount = function () {\n    try {\n      var e,\n          t = function t() {\n        function t() {\n          return e || (e = s(r.provider.send({\n            method: \"eth_accounts\"\n          }))[0]), e;\n        }\n\n        var n = function () {\n          if (!e) {\n            var t = h(function () {\n              return Promise.resolve(r.provider.enable().then(function (e) {\n                return s(e)[0];\n              })).then(function (t) {\n                e = t;\n              });\n            }, function () {});\n            if (t && t.then) return t.then(function () {});\n          }\n        }();\n\n        return n && n.then ? n.then(t) : t();\n      },\n          r = this;\n\n      if (!r.provider) throw new d();\n      var n = h(function () {\n        return Promise.resolve(r.provider.send(\"eth_accounts\").then(function (e) {\n          return s(e)[0];\n        })).then(function (t) {\n          e = t;\n        });\n      }, function () {});\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, o.deactivate = function () {\n    this.provider && this.provider.removeListener && (this.provider.removeListener(\"chainChanged\", this.handleChainChanged), this.provider.removeListener(\"accountsChanged\", this.handleAccountsChanged), this.provider.removeListener(\"close\", this.handleClose), this.provider.removeListener(\"networkChanged\", this.handleNetworkChanged));\n  }, o.isAuthorized = function () {\n    try {\n      var e = this;\n      return Promise.resolve(!!e.provider && h(function () {\n        return Promise.resolve(e.provider.send(\"eth_accounts\").then(function (e) {\n          return s(e).length > 0;\n        }));\n      }, function () {\n        return !1;\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, n;\n}(e.AbstractConnector);\n\nexports.NoEthereumProviderError = d, exports.ProvidedConnector = p, exports.UserRejectedRequestError = f;","map":null,"metadata":{},"sourceType":"script"}