{"ast":null,"code":"import t, { useMemo as e, useContext as n, useReducer as r, useRef as o, useCallback as i, useEffect as s, createContext as c, useState as a } from \"react\";\nimport { ProvidedConnector as u, UserRejectedRequestError as l } from \"@aragon/provided-connector\";\nimport h, { EventEmitter as f } from \"events\";\nvar d = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n\nfunction p() {\n  throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n}\n\nfunction _(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\n\nfunction g(t, e) {\n  return t(e = {\n    exports: {}\n  }, e.exports), e.exports;\n}\n\nfunction m(t) {\n  return t && t.default || t;\n}\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar v = \"function\" == typeof Symbol && Symbol.for,\n    y = v ? Symbol.for(\"react.element\") : 60103,\n    b = v ? Symbol.for(\"react.portal\") : 60106,\n    w = v ? Symbol.for(\"react.fragment\") : 60107,\n    E = v ? Symbol.for(\"react.strict_mode\") : 60108,\n    C = v ? Symbol.for(\"react.profiler\") : 60114,\n    O = v ? Symbol.for(\"react.provider\") : 60109,\n    P = v ? Symbol.for(\"react.context\") : 60110,\n    N = v ? Symbol.for(\"react.async_mode\") : 60111,\n    I = v ? Symbol.for(\"react.concurrent_mode\") : 60111,\n    S = v ? Symbol.for(\"react.forward_ref\") : 60112,\n    D = v ? Symbol.for(\"react.suspense\") : 60113,\n    A = v ? Symbol.for(\"react.suspense_list\") : 60120,\n    R = v ? Symbol.for(\"react.memo\") : 60115,\n    k = v ? Symbol.for(\"react.lazy\") : 60116,\n    T = v ? Symbol.for(\"react.block\") : 60121,\n    j = v ? Symbol.for(\"react.fundamental\") : 60117,\n    x = v ? Symbol.for(\"react.responder\") : 60118,\n    B = v ? Symbol.for(\"react.scope\") : 60119;\n\nfunction M(t) {\n  if (\"object\" == typeof t && null !== t) {\n    var e = t.$$typeof;\n\n    switch (e) {\n      case y:\n        switch (t = t.type) {\n          case N:\n          case I:\n          case w:\n          case C:\n          case E:\n          case D:\n            return t;\n\n          default:\n            switch (t = t && t.$$typeof) {\n              case P:\n              case S:\n              case k:\n              case R:\n              case O:\n                return t;\n\n              default:\n                return e;\n            }\n\n        }\n\n      case b:\n        return e;\n    }\n  }\n}\n\nfunction U(t) {\n  return M(t) === I;\n}\n\nvar L = {\n  AsyncMode: N,\n  ConcurrentMode: I,\n  ContextConsumer: P,\n  ContextProvider: O,\n  Element: y,\n  ForwardRef: S,\n  Fragment: w,\n  Lazy: k,\n  Memo: R,\n  Portal: b,\n  Profiler: C,\n  StrictMode: E,\n  Suspense: D,\n  isAsyncMode: function (t) {\n    return U(t) || M(t) === N;\n  },\n  isConcurrentMode: U,\n  isContextConsumer: function (t) {\n    return M(t) === P;\n  },\n  isContextProvider: function (t) {\n    return M(t) === O;\n  },\n  isElement: function (t) {\n    return \"object\" == typeof t && null !== t && t.$$typeof === y;\n  },\n  isForwardRef: function (t) {\n    return M(t) === S;\n  },\n  isFragment: function (t) {\n    return M(t) === w;\n  },\n  isLazy: function (t) {\n    return M(t) === k;\n  },\n  isMemo: function (t) {\n    return M(t) === R;\n  },\n  isPortal: function (t) {\n    return M(t) === b;\n  },\n  isProfiler: function (t) {\n    return M(t) === C;\n  },\n  isStrictMode: function (t) {\n    return M(t) === E;\n  },\n  isSuspense: function (t) {\n    return M(t) === D;\n  },\n  isValidElementType: function (t) {\n    return \"string\" == typeof t || \"function\" == typeof t || t === w || t === I || t === C || t === E || t === D || t === A || \"object\" == typeof t && null !== t && (t.$$typeof === k || t.$$typeof === R || t.$$typeof === O || t.$$typeof === P || t.$$typeof === S || t.$$typeof === j || t.$$typeof === x || t.$$typeof === B || t.$$typeof === T);\n  },\n  typeOf: M\n},\n    V = g(function (t, e) {\n  \"production\" !== process.env.NODE_ENV && function () {\n    var t = \"function\" == typeof Symbol && Symbol.for,\n        n = t ? Symbol.for(\"react.element\") : 60103,\n        r = t ? Symbol.for(\"react.portal\") : 60106,\n        o = t ? Symbol.for(\"react.fragment\") : 60107,\n        i = t ? Symbol.for(\"react.strict_mode\") : 60108,\n        s = t ? Symbol.for(\"react.profiler\") : 60114,\n        c = t ? Symbol.for(\"react.provider\") : 60109,\n        a = t ? Symbol.for(\"react.context\") : 60110,\n        u = t ? Symbol.for(\"react.async_mode\") : 60111,\n        l = t ? Symbol.for(\"react.concurrent_mode\") : 60111,\n        h = t ? Symbol.for(\"react.forward_ref\") : 60112,\n        f = t ? Symbol.for(\"react.suspense\") : 60113,\n        d = t ? Symbol.for(\"react.suspense_list\") : 60120,\n        p = t ? Symbol.for(\"react.memo\") : 60115,\n        _ = t ? Symbol.for(\"react.lazy\") : 60116,\n        g = t ? Symbol.for(\"react.block\") : 60121,\n        m = t ? Symbol.for(\"react.fundamental\") : 60117,\n        v = t ? Symbol.for(\"react.responder\") : 60118,\n        y = t ? Symbol.for(\"react.scope\") : 60119;\n\n    function b(t) {\n      if (\"object\" == typeof t && null !== t) {\n        var e = t.$$typeof;\n\n        switch (e) {\n          case n:\n            var d = t.type;\n\n            switch (d) {\n              case u:\n              case l:\n              case o:\n              case s:\n              case i:\n              case f:\n                return d;\n\n              default:\n                var g = d && d.$$typeof;\n\n                switch (g) {\n                  case a:\n                  case h:\n                  case _:\n                  case p:\n                  case c:\n                    return g;\n\n                  default:\n                    return e;\n                }\n\n            }\n\n          case r:\n            return e;\n        }\n      }\n    }\n\n    var w = u,\n        E = l,\n        C = a,\n        O = c,\n        P = n,\n        N = h,\n        I = o,\n        S = _,\n        D = p,\n        A = r,\n        R = s,\n        k = i,\n        T = f,\n        j = !1;\n\n    function x(t) {\n      return b(t) === l;\n    }\n\n    e.AsyncMode = w, e.ConcurrentMode = E, e.ContextConsumer = C, e.ContextProvider = O, e.Element = P, e.ForwardRef = N, e.Fragment = I, e.Lazy = S, e.Memo = D, e.Portal = A, e.Profiler = R, e.StrictMode = k, e.Suspense = T, e.isAsyncMode = function (t) {\n      return j || (j = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), x(t) || b(t) === u;\n    }, e.isConcurrentMode = x, e.isContextConsumer = function (t) {\n      return b(t) === a;\n    }, e.isContextProvider = function (t) {\n      return b(t) === c;\n    }, e.isElement = function (t) {\n      return \"object\" == typeof t && null !== t && t.$$typeof === n;\n    }, e.isForwardRef = function (t) {\n      return b(t) === h;\n    }, e.isFragment = function (t) {\n      return b(t) === o;\n    }, e.isLazy = function (t) {\n      return b(t) === _;\n    }, e.isMemo = function (t) {\n      return b(t) === p;\n    }, e.isPortal = function (t) {\n      return b(t) === r;\n    }, e.isProfiler = function (t) {\n      return b(t) === s;\n    }, e.isStrictMode = function (t) {\n      return b(t) === i;\n    }, e.isSuspense = function (t) {\n      return b(t) === f;\n    }, e.isValidElementType = function (t) {\n      return \"string\" == typeof t || \"function\" == typeof t || t === o || t === l || t === s || t === i || t === f || t === d || \"object\" == typeof t && null !== t && (t.$$typeof === _ || t.$$typeof === p || t.$$typeof === c || t.$$typeof === a || t.$$typeof === h || t.$$typeof === m || t.$$typeof === v || t.$$typeof === y || t.$$typeof === g);\n    }, e.typeOf = b;\n  }();\n}),\n    F = (V.AsyncMode, V.ConcurrentMode, V.ContextConsumer, V.ContextProvider, V.Element, V.ForwardRef, V.Fragment, V.Lazy, V.Memo, V.Portal, V.Profiler, V.StrictMode, V.Suspense, V.isAsyncMode, V.isConcurrentMode, V.isContextConsumer, V.isContextProvider, V.isElement, V.isForwardRef, V.isFragment, V.isLazy, V.isMemo, V.isPortal, V.isProfiler, V.isStrictMode, V.isSuspense, V.isValidElementType, V.typeOf, g(function (t) {\n  \"production\" === process.env.NODE_ENV ? t.exports = L : t.exports = V;\n})),\n    q = Object.getOwnPropertySymbols,\n    $ = Object.prototype.hasOwnProperty,\n    z = Object.prototype.propertyIsEnumerable;\n\nfunction W(t) {\n  if (null == t) throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(t);\n}\n\nvar G = function () {\n  try {\n    if (!Object.assign) return !1;\n    var t = new String(\"abc\");\n    if (t[5] = \"de\", \"5\" === Object.getOwnPropertyNames(t)[0]) return !1;\n\n    for (var e = {}, n = 0; n < 10; n++) e[\"_\" + String.fromCharCode(n)] = n;\n\n    if (\"0123456789\" !== Object.getOwnPropertyNames(e).map(function (t) {\n      return e[t];\n    }).join(\"\")) return !1;\n    var r = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function (t) {\n      r[t] = t;\n    }), \"abcdefghijklmnopqrst\" === Object.keys(Object.assign({}, r)).join(\"\");\n  } catch (t) {\n    return !1;\n  }\n}() ? Object.assign : function (t, e) {\n  for (var n, r, o = W(t), i = 1; i < arguments.length; i++) {\n    for (var s in n = Object(arguments[i])) $.call(n, s) && (o[s] = n[s]);\n\n    if (q) {\n      r = q(n);\n\n      for (var c = 0; c < r.length; c++) z.call(n, r[c]) && (o[r[c]] = n[r[c]]);\n    }\n  }\n\n  return o;\n},\n    H = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\",\n    J = function () {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var K = H,\n      X = {},\n      Y = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  J = function (t) {\n    var e = \"Warning: \" + t;\n    \"undefined\" != typeof console && console.error(e);\n\n    try {\n      throw new Error(e);\n    } catch (t) {}\n  };\n}\n\nfunction Q(t, e, n, r, o) {\n  if (\"production\" !== process.env.NODE_ENV) for (var i in t) if (Y(t, i)) {\n    var s;\n\n    try {\n      if (\"function\" != typeof t[i]) {\n        var c = Error((r || \"React class\") + \": \" + n + \" type `\" + i + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof t[i] + \"`.\");\n        throw c.name = \"Invariant Violation\", c;\n      }\n\n      s = t[i](e, i, r, n, null, K);\n    } catch (t) {\n      s = t;\n    }\n\n    if (!s || s instanceof Error || J((r || \"React class\") + \": type specification of \" + n + \" `\" + i + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof s + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"), s instanceof Error && !(s.message in X)) {\n      X[s.message] = !0;\n      var a = o ? o() : \"\";\n      J(\"Failed \" + n + \" type: \" + s.message + (null != a ? a : \"\"));\n    }\n  }\n}\n\nQ.resetWarningCache = function () {\n  \"production\" !== process.env.NODE_ENV && (X = {});\n};\n\nvar Z = Q,\n    tt = Function.call.bind(Object.prototype.hasOwnProperty),\n    et = function () {};\n\nfunction nt() {\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (et = function (t) {\n  var e = \"Warning: \" + t;\n  \"undefined\" != typeof console && console.error(e);\n\n  try {\n    throw new Error(e);\n  } catch (t) {}\n});\n\nvar rt = function (t, e) {\n  var n = \"function\" == typeof Symbol && Symbol.iterator;\n  var r = {\n    array: c(\"array\"),\n    bool: c(\"boolean\"),\n    func: c(\"function\"),\n    number: c(\"number\"),\n    object: c(\"object\"),\n    string: c(\"string\"),\n    symbol: c(\"symbol\"),\n    any: s(nt),\n    arrayOf: function (t) {\n      return s(function (e, n, r, o, s) {\n        if (\"function\" != typeof t) return new i(\"Property `\" + s + \"` of component `\" + r + \"` has invalid PropType notation inside arrayOf.\");\n        var c = e[n];\n        if (!Array.isArray(c)) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + u(c) + \"` supplied to `\" + r + \"`, expected an array.\");\n\n        for (var a = 0; a < c.length; a++) {\n          var l = t(c, a, r, o, s + \"[\" + a + \"]\", H);\n          if (l instanceof Error) return l;\n        }\n\n        return null;\n      });\n    },\n    element: s(function (e, n, r, o, s) {\n      var c = e[n];\n      return t(c) ? null : new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + u(c) + \"` supplied to `\" + r + \"`, expected a single ReactElement.\");\n    }),\n    elementType: s(function (t, e, n, r, o) {\n      var s = t[e];\n      return F.isValidElementType(s) ? null : new i(\"Invalid \" + r + \" `\" + o + \"` of type `\" + u(s) + \"` supplied to `\" + n + \"`, expected a single ReactElement type.\");\n    }),\n    instanceOf: function (t) {\n      return s(function (e, n, r, o, s) {\n        if (!(e[n] instanceof t)) {\n          var c = t.name || \"<<anonymous>>\";\n          return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + function (t) {\n            if (!t.constructor || !t.constructor.name) return \"<<anonymous>>\";\n            return t.constructor.name;\n          }(e[n]) + \"` supplied to `\" + r + \"`, expected instance of `\" + c + \"`.\");\n        }\n\n        return null;\n      });\n    },\n    node: s(function (t, e, n, r, o) {\n      return a(t[e]) ? null : new i(\"Invalid \" + r + \" `\" + o + \"` supplied to `\" + n + \"`, expected a ReactNode.\");\n    }),\n    objectOf: function (t) {\n      return s(function (e, n, r, o, s) {\n        if (\"function\" != typeof t) return new i(\"Property `\" + s + \"` of component `\" + r + \"` has invalid PropType notation inside objectOf.\");\n        var c = e[n],\n            a = u(c);\n        if (\"object\" !== a) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + a + \"` supplied to `\" + r + \"`, expected an object.\");\n\n        for (var l in c) if (tt(c, l)) {\n          var h = t(c, l, r, o, s + \".\" + l, H);\n          if (h instanceof Error) return h;\n        }\n\n        return null;\n      });\n    },\n    oneOf: function (t) {\n      if (!Array.isArray(t)) return \"production\" !== process.env.NODE_ENV && (arguments.length > 1 ? et(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\") : et(\"Invalid argument supplied to oneOf, expected an array.\")), nt;\n\n      function e(e, n, r, s, c) {\n        for (var a = e[n], u = 0; u < t.length; u++) if (o(a, t[u])) return null;\n\n        var h = JSON.stringify(t, function (t, e) {\n          return \"symbol\" === l(e) ? String(e) : e;\n        });\n        return new i(\"Invalid \" + s + \" `\" + c + \"` of value `\" + String(a) + \"` supplied to `\" + r + \"`, expected one of \" + h + \".\");\n      }\n\n      return s(e);\n    },\n    oneOfType: function (t) {\n      if (!Array.isArray(t)) return \"production\" !== process.env.NODE_ENV && et(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), nt;\n\n      for (var e = 0; e < t.length; e++) {\n        var n = t[e];\n        if (\"function\" != typeof n) return et(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + h(n) + \" at index \" + e + \".\"), nt;\n      }\n\n      return s(function (e, n, r, o, s) {\n        for (var c = 0; c < t.length; c++) {\n          if (null == (0, t[c])(e, n, r, o, s, H)) return null;\n        }\n\n        return new i(\"Invalid \" + o + \" `\" + s + \"` supplied to `\" + r + \"`.\");\n      });\n    },\n    shape: function (t) {\n      return s(function (e, n, r, o, s) {\n        var c = e[n],\n            a = u(c);\n        if (\"object\" !== a) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + a + \"` supplied to `\" + r + \"`, expected `object`.\");\n\n        for (var l in t) {\n          var h = t[l];\n\n          if (h) {\n            var f = h(c, l, r, o, s + \".\" + l, H);\n            if (f) return f;\n          }\n        }\n\n        return null;\n      });\n    },\n    exact: function (t) {\n      return s(function (e, n, r, o, s) {\n        var c = e[n],\n            a = u(c);\n        if (\"object\" !== a) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + a + \"` supplied to `\" + r + \"`, expected `object`.\");\n        var l = G({}, e[n], t);\n\n        for (var h in l) {\n          var f = t[h];\n          if (!f) return new i(\"Invalid \" + o + \" `\" + s + \"` key `\" + h + \"` supplied to `\" + r + \"`.\\nBad object: \" + JSON.stringify(e[n], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(t), null, \"  \"));\n          var d = f(c, h, r, o, s + \".\" + h, H);\n          if (d) return d;\n        }\n\n        return null;\n      });\n    }\n  };\n\n  function o(t, e) {\n    return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;\n  }\n\n  function i(t) {\n    this.message = t, this.stack = \"\";\n  }\n\n  function s(t) {\n    if (\"production\" !== process.env.NODE_ENV) var n = {},\n        r = 0;\n\n    function o(o, s, c, a, u, l, h) {\n      if (a = a || \"<<anonymous>>\", l = l || c, h !== H) {\n        if (e) {\n          var f = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\");\n          throw f.name = \"Invariant Violation\", f;\n        }\n\n        if (\"production\" !== process.env.NODE_ENV && \"undefined\" != typeof console) {\n          var d = a + \":\" + c;\n          !n[d] && r < 3 && (et(\"You are manually calling a React.PropTypes validation function for the `\" + l + \"` prop on `\" + a + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"), n[d] = !0, r++);\n        }\n      }\n\n      return null == s[c] ? o ? null === s[c] ? new i(\"The \" + u + \" `\" + l + \"` is marked as required in `\" + a + \"`, but its value is `null`.\") : new i(\"The \" + u + \" `\" + l + \"` is marked as required in `\" + a + \"`, but its value is `undefined`.\") : null : t(s, c, a, u, l);\n    }\n\n    var s = o.bind(null, !1);\n    return s.isRequired = o.bind(null, !0), s;\n  }\n\n  function c(t) {\n    return s(function (e, n, r, o, s, c) {\n      var a = e[n];\n      return u(a) !== t ? new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + l(a) + \"` supplied to `\" + r + \"`, expected `\" + t + \"`.\") : null;\n    });\n  }\n\n  function a(e) {\n    switch (typeof e) {\n      case \"number\":\n      case \"string\":\n      case \"undefined\":\n        return !0;\n\n      case \"boolean\":\n        return !e;\n\n      case \"object\":\n        if (Array.isArray(e)) return e.every(a);\n        if (null === e || t(e)) return !0;\n\n        var r = function (t) {\n          var e = t && (n && t[n] || t[\"@@iterator\"]);\n          if (\"function\" == typeof e) return e;\n        }(e);\n\n        if (!r) return !1;\n        var o,\n            i = r.call(e);\n\n        if (r !== e.entries) {\n          for (; !(o = i.next()).done;) if (!a(o.value)) return !1;\n        } else for (; !(o = i.next()).done;) {\n          var s = o.value;\n          if (s && !a(s[1])) return !1;\n        }\n\n        return !0;\n\n      default:\n        return !1;\n    }\n  }\n\n  function u(t) {\n    var e = typeof t;\n    return Array.isArray(t) ? \"array\" : t instanceof RegExp ? \"object\" : function (t, e) {\n      return \"symbol\" === t || !!e && (\"Symbol\" === e[\"@@toStringTag\"] || \"function\" == typeof Symbol && e instanceof Symbol);\n    }(e, t) ? \"symbol\" : e;\n  }\n\n  function l(t) {\n    if (null == t) return \"\" + t;\n    var e = u(t);\n\n    if (\"object\" === e) {\n      if (t instanceof Date) return \"date\";\n      if (t instanceof RegExp) return \"regexp\";\n    }\n\n    return e;\n  }\n\n  function h(t) {\n    var e = l(t);\n\n    switch (e) {\n      case \"array\":\n      case \"object\":\n        return \"an \" + e;\n\n      case \"boolean\":\n      case \"date\":\n      case \"regexp\":\n        return \"a \" + e;\n\n      default:\n        return e;\n    }\n  }\n\n  return i.prototype = Error.prototype, r.checkPropTypes = Z, r.resetWarningCache = Z.resetWarningCache, r.PropTypes = r, r;\n};\n\nfunction ot() {}\n\nfunction it() {}\n\nit.resetWarningCache = ot;\nvar st,\n    ct = g(function (t) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    var e = F;\n    t.exports = rt(e.isElement, !0);\n  } else t.exports = function () {\n    function t(t, e, n, r, o, i) {\n      if (i !== H) {\n        var s = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n        throw s.name = \"Invariant Violation\", s;\n      }\n    }\n\n    function e() {\n      return t;\n    }\n\n    t.isRequired = t;\n    var n = {\n      array: t,\n      bool: t,\n      func: t,\n      number: t,\n      object: t,\n      string: t,\n      symbol: t,\n      any: t,\n      arrayOf: e,\n      element: t,\n      elementType: t,\n      instanceOf: e,\n      node: t,\n      objectOf: e,\n      oneOf: e,\n      oneOfType: e,\n      shape: e,\n      exact: e,\n      checkPropTypes: it,\n      resetWarningCache: ot\n    };\n    return n.PropTypes = n, n;\n  }();\n}),\n    at = \"production\" === process.env.NODE_ENV;\n\nfunction ut(t, e) {\n  if (!t) {\n    if (at) throw new Error(\"Invariant failed\");\n    throw new Error(\"Invariant failed: \" + (e || \"\"));\n  }\n}\n\n!function (t) {\n  t.Update = \"Web3ReactUpdate\", t.Error = \"Web3ReactError\", t.Deactivate = \"Web3ReactDeactivate\";\n}(st || (st = {}));\nvar lt = \"production\" === process.env.NODE_ENV;\n\nfunction ht(t, e) {\n  if (!lt) {\n    if (t) return;\n    var n = \"Warning: \" + e;\n    \"undefined\" != typeof console && console.warn(n);\n\n    try {\n      throw Error(n);\n    } catch (t) {}\n  }\n}\n\nlet ft = !1,\n    dt = !1;\nconst pt = {\n  debug: 1,\n  default: 2,\n  info: 2,\n  warning: 3,\n  error: 4,\n  off: 5\n};\nlet _t = pt.default,\n    gt = null;\n\nconst mt = function () {\n  try {\n    const t = [];\n    if ([\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(e => {\n      try {\n        if (\"test\" !== \"test\".normalize(e)) throw new Error(\"bad normalize\");\n      } catch (n) {\n        t.push(e);\n      }\n    }), t.length) throw new Error(\"missing \" + t.join(\", \"));\n    if (String.fromCharCode(233).normalize(\"NFD\") !== String.fromCharCode(101, 769)) throw new Error(\"broken implementation\");\n  } catch (t) {\n    return t.message;\n  }\n\n  return null;\n}();\n\nclass vt {\n  constructor(t) {\n    Object.defineProperty(this, \"version\", {\n      enumerable: !0,\n      value: t,\n      writable: !1\n    });\n  }\n\n  _log(t, e) {\n    const n = t.toLowerCase();\n    null == pt[n] && this.throwArgumentError(\"invalid log level name\", \"logLevel\", t), _t > pt[n] || console.log.apply(console, e);\n  }\n\n  debug(...t) {\n    this._log(vt.levels.DEBUG, t);\n  }\n\n  info(...t) {\n    this._log(vt.levels.INFO, t);\n  }\n\n  warn(...t) {\n    this._log(vt.levels.WARNING, t);\n  }\n\n  makeError(t, e, n) {\n    if (dt) return this.makeError(\"censored error\", e, {});\n    e || (e = vt.errors.UNKNOWN_ERROR), n || (n = {});\n    const r = [];\n    Object.keys(n).forEach(t => {\n      try {\n        r.push(t + \"=\" + JSON.stringify(n[t]));\n      } catch (e) {\n        r.push(t + \"=\" + JSON.stringify(n[t].toString()));\n      }\n    }), r.push(`code=${e}`), r.push(`version=${this.version}`);\n    const o = t;\n    r.length && (t += \" (\" + r.join(\", \") + \")\");\n    const i = new Error(t);\n    return i.reason = o, i.code = e, Object.keys(n).forEach(function (t) {\n      i[t] = n[t];\n    }), i;\n  }\n\n  throwError(t, e, n) {\n    throw this.makeError(t, e, n);\n  }\n\n  throwArgumentError(t, e, n) {\n    return this.throwError(t, vt.errors.INVALID_ARGUMENT, {\n      argument: e,\n      value: n\n    });\n  }\n\n  checkNormalize(t) {\n    mt && this.throwError(\"platform missing String.prototype.normalize\", vt.errors.UNSUPPORTED_OPERATION, {\n      operation: \"String.prototype.normalize\",\n      form: mt\n    });\n  }\n\n  checkSafeUint53(t, e) {\n    \"number\" == typeof t && (null == e && (e = \"value not safe\"), (t < 0 || t >= 9007199254740991) && this.throwError(e, vt.errors.NUMERIC_FAULT, {\n      operation: \"checkSafeInteger\",\n      fault: \"out-of-safe-range\",\n      value: t\n    }), t % 1 && this.throwError(e, vt.errors.NUMERIC_FAULT, {\n      operation: \"checkSafeInteger\",\n      fault: \"non-integer\",\n      value: t\n    }));\n  }\n\n  checkArgumentCount(t, e, n) {\n    n = n ? \": \" + n : \"\", t < e && this.throwError(\"missing argument\" + n, vt.errors.MISSING_ARGUMENT, {\n      count: t,\n      expectedCount: e\n    }), t > e && this.throwError(\"too many arguments\" + n, vt.errors.UNEXPECTED_ARGUMENT, {\n      count: t,\n      expectedCount: e\n    });\n  }\n\n  checkNew(t, e) {\n    t !== Object && null != t || this.throwError(\"missing new\", vt.errors.MISSING_NEW, {\n      name: e.name\n    });\n  }\n\n  checkAbstract(t, e) {\n    t === e ? this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(e.name) + \" directly; use a sub-class\", vt.errors.UNSUPPORTED_OPERATION, {\n      name: t.name,\n      operation: \"new\"\n    }) : t !== Object && null != t || this.throwError(\"missing new\", vt.errors.MISSING_NEW, {\n      name: e.name\n    });\n  }\n\n  static globalLogger() {\n    return gt || (gt = new vt(\"logger/5.0.0-beta.136\")), gt;\n  }\n\n  static setCensorship(t, e) {\n    if (!t && e && this.globalLogger().throwError(\"cannot permanently disable censorship\", vt.errors.UNSUPPORTED_OPERATION, {\n      operation: \"setCensorship\"\n    }), ft) {\n      if (!t) return;\n      this.globalLogger().throwError(\"error censorship permanent\", vt.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\"\n      });\n    }\n\n    dt = !!t, ft = !!e;\n  }\n\n  static setLogLevel(t) {\n    const e = pt[t];\n    null != e ? _t = e : vt.globalLogger().warn(\"invalid log level - \" + t);\n  }\n\n}\n\nvt.errors = {\n  UNKNOWN_ERROR: \"UNKNOWN_ERROR\",\n  NOT_IMPLEMENTED: \"NOT_IMPLEMENTED\",\n  UNSUPPORTED_OPERATION: \"UNSUPPORTED_OPERATION\",\n  NETWORK_ERROR: \"NETWORK_ERROR\",\n  SERVER_ERROR: \"SERVER_ERROR\",\n  TIMEOUT: \"TIMEOUT\",\n  BUFFER_OVERRUN: \"BUFFER_OVERRUN\",\n  NUMERIC_FAULT: \"NUMERIC_FAULT\",\n  MISSING_NEW: \"MISSING_NEW\",\n  INVALID_ARGUMENT: \"INVALID_ARGUMENT\",\n  MISSING_ARGUMENT: \"MISSING_ARGUMENT\",\n  UNEXPECTED_ARGUMENT: \"UNEXPECTED_ARGUMENT\",\n  CALL_EXCEPTION: \"CALL_EXCEPTION\",\n  INSUFFICIENT_FUNDS: \"INSUFFICIENT_FUNDS\",\n  NONCE_EXPIRED: \"NONCE_EXPIRED\",\n  REPLACEMENT_UNDERPRICED: \"REPLACEMENT_UNDERPRICED\",\n  UNPREDICTABLE_GAS_LIMIT: \"UNPREDICTABLE_GAS_LIMIT\"\n}, vt.levels = {\n  DEBUG: \"DEBUG\",\n  INFO: \"INFO\",\n  WARNING: \"WARNING\",\n  ERROR: \"ERROR\",\n  OFF: \"OFF\"\n};\nconst yt = new vt(\"bytes/5.0.0-beta.137\");\n\nfunction bt(t) {\n  return t.slice || (t.slice = function () {\n    const e = Array.prototype.slice.call(arguments);\n    return bt(new Uint8Array(Array.prototype.slice.apply(t, e)));\n  }), t;\n}\n\nfunction wt(t, e) {\n  if (e || (e = {}), \"number\" == typeof t) {\n    yt.checkSafeUint53(t, \"invalid arrayify value\");\n    const e = [];\n\n    for (; t;) e.unshift(255 & t), t = parseInt(String(t / 256));\n\n    return 0 === e.length && e.push(0), bt(new Uint8Array(e));\n  }\n\n  if (e.allowMissingPrefix && \"string\" == typeof t && \"0x\" !== t.substring(0, 2) && (t = \"0x\" + t), function (t) {\n    return !!t.toHexString;\n  }(t) && (t = t.toHexString()), function (t, e) {\n    if (\"string\" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/)) return !1;\n    if (e && t.length !== 2 + 2 * e) return !1;\n    return !0;\n  }(t)) {\n    let n = t.substring(2);\n    n.length % 2 && (\"left\" === e.hexPad ? n = \"0x0\" + n.substring(2) : \"right\" === e.hexPad ? n += \"0\" : yt.throwArgumentError(\"hex data is odd-length\", \"value\", t));\n    const r = [];\n\n    for (let t = 0; t < n.length; t += 2) r.push(parseInt(n.substring(t, t + 2), 16));\n\n    return bt(new Uint8Array(r));\n  }\n\n  return function (t) {\n    if (null == t) return !1;\n    if (t.constructor === Uint8Array) return !0;\n    if (\"string\" == typeof t) return !1;\n    if (null == t.length) return !1;\n\n    for (let e = 0; e < t.length; e++) {\n      const n = t[e];\n      if (n < 0 || n >= 256 || n % 1) return !1;\n    }\n\n    return !0;\n  }(t) ? bt(new Uint8Array(t)) : yt.throwArgumentError(\"invalid arrayify value\", \"value\", t);\n}\n\nvar Et = g(function (t) {\n  /**\n   * [js-sha3]{@link https://github.com/emn178/js-sha3}\n   *\n   * @version 0.5.7\n   * @author Chen, Yi-Cyuan [emn178@gmail.com]\n   * @copyright Chen, Yi-Cyuan 2015-2016\n   * @license MIT\n   */\n  !function () {\n    var e = \"object\" == typeof window ? window : {};\n    !e.JS_SHA3_NO_NODE_JS && \"object\" == typeof process && process.versions && process.versions.node && (e = d);\n\n    for (var n = !e.JS_SHA3_NO_COMMON_JS && t.exports, r = \"0123456789abcdef\".split(\"\"), o = [0, 8, 16, 24], i = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], s = [224, 256, 384, 512], c = [\"hex\", \"buffer\", \"arrayBuffer\", \"array\"], a = function (t, e, n) {\n      return function (r) {\n        return new b(t, e, t).update(r)[n]();\n      };\n    }, u = function (t, e, n) {\n      return function (r, o) {\n        return new b(t, e, o).update(r)[n]();\n      };\n    }, l = function (t, e) {\n      var n = a(t, e, \"hex\");\n      n.create = function () {\n        return new b(t, e, t);\n      }, n.update = function (t) {\n        return n.create().update(t);\n      };\n\n      for (var r = 0; r < c.length; ++r) {\n        var o = c[r];\n        n[o] = a(t, e, o);\n      }\n\n      return n;\n    }, h = [{\n      name: \"keccak\",\n      padding: [1, 256, 65536, 16777216],\n      bits: s,\n      createMethod: l\n    }, {\n      name: \"sha3\",\n      padding: [6, 1536, 393216, 100663296],\n      bits: s,\n      createMethod: l\n    }, {\n      name: \"shake\",\n      padding: [31, 7936, 2031616, 520093696],\n      bits: [128, 256],\n      createMethod: function (t, e) {\n        var n = u(t, e, \"hex\");\n        n.create = function (n) {\n          return new b(t, e, n);\n        }, n.update = function (t, e) {\n          return n.create(e).update(t);\n        };\n\n        for (var r = 0; r < c.length; ++r) {\n          var o = c[r];\n          n[o] = u(t, e, o);\n        }\n\n        return n;\n      }\n    }], f = {}, p = [], _ = 0; _ < h.length; ++_) for (var g = h[_], m = g.bits, v = 0; v < m.length; ++v) {\n      var y = g.name + \"_\" + m[v];\n      p.push(y), f[y] = g.createMethod(m[v], g.padding);\n    }\n\n    function b(t, e, n) {\n      this.blocks = [], this.s = [], this.padding = e, this.outputBits = n, this.reset = !0, this.block = 0, this.start = 0, this.blockCount = 1600 - (t << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = n >> 5, this.extraBytes = (31 & n) >> 3;\n\n      for (var r = 0; r < 50; ++r) this.s[r] = 0;\n    }\n\n    b.prototype.update = function (t) {\n      var e = \"string\" != typeof t;\n      e && t.constructor === ArrayBuffer && (t = new Uint8Array(t));\n\n      for (var n, r, i = t.length, s = this.blocks, c = this.byteCount, a = this.blockCount, u = 0, l = this.s; u < i;) {\n        if (this.reset) for (this.reset = !1, s[0] = this.block, n = 1; n < a + 1; ++n) s[n] = 0;\n        if (e) for (n = this.start; u < i && n < c; ++u) s[n >> 2] |= t[u] << o[3 & n++];else for (n = this.start; u < i && n < c; ++u) (r = t.charCodeAt(u)) < 128 ? s[n >> 2] |= r << o[3 & n++] : r < 2048 ? (s[n >> 2] |= (192 | r >> 6) << o[3 & n++], s[n >> 2] |= (128 | 63 & r) << o[3 & n++]) : r < 55296 || r >= 57344 ? (s[n >> 2] |= (224 | r >> 12) << o[3 & n++], s[n >> 2] |= (128 | r >> 6 & 63) << o[3 & n++], s[n >> 2] |= (128 | 63 & r) << o[3 & n++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & t.charCodeAt(++u)), s[n >> 2] |= (240 | r >> 18) << o[3 & n++], s[n >> 2] |= (128 | r >> 12 & 63) << o[3 & n++], s[n >> 2] |= (128 | r >> 6 & 63) << o[3 & n++], s[n >> 2] |= (128 | 63 & r) << o[3 & n++]);\n\n        if (this.lastByteIndex = n, n >= c) {\n          for (this.start = n - c, this.block = s[a], n = 0; n < a; ++n) l[n] ^= s[n];\n\n          w(l), this.reset = !0;\n        } else this.start = n;\n      }\n\n      return this;\n    }, b.prototype.finalize = function () {\n      var t = this.blocks,\n          e = this.lastByteIndex,\n          n = this.blockCount,\n          r = this.s;\n      if (t[e >> 2] |= this.padding[3 & e], this.lastByteIndex === this.byteCount) for (t[0] = t[n], e = 1; e < n + 1; ++e) t[e] = 0;\n\n      for (t[n - 1] |= 2147483648, e = 0; e < n; ++e) r[e] ^= t[e];\n\n      w(r);\n    }, b.prototype.toString = b.prototype.hex = function () {\n      this.finalize();\n\n      for (var t, e = this.blockCount, n = this.s, o = this.outputBlocks, i = this.extraBytes, s = 0, c = 0, a = \"\"; c < o;) {\n        for (s = 0; s < e && c < o; ++s, ++c) t = n[s], a += r[t >> 4 & 15] + r[15 & t] + r[t >> 12 & 15] + r[t >> 8 & 15] + r[t >> 20 & 15] + r[t >> 16 & 15] + r[t >> 28 & 15] + r[t >> 24 & 15];\n\n        c % e == 0 && (w(n), s = 0);\n      }\n\n      return i && (t = n[s], i > 0 && (a += r[t >> 4 & 15] + r[15 & t]), i > 1 && (a += r[t >> 12 & 15] + r[t >> 8 & 15]), i > 2 && (a += r[t >> 20 & 15] + r[t >> 16 & 15])), a;\n    }, b.prototype.arrayBuffer = function () {\n      this.finalize();\n      var t,\n          e = this.blockCount,\n          n = this.s,\n          r = this.outputBlocks,\n          o = this.extraBytes,\n          i = 0,\n          s = 0,\n          c = this.outputBits >> 3;\n      t = o ? new ArrayBuffer(r + 1 << 2) : new ArrayBuffer(c);\n\n      for (var a = new Uint32Array(t); s < r;) {\n        for (i = 0; i < e && s < r; ++i, ++s) a[s] = n[i];\n\n        s % e == 0 && w(n);\n      }\n\n      return o && (a[i] = n[i], t = t.slice(0, c)), t;\n    }, b.prototype.buffer = b.prototype.arrayBuffer, b.prototype.digest = b.prototype.array = function () {\n      this.finalize();\n\n      for (var t, e, n = this.blockCount, r = this.s, o = this.outputBlocks, i = this.extraBytes, s = 0, c = 0, a = []; c < o;) {\n        for (s = 0; s < n && c < o; ++s, ++c) t = c << 2, e = r[s], a[t] = 255 & e, a[t + 1] = e >> 8 & 255, a[t + 2] = e >> 16 & 255, a[t + 3] = e >> 24 & 255;\n\n        c % n == 0 && w(r);\n      }\n\n      return i && (t = c << 2, e = r[s], i > 0 && (a[t] = 255 & e), i > 1 && (a[t + 1] = e >> 8 & 255), i > 2 && (a[t + 2] = e >> 16 & 255)), a;\n    };\n\n    var w = function (t) {\n      var e, n, r, o, s, c, a, u, l, h, f, d, p, _, g, m, v, y, b, w, E, C, O, P, N, I, S, D, A, R, k, T, j, x, B, M, U, L, V, F, q, $, z, W, G, H, J, K, X, Y, Q, Z, tt, et, nt, rt, ot, it, st, ct, at, ut, lt;\n\n      for (r = 0; r < 48; r += 2) o = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], s = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], c = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42], a = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43], u = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], l = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], h = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], f = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], e = (d = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (c << 1 | a >>> 31), n = (p = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ (a << 1 | c >>> 31), t[0] ^= e, t[1] ^= n, t[10] ^= e, t[11] ^= n, t[20] ^= e, t[21] ^= n, t[30] ^= e, t[31] ^= n, t[40] ^= e, t[41] ^= n, e = o ^ (u << 1 | l >>> 31), n = s ^ (l << 1 | u >>> 31), t[2] ^= e, t[3] ^= n, t[12] ^= e, t[13] ^= n, t[22] ^= e, t[23] ^= n, t[32] ^= e, t[33] ^= n, t[42] ^= e, t[43] ^= n, e = c ^ (h << 1 | f >>> 31), n = a ^ (f << 1 | h >>> 31), t[4] ^= e, t[5] ^= n, t[14] ^= e, t[15] ^= n, t[24] ^= e, t[25] ^= n, t[34] ^= e, t[35] ^= n, t[44] ^= e, t[45] ^= n, e = u ^ (d << 1 | p >>> 31), n = l ^ (p << 1 | d >>> 31), t[6] ^= e, t[7] ^= n, t[16] ^= e, t[17] ^= n, t[26] ^= e, t[27] ^= n, t[36] ^= e, t[37] ^= n, t[46] ^= e, t[47] ^= n, e = h ^ (o << 1 | s >>> 31), n = f ^ (s << 1 | o >>> 31), t[8] ^= e, t[9] ^= n, t[18] ^= e, t[19] ^= n, t[28] ^= e, t[29] ^= n, t[38] ^= e, t[39] ^= n, t[48] ^= e, t[49] ^= n, _ = t[0], g = t[1], H = t[11] << 4 | t[10] >>> 28, J = t[10] << 4 | t[11] >>> 28, D = t[20] << 3 | t[21] >>> 29, A = t[21] << 3 | t[20] >>> 29, ct = t[31] << 9 | t[30] >>> 23, at = t[30] << 9 | t[31] >>> 23, $ = t[40] << 18 | t[41] >>> 14, z = t[41] << 18 | t[40] >>> 14, x = t[2] << 1 | t[3] >>> 31, B = t[3] << 1 | t[2] >>> 31, m = t[13] << 12 | t[12] >>> 20, v = t[12] << 12 | t[13] >>> 20, K = t[22] << 10 | t[23] >>> 22, X = t[23] << 10 | t[22] >>> 22, R = t[33] << 13 | t[32] >>> 19, k = t[32] << 13 | t[33] >>> 19, ut = t[42] << 2 | t[43] >>> 30, lt = t[43] << 2 | t[42] >>> 30, et = t[5] << 30 | t[4] >>> 2, nt = t[4] << 30 | t[5] >>> 2, M = t[14] << 6 | t[15] >>> 26, U = t[15] << 6 | t[14] >>> 26, y = t[25] << 11 | t[24] >>> 21, b = t[24] << 11 | t[25] >>> 21, Y = t[34] << 15 | t[35] >>> 17, Q = t[35] << 15 | t[34] >>> 17, T = t[45] << 29 | t[44] >>> 3, j = t[44] << 29 | t[45] >>> 3, P = t[6] << 28 | t[7] >>> 4, N = t[7] << 28 | t[6] >>> 4, rt = t[17] << 23 | t[16] >>> 9, ot = t[16] << 23 | t[17] >>> 9, L = t[26] << 25 | t[27] >>> 7, V = t[27] << 25 | t[26] >>> 7, w = t[36] << 21 | t[37] >>> 11, E = t[37] << 21 | t[36] >>> 11, Z = t[47] << 24 | t[46] >>> 8, tt = t[46] << 24 | t[47] >>> 8, W = t[8] << 27 | t[9] >>> 5, G = t[9] << 27 | t[8] >>> 5, I = t[18] << 20 | t[19] >>> 12, S = t[19] << 20 | t[18] >>> 12, it = t[29] << 7 | t[28] >>> 25, st = t[28] << 7 | t[29] >>> 25, F = t[38] << 8 | t[39] >>> 24, q = t[39] << 8 | t[38] >>> 24, C = t[48] << 14 | t[49] >>> 18, O = t[49] << 14 | t[48] >>> 18, t[0] = _ ^ ~m & y, t[1] = g ^ ~v & b, t[10] = P ^ ~I & D, t[11] = N ^ ~S & A, t[20] = x ^ ~M & L, t[21] = B ^ ~U & V, t[30] = W ^ ~H & K, t[31] = G ^ ~J & X, t[40] = et ^ ~rt & it, t[41] = nt ^ ~ot & st, t[2] = m ^ ~y & w, t[3] = v ^ ~b & E, t[12] = I ^ ~D & R, t[13] = S ^ ~A & k, t[22] = M ^ ~L & F, t[23] = U ^ ~V & q, t[32] = H ^ ~K & Y, t[33] = J ^ ~X & Q, t[42] = rt ^ ~it & ct, t[43] = ot ^ ~st & at, t[4] = y ^ ~w & C, t[5] = b ^ ~E & O, t[14] = D ^ ~R & T, t[15] = A ^ ~k & j, t[24] = L ^ ~F & $, t[25] = V ^ ~q & z, t[34] = K ^ ~Y & Z, t[35] = X ^ ~Q & tt, t[44] = it ^ ~ct & ut, t[45] = st ^ ~at & lt, t[6] = w ^ ~C & _, t[7] = E ^ ~O & g, t[16] = R ^ ~T & P, t[17] = k ^ ~j & N, t[26] = F ^ ~$ & x, t[27] = q ^ ~z & B, t[36] = Y ^ ~Z & W, t[37] = Q ^ ~tt & G, t[46] = ct ^ ~ut & et, t[47] = at ^ ~lt & nt, t[8] = C ^ ~_ & m, t[9] = O ^ ~g & v, t[18] = T ^ ~P & I, t[19] = j ^ ~N & S, t[28] = $ ^ ~x & M, t[29] = z ^ ~B & U, t[38] = Z ^ ~W & H, t[39] = tt ^ ~G & J, t[48] = ut ^ ~et & rt, t[49] = lt ^ ~nt & ot, t[0] ^= i[r], t[1] ^= i[r + 1];\n    };\n\n    if (n) t.exports = f;else for (_ = 0; _ < p.length; ++_) e[p[_]] = f[p[_]];\n  }();\n});\n\nfunction Ct() {\n  return (Ct = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction Ot(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction Pt(t) {\n  return (Pt = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction Nt(t, e) {\n  return (Nt = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction It() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction St(t, e, n) {\n  return (St = It() ? Reflect.construct : function (t, e, n) {\n    var r = [null];\n    r.push.apply(r, e);\n    var o = new (Function.bind.apply(t, r))();\n    return n && Nt(o, n.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction Dt(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (Dt = function (t) {\n    if (null === t || (n = t, -1 === Function.toString.call(n).indexOf(\"[native code]\"))) return t;\n    var n;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, r);\n    }\n\n    function r() {\n      return St(t, arguments, Pt(this).constructor);\n    }\n\n    return r.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: r,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), Nt(r, t);\n  })(t);\n}\n\n\"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")));\n\nfunction At(t, e) {\n  try {\n    var n = t();\n  } catch (t) {\n    return e(t);\n  }\n\n  return n && n.then ? n.then(void 0, e) : n;\n}\n\nfunction Rt(t) {\n  if (\"string\" == typeof t) {\n    t = t.replace(/^Ox/, \"0x\");\n    var e = Number.parseInt(t, \"0x\" === t.trim().substring(0, 2) ? 16 : 10);\n    return Number.isNaN(e) && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"chainId \" + t + \" is not an integer\") : ut(!1)), e;\n  }\n\n  return Number.isInteger(t) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"chainId \" + t + \" is not an integer\") : ut(!1)), t;\n}\n\nfunction kt(t) {\n  \"string\" == typeof t && t.match(/^(0x)?[0-9a-fA-F]{40}$/) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Invalid address \" + t) : ut(!1));\n\n  for (var e = \"0x\" === t.substring(0, 2) ? t : \"0x\" + t, n = e.toLowerCase().substring(2).split(\"\"), r = new Uint8Array(40), o = 0; o < 40; o++) r[o] = n[o].charCodeAt(0);\n\n  for (var i, s = wt((i = r, \"0x\" + Et.keccak_256(wt(i)))), c = 0; c < 40; c += 2) s[c >> 1] >> 4 >= 8 && (n[c] = n[c].toUpperCase()), (15 & s[c >> 1]) >= 8 && (n[c + 1] = n[c + 1].toUpperCase());\n\n  var a = \"0x\" + n.join(\"\");\n  return e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== a && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Bad address checksum \" + e + \" \" + a) : ut(!1)), a;\n}\n\nvar Tt,\n    jt = function (t, e) {\n  try {\n    var n = function (n) {\n      return Promise.resolve(Promise.all([void 0 === e.chainId ? t.getChainId() : e.chainId, void 0 === e.account ? t.getAccount() : e.account])).then(function (e) {\n        var r = e[0],\n            o = e[1],\n            i = Rt(r);\n        if (t.supportedChainIds && !t.supportedChainIds.includes(i)) throw new Bt(i, t.supportedChainIds);\n        var s = null === o ? o : kt(o);\n        return {\n          provider: n,\n          chainId: i,\n          account: s\n        };\n      });\n    },\n        r = void 0 === e.provider;\n\n    return Promise.resolve(r ? Promise.resolve(t.getProvider()).then(n) : n(e.provider));\n  } catch (t) {\n    return Promise.reject(t);\n  }\n},\n    xt = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e;\n  }\n\n  return Ot(e, t), e;\n}(Dt(Error)),\n    Bt = function (t) {\n  function e(e, n) {\n    var r;\n    return (r = t.call(this) || this).name = r.constructor.name, r.message = \"Unsupported chain id: \" + e + \". Supported chain ids are: \" + n + \".\", r;\n  }\n\n  return Ot(e, t), e;\n}(Dt(Error));\n\nfunction Mt(t, e) {\n  var n = e.type,\n      r = e.payload;\n\n  switch (n) {\n    case Tt.ACTIVATE_CONNECTOR:\n      return {\n        connector: r.connector,\n        provider: r.provider,\n        chainId: r.chainId,\n        account: r.account,\n        onError: r.onError\n      };\n\n    case Tt.UPDATE:\n      var o = r.provider,\n          i = r.chainId,\n          s = r.account;\n      return Ct({}, t, void 0 === o ? {} : {\n        provider: o\n      }, void 0 === i ? {} : {\n        chainId: i\n      }, void 0 === s ? {} : {\n        account: s\n      });\n\n    case Tt.UPDATE_FROM_ERROR:\n      var c = r.provider,\n          a = r.chainId,\n          u = r.account;\n      return Ct({}, t, void 0 === c ? {} : {\n        provider: c\n      }, void 0 === a ? {} : {\n        chainId: a\n      }, void 0 === u ? {} : {\n        account: u\n      }, {\n        error: void 0\n      });\n\n    case Tt.ERROR:\n      var l = r.error;\n      return {\n        connector: t.connector,\n        error: l,\n        onError: t.onError\n      };\n\n    case Tt.ERROR_FROM_ACTIVATION:\n      return {\n        connector: r.connector,\n        error: r.error\n      };\n\n    case Tt.DEACTIVATE_CONNECTOR:\n      return {};\n  }\n}\n\n!function (t) {\n  t[t.ACTIVATE_CONNECTOR = 0] = \"ACTIVATE_CONNECTOR\", t[t.UPDATE = 1] = \"UPDATE\", t[t.UPDATE_FROM_ERROR = 2] = \"UPDATE_FROM_ERROR\", t[t.ERROR = 3] = \"ERROR\", t[t.ERROR_FROM_ACTIVATION = 4] = \"ERROR_FROM_ACTIVATION\", t[t.DEACTIVATE_CONNECTOR = 5] = \"DEACTIVATE_CONNECTOR\";\n}(Tt || (Tt = {}));\nvar Ut = {};\n\nfunction Lt(n) {\n  Ut[n] && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"A root already exists for provided key \" + n) : ut(!1)), Ut[n] = c({\n    activate: function () {\n      try {\n        return \"production\" !== process.env.NODE_ENV ? ut(!1, \"No <Web3ReactProvider ... /> found.\") : ut(!1), Promise.resolve();\n      } catch (t) {\n        return Promise.reject(t);\n      }\n    },\n    setError: function () {\n      \"production\" !== process.env.NODE_ENV ? ut(!1, \"No <Web3ReactProvider ... /> found.\") : ut(!1);\n    },\n    deactivate: function () {\n      \"production\" !== process.env.NODE_ENV ? ut(!1, \"No <Web3ReactProvider ... /> found.\") : ut(!1);\n    },\n    active: !1\n  }), Ut[n].displayName = \"Web3ReactContext - \" + n;\n  var a = Ut[n].Provider;\n  return function (n) {\n    var c = n.getLibrary,\n        u = n.children,\n        l = function () {\n      var t = r(Mt, {}),\n          e = t[0],\n          n = t[1],\n          c = e.connector,\n          a = e.provider,\n          u = e.chainId,\n          l = e.account,\n          h = e.onError,\n          f = e.error,\n          d = o(-1);\n      d.current += 1;\n\n      var p = i(function (t, e, r) {\n        void 0 === r && (r = !1);\n\n        try {\n          var o = d.current,\n              i = !1;\n          return Promise.resolve(At(function () {\n            return Promise.resolve(t.activate().then(function (t) {\n              return i = !0, t;\n            })).then(function (r) {\n              return Promise.resolve(jt(t, r)).then(function (r) {\n                if (d.current > o) throw new xt();\n                n({\n                  type: Tt.ACTIVATE_CONNECTOR,\n                  payload: Ct({\n                    connector: t\n                  }, r, {\n                    onError: e\n                  })\n                });\n              });\n            });\n          }, function (o) {\n            if (o instanceof xt) i && t.deactivate(), \"production\" !== process.env.NODE_ENV && ht(!1, \"Suppressed stale connector activation \" + t);else {\n              if (r) throw i && t.deactivate(), o;\n              e ? (i && t.deactivate(), e(o)) : n({\n                type: Tt.ERROR_FROM_ACTIVATION,\n                payload: {\n                  connector: t,\n                  error: o\n                }\n              });\n            }\n          }));\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, []),\n          _ = i(function (t) {\n        n({\n          type: Tt.ERROR,\n          payload: {\n            error: t\n          }\n        });\n      }, []),\n          g = i(function () {\n        n({\n          type: Tt.DEACTIVATE_CONNECTOR\n        });\n      }, []),\n          m = i(function (t) {\n        try {\n          if (!c) throw Error(\"This should never happen, it's just so Typescript stops complaining\");\n          var e = d.current;\n          return Promise.resolve(function () {\n            if (f) return At(function () {\n              return Promise.resolve(jt(c, t)).then(function (t) {\n                if (d.current > e) throw new xt();\n                n({\n                  type: Tt.UPDATE_FROM_ERROR,\n                  payload: t\n                });\n              });\n            }, function (e) {\n              e instanceof xt ? \"production\" !== process.env.NODE_ENV && ht(!1, \"Suppressed stale connector update from error state \" + c + \" \" + t) : h ? h(e) : n({\n                type: Tt.ERROR,\n                payload: {\n                  error: e\n                }\n              });\n            });\n            var r = void 0 === t.chainId ? void 0 : Rt(t.chainId);\n\n            if (void 0 !== r && c.supportedChainIds && !c.supportedChainIds.includes(r)) {\n              var o = new Bt(r, c.supportedChainIds);\n              h ? h(o) : n({\n                type: Tt.ERROR,\n                payload: {\n                  error: o\n                }\n              });\n            } else {\n              var i = \"string\" == typeof t.account ? kt(t.account) : t.account;\n              n({\n                type: Tt.UPDATE,\n                payload: {\n                  provider: t.provider,\n                  chainId: r,\n                  account: i\n                }\n              });\n            }\n          }());\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, [c, f, h]),\n          v = i(function (t) {\n        h ? h(t) : n({\n          type: Tt.ERROR,\n          payload: {\n            error: t\n          }\n        });\n      }, [h]),\n          y = i(function () {\n        n({\n          type: Tt.DEACTIVATE_CONNECTOR\n        });\n      }, []);\n\n      return s(function () {\n        return function () {\n          c && c.deactivate();\n        };\n      }, [c]), s(function () {\n        return c && c.on(st.Update, m).on(st.Error, v).on(st.Deactivate, y), function () {\n          c && c.off(st.Update, m).off(st.Error, v).off(st.Deactivate, y);\n        };\n      }, [c, m, v, y]), {\n        connector: c,\n        provider: a,\n        chainId: u,\n        account: l,\n        activate: p,\n        setError: _,\n        deactivate: g,\n        error: f\n      };\n    }(),\n        h = l.connector,\n        f = l.provider,\n        d = l.chainId,\n        p = l.account,\n        _ = l.activate,\n        g = l.setError,\n        m = l.deactivate,\n        v = l.error,\n        y = void 0 !== h && void 0 !== d && void 0 !== p && !v,\n        b = e(function () {\n      return y && void 0 !== d && Number.isInteger(d) && h ? c(f, h) : void 0;\n    }, [y, c, f, h, d]),\n        w = {\n      connector: h,\n      library: b,\n      chainId: d,\n      account: p,\n      activate: _,\n      setError: g,\n      deactivate: m,\n      active: y,\n      error: v\n    };\n\n    return t.createElement(a, {\n      value: w\n    }, u);\n  };\n}\n\nvar Vt = Lt(\"primary\");\n\nfunction Ft(t) {\n  return n(function (t) {\n    return void 0 === t && (t = \"primary\"), Object.keys(Ut).includes(t) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Invalid key \" + t) : ut(!1)), Ut[t];\n  }(t));\n}\n\nclass qt extends Array {\n  constructor(t, e) {\n    if (t > qt.__kMaxLength) throw new RangeError(\"Maximum BigInt size exceeded\");\n    super(t), this.sign = e;\n  }\n\n  static BigInt(t) {\n    var e = Math.floor,\n        n = Number.isFinite;\n\n    if (\"number\" == typeof t) {\n      if (0 === t) return qt.__zero();\n      if ((0 | t) === t) return 0 > t ? qt.__oneDigit(-t, !0) : qt.__oneDigit(t, !1);\n      if (!n(t) || e(t) !== t) throw new RangeError(\"The number \" + t + \" cannot be converted to BigInt because it is not an integer\");\n      return qt.__fromDouble(t);\n    }\n\n    if (\"string\" == typeof t) {\n      const e = qt.__fromString(t);\n\n      if (null === e) throw new SyntaxError(\"Cannot convert \" + t + \" to a BigInt\");\n      return e;\n    }\n\n    if (\"boolean\" == typeof t) return !0 === t ? qt.__oneDigit(1, !1) : qt.__zero();\n\n    if (\"object\" == typeof t) {\n      if (t.constructor === qt) return t;\n\n      const e = qt.__toPrimitive(t);\n\n      return qt.BigInt(e);\n    }\n\n    throw new TypeError(\"Cannot convert \" + t + \" to a BigInt\");\n  }\n\n  toDebugString() {\n    const t = [\"BigInt[\"];\n\n    for (const e of this) t.push((e ? (e >>> 0).toString(16) : e) + \", \");\n\n    return t.push(\"]\"), t.join(\"\");\n  }\n\n  toString(t = 10) {\n    if (2 > t || 36 < t) throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n    return 0 === this.length ? \"0\" : 0 == (t & t - 1) ? qt.__toStringBasePowerOfTwo(this, t) : qt.__toStringGeneric(this, t, !1);\n  }\n\n  static toNumber(t) {\n    var e = Math.clz32;\n    const n = t.length;\n    if (0 === n) return 0;\n\n    if (1 === n) {\n      const e = t.__unsignedDigit(0);\n\n      return t.sign ? -e : e;\n    }\n\n    const r = t.__digit(n - 1),\n          o = e(r),\n          i = 32 * n - o;\n\n    if (1024 < i) return t.sign ? -1 / 0 : 1 / 0;\n    let s = i - 1,\n        c = r,\n        a = n - 1;\n    const u = o + 1;\n    let l = 32 === u ? 0 : c << u;\n    l >>>= 12;\n    const h = u - 12;\n    let f = 12 <= u ? 0 : c << 20 + u,\n        d = 20 + u;\n    0 < h && 0 < a && (a--, c = t.__digit(a), l |= c >>> 32 - h, f = c << h, d = h), 0 < d && 0 < a && (a--, c = t.__digit(a), f |= c >>> 32 - d, d -= 32);\n\n    const p = qt.__decideRounding(t, d, a, c);\n\n    if ((1 === p || 0 === p && 1 == (1 & f)) && (f = f + 1 >>> 0, 0 == f && (l++, 0 != l >>> 20 && (l = 0, s++, 1023 < s)))) return t.sign ? -1 / 0 : 1 / 0;\n\n    const _ = t.sign ? -2147483648 : 0;\n\n    return s = s + 1023 << 20, qt.__kBitConversionInts[1] = _ | s | l, qt.__kBitConversionInts[0] = f, qt.__kBitConversionDouble[0];\n  }\n\n  static unaryMinus(t) {\n    if (0 === t.length) return t;\n\n    const e = t.__copy();\n\n    return e.sign = !t.sign, e;\n  }\n\n  static bitwiseNot(t) {\n    return t.sign ? qt.__absoluteSubOne(t).__trim() : qt.__absoluteAddOne(t, !0);\n  }\n\n  static exponentiate(t, e) {\n    if (e.sign) throw new RangeError(\"Exponent must be positive\");\n    if (0 === e.length) return qt.__oneDigit(1, !1);\n    if (0 === t.length) return t;\n    if (1 === t.length && 1 === t.__digit(0)) return t.sign && 0 == (1 & e.__digit(0)) ? qt.unaryMinus(t) : t;\n    if (1 < e.length) throw new RangeError(\"BigInt too big\");\n\n    let n = e.__unsignedDigit(0);\n\n    if (1 === n) return t;\n    if (n >= qt.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n\n    if (1 === t.length && 2 === t.__digit(0)) {\n      const e = 1 + (n >>> 5),\n            r = t.sign && 0 != (1 & n),\n            o = new qt(e, r);\n\n      o.__initializeDigits();\n\n      const i = 1 << (31 & n);\n      return o.__setDigit(e - 1, i), o;\n    }\n\n    let r = null,\n        o = t;\n\n    for (0 != (1 & n) && (r = t), n >>= 1; 0 !== n; n >>= 1) o = qt.multiply(o, o), 0 != (1 & n) && (r = null === r ? o : qt.multiply(r, o));\n\n    return r;\n  }\n\n  static multiply(t, e) {\n    if (0 === t.length) return t;\n    if (0 === e.length) return e;\n    let n = t.length + e.length;\n    32 <= t.__clzmsd() + e.__clzmsd() && n--;\n    const r = new qt(n, t.sign !== e.sign);\n\n    r.__initializeDigits();\n\n    for (let n = 0; n < t.length; n++) qt.__multiplyAccumulate(e, t.__digit(n), r, n);\n\n    return r.__trim();\n  }\n\n  static divide(t, e) {\n    if (0 === e.length) throw new RangeError(\"Division by zero\");\n    if (0 > qt.__absoluteCompare(t, e)) return qt.__zero();\n\n    const n = t.sign !== e.sign,\n          r = e.__unsignedDigit(0);\n\n    let o;\n\n    if (1 === e.length && 65535 >= r) {\n      if (1 === r) return n === t.sign ? t : qt.unaryMinus(t);\n      o = qt.__absoluteDivSmall(t, r, null);\n    } else o = qt.__absoluteDivLarge(t, e, !0, !1);\n\n    return o.sign = n, o.__trim();\n  }\n\n  static remainder(t, e) {\n    if (0 === e.length) throw new RangeError(\"Division by zero\");\n    if (0 > qt.__absoluteCompare(t, e)) return t;\n\n    const n = e.__unsignedDigit(0);\n\n    if (1 === e.length && 65535 >= n) {\n      if (1 === n) return qt.__zero();\n\n      const e = qt.__absoluteModSmall(t, n);\n\n      return 0 === e ? qt.__zero() : qt.__oneDigit(e, t.sign);\n    }\n\n    const r = qt.__absoluteDivLarge(t, e, !1, !0);\n\n    return r.sign = t.sign, r.__trim();\n  }\n\n  static add(t, e) {\n    const n = t.sign;\n    return n === e.sign ? qt.__absoluteAdd(t, e, n) : 0 <= qt.__absoluteCompare(t, e) ? qt.__absoluteSub(t, e, n) : qt.__absoluteSub(e, t, !n);\n  }\n\n  static subtract(t, e) {\n    const n = t.sign;\n    return n === e.sign ? 0 <= qt.__absoluteCompare(t, e) ? qt.__absoluteSub(t, e, n) : qt.__absoluteSub(e, t, !n) : qt.__absoluteAdd(t, e, n);\n  }\n\n  static leftShift(t, e) {\n    return 0 === e.length || 0 === t.length ? t : e.sign ? qt.__rightShiftByAbsolute(t, e) : qt.__leftShiftByAbsolute(t, e);\n  }\n\n  static signedRightShift(t, e) {\n    return 0 === e.length || 0 === t.length ? t : e.sign ? qt.__leftShiftByAbsolute(t, e) : qt.__rightShiftByAbsolute(t, e);\n  }\n\n  static unsignedRightShift() {\n    throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\");\n  }\n\n  static lessThan(t, e) {\n    return 0 > qt.__compareToBigInt(t, e);\n  }\n\n  static lessThanOrEqual(t, e) {\n    return 0 >= qt.__compareToBigInt(t, e);\n  }\n\n  static greaterThan(t, e) {\n    return 0 < qt.__compareToBigInt(t, e);\n  }\n\n  static greaterThanOrEqual(t, e) {\n    return 0 <= qt.__compareToBigInt(t, e);\n  }\n\n  static equal(t, e) {\n    if (t.sign !== e.sign) return !1;\n    if (t.length !== e.length) return !1;\n\n    for (let n = 0; n < t.length; n++) if (t.__digit(n) !== e.__digit(n)) return !1;\n\n    return !0;\n  }\n\n  static notEqual(t, e) {\n    return !qt.equal(t, e);\n  }\n\n  static bitwiseAnd(t, e) {\n    var n = Math.max;\n    if (!t.sign && !e.sign) return qt.__absoluteAnd(t, e).__trim();\n\n    if (t.sign && e.sign) {\n      const r = n(t.length, e.length) + 1;\n\n      let o = qt.__absoluteSubOne(t, r);\n\n      const i = qt.__absoluteSubOne(e);\n\n      return o = qt.__absoluteOr(o, i, o), qt.__absoluteAddOne(o, !0, o).__trim();\n    }\n\n    return t.sign && ([t, e] = [e, t]), qt.__absoluteAndNot(t, qt.__absoluteSubOne(e)).__trim();\n  }\n\n  static bitwiseXor(t, e) {\n    var n = Math.max;\n    if (!t.sign && !e.sign) return qt.__absoluteXor(t, e).__trim();\n\n    if (t.sign && e.sign) {\n      const r = n(t.length, e.length),\n            o = qt.__absoluteSubOne(t, r),\n            i = qt.__absoluteSubOne(e);\n\n      return qt.__absoluteXor(o, i, o).__trim();\n    }\n\n    const r = n(t.length, e.length) + 1;\n    t.sign && ([t, e] = [e, t]);\n\n    let o = qt.__absoluteSubOne(e, r);\n\n    return o = qt.__absoluteXor(o, t, o), qt.__absoluteAddOne(o, !0, o).__trim();\n  }\n\n  static bitwiseOr(t, e) {\n    const n = (0, Math.max)(t.length, e.length);\n    if (!t.sign && !e.sign) return qt.__absoluteOr(t, e).__trim();\n\n    if (t.sign && e.sign) {\n      let r = qt.__absoluteSubOne(t, n);\n\n      const o = qt.__absoluteSubOne(e);\n\n      return r = qt.__absoluteAnd(r, o, r), qt.__absoluteAddOne(r, !0, r).__trim();\n    }\n\n    t.sign && ([t, e] = [e, t]);\n\n    let r = qt.__absoluteSubOne(e, n);\n\n    return r = qt.__absoluteAndNot(r, t, r), qt.__absoluteAddOne(r, !0, r).__trim();\n  }\n\n  static asIntN(t, e) {\n    if (0 === e.length) return e;\n    if (0 === t) return qt.__zero();\n    if (t >= qt.__kMaxLengthBits) return e;\n    const n = t + 31 >>> 5;\n    if (e.length < n) return e;\n\n    const r = e.__unsignedDigit(n - 1),\n          o = 1 << (31 & t - 1);\n\n    if (e.length === n && r < o) return e;\n    if ((r & o) !== o) return qt.__truncateToNBits(t, e);\n    if (!e.sign) return qt.__truncateAndSubFromPowerOfTwo(t, e, !0);\n\n    if (0 == (r & o - 1)) {\n      for (let r = n - 2; 0 <= r; r--) if (0 !== e.__digit(r)) return qt.__truncateAndSubFromPowerOfTwo(t, e, !1);\n\n      return e.length === n && r === o ? e : qt.__truncateToNBits(t, e);\n    }\n\n    return qt.__truncateAndSubFromPowerOfTwo(t, e, !1);\n  }\n\n  static asUintN(t, e) {\n    if (0 === e.length) return e;\n    if (0 === t) return qt.__zero();\n\n    if (e.sign) {\n      if (t > qt.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n      return qt.__truncateAndSubFromPowerOfTwo(t, e, !1);\n    }\n\n    if (t >= qt.__kMaxLengthBits) return e;\n    const n = t + 31 >>> 5;\n    if (e.length < n) return e;\n    const r = 31 & t;\n\n    if (e.length == n) {\n      if (0 == r) return e;\n      if (0 == e.__digit(n - 1) >>> r) return e;\n    }\n\n    return qt.__truncateToNBits(t, e);\n  }\n\n  static ADD(t, e) {\n    if (t = qt.__toPrimitive(t), e = qt.__toPrimitive(e), \"string\" == typeof t) return \"string\" != typeof e && (e = e.toString()), t + e;\n    if (\"string\" == typeof e) return t.toString() + e;\n    if (t = qt.__toNumeric(t), e = qt.__toNumeric(e), qt.__isBigInt(t) && qt.__isBigInt(e)) return qt.add(t, e);\n    if (\"number\" == typeof t && \"number\" == typeof e) return t + e;\n    throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\");\n  }\n\n  static LT(t, e) {\n    return qt.__compare(t, e, 0);\n  }\n\n  static LE(t, e) {\n    return qt.__compare(t, e, 1);\n  }\n\n  static GT(t, e) {\n    return qt.__compare(t, e, 2);\n  }\n\n  static GE(t, e) {\n    return qt.__compare(t, e, 3);\n  }\n\n  static EQ(t, e) {\n    for (;;) {\n      if (qt.__isBigInt(t)) return qt.__isBigInt(e) ? qt.equal(t, e) : qt.EQ(e, t);\n\n      if (\"number\" == typeof t) {\n        if (qt.__isBigInt(e)) return qt.__equalToNumber(e, t);\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else if (\"string\" == typeof t) {\n        if (qt.__isBigInt(e)) return null !== (t = qt.__fromString(t)) && qt.equal(t, e);\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else if (\"boolean\" == typeof t) {\n        if (qt.__isBigInt(e)) return qt.__equalToNumber(e, +t);\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else if (\"symbol\" == typeof t) {\n        if (qt.__isBigInt(e)) return !1;\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else {\n        if (\"object\" != typeof t) return t == e;\n        if (\"object\" == typeof e && e.constructor !== qt) return t == e;\n        t = qt.__toPrimitive(t);\n      }\n    }\n  }\n\n  static NE(t, e) {\n    return !qt.EQ(t, e);\n  }\n\n  static __zero() {\n    return new qt(0, !1);\n  }\n\n  static __oneDigit(t, e) {\n    const n = new qt(1, e);\n    return n.__setDigit(0, t), n;\n  }\n\n  __copy() {\n    const t = new qt(this.length, this.sign);\n\n    for (let e = 0; e < this.length; e++) t[e] = this[e];\n\n    return t;\n  }\n\n  __trim() {\n    let t = this.length,\n        e = this[t - 1];\n\n    for (; 0 === e;) t--, e = this[t - 1], this.pop();\n\n    return 0 === t && (this.sign = !1), this;\n  }\n\n  __initializeDigits() {\n    for (let t = 0; t < this.length; t++) this[t] = 0;\n  }\n\n  static __decideRounding(t, e, n, r) {\n    if (0 < e) return -1;\n    let o;\n    if (0 > e) o = -e - 1;else {\n      if (0 === n) return -1;\n      n--, r = t.__digit(n), o = 31;\n    }\n    let i = 1 << o;\n    if (0 == (r & i)) return -1;\n    if (i -= 1, 0 != (r & i)) return 1;\n\n    for (; 0 < n;) if (n--, 0 !== t.__digit(n)) return 1;\n\n    return 0;\n  }\n\n  static __fromDouble(t) {\n    qt.__kBitConversionDouble[0] = t;\n    const e = (2047 & qt.__kBitConversionInts[1] >>> 20) - 1023,\n          n = 1 + (e >>> 5),\n          r = new qt(n, 0 > t);\n    let o = 1048575 & qt.__kBitConversionInts[1] | 1048576,\n        i = qt.__kBitConversionInts[0];\n    const s = 31 & e;\n    let c,\n        a = 0;\n\n    if (s < 20) {\n      const t = 20 - s;\n      a = t + 32, c = o >>> t, o = o << 32 - t | i >>> t, i <<= 32 - t;\n    } else if (20 === s) a = 32, c = o, o = i;else {\n      const t = s - 20;\n      a = 32 - t, c = o << t | i >>> 32 - t, o = i << t;\n    }\n\n    r.__setDigit(n - 1, c);\n\n    for (let t = n - 2; 0 <= t; t--) 0 < a ? (a -= 32, c = o, o = i) : c = 0, r.__setDigit(t, c);\n\n    return r.__trim();\n  }\n\n  static __isWhitespace(t) {\n    return !!(13 >= t && 9 <= t) || (159 >= t ? 32 == t : 131071 >= t ? 160 == t || 5760 == t : 196607 >= t ? 10 >= (t &= 131071) || 40 == t || 41 == t || 47 == t || 95 == t || 4096 == t : 65279 == t);\n  }\n\n  static __fromString(t, e = 0) {\n    let n = 0;\n    const r = t.length;\n    let o = 0;\n    if (o === r) return qt.__zero();\n    let i = t.charCodeAt(o);\n\n    for (; qt.__isWhitespace(i);) {\n      if (++o === r) return qt.__zero();\n      i = t.charCodeAt(o);\n    }\n\n    if (43 === i) {\n      if (++o === r) return null;\n      i = t.charCodeAt(o), n = 1;\n    } else if (45 === i) {\n      if (++o === r) return null;\n      i = t.charCodeAt(o), n = -1;\n    }\n\n    if (0 === e) {\n      if (e = 10, 48 === i) {\n        if (++o === r) return qt.__zero();\n\n        if (i = t.charCodeAt(o), 88 === i || 120 === i) {\n          if (e = 16, ++o === r) return null;\n          i = t.charCodeAt(o);\n        } else if (79 === i || 111 === i) {\n          if (e = 8, ++o === r) return null;\n          i = t.charCodeAt(o);\n        } else if (66 === i || 98 === i) {\n          if (e = 2, ++o === r) return null;\n          i = t.charCodeAt(o);\n        }\n      }\n    } else if (16 === e && 48 === i) {\n      if (++o === r) return qt.__zero();\n\n      if (i = t.charCodeAt(o), 88 === i || 120 === i) {\n        if (++o === r) return null;\n        i = t.charCodeAt(o);\n      }\n    }\n\n    for (; 48 === i;) {\n      if (++o === r) return qt.__zero();\n      i = t.charCodeAt(o);\n    }\n\n    const s = r - o;\n    let c = qt.__kMaxBitsPerChar[e],\n        a = qt.__kBitsPerCharTableMultiplier - 1;\n    if (s > 1073741824 / c) return null;\n    const u = c * s + a >>> qt.__kBitsPerCharTableShift,\n          l = new qt(u + 31 >>> 5, !1),\n          h = 10 > e ? e : 10,\n          f = 10 < e ? e - 10 : 0;\n\n    if (0 == (e & e - 1)) {\n      c >>= qt.__kBitsPerCharTableShift;\n      const e = [],\n            n = [];\n      let s = !1;\n\n      do {\n        let a = 0,\n            u = 0;\n\n        for (;;) {\n          let e;\n          if (i - 48 >>> 0 < h) e = i - 48;else {\n            if (!((32 | i) - 97 >>> 0 < f)) {\n              s = !0;\n              break;\n            }\n\n            e = (32 | i) - 87;\n          }\n\n          if (u += c, a = a << c | e, ++o === r) {\n            s = !0;\n            break;\n          }\n\n          if (i = t.charCodeAt(o), 32 < u + c) break;\n        }\n\n        e.push(a), n.push(u);\n      } while (!s);\n\n      qt.__fillFromParts(l, e, n);\n    } else {\n      l.__initializeDigits();\n\n      let n = !1,\n          s = 0;\n\n      do {\n        let u = 0,\n            d = 1;\n\n        for (;;) {\n          let c;\n          if (i - 48 >>> 0 < h) c = i - 48;else {\n            if (!((32 | i) - 97 >>> 0 < f)) {\n              n = !0;\n              break;\n            }\n\n            c = (32 | i) - 87;\n          }\n          const a = d * e;\n          if (4294967295 < a) break;\n\n          if (d = a, u = u * e + c, s++, ++o === r) {\n            n = !0;\n            break;\n          }\n\n          i = t.charCodeAt(o);\n        }\n\n        a = 32 * qt.__kBitsPerCharTableMultiplier - 1;\n        const p = c * s + a >>> qt.__kBitsPerCharTableShift + 5;\n\n        l.__inplaceMultiplyAdd(d, u, p);\n      } while (!n);\n    }\n\n    if (o !== r) {\n      if (!qt.__isWhitespace(i)) return null;\n\n      for (o++; o < r; o++) if (i = t.charCodeAt(o), !qt.__isWhitespace(i)) return null;\n    }\n\n    return 0 != n && 10 !== e ? null : (l.sign = -1 == n, l.__trim());\n  }\n\n  static __fillFromParts(t, e, n) {\n    let r = 0,\n        o = 0,\n        i = 0;\n\n    for (let s = e.length - 1; 0 <= s; s--) {\n      const c = e[s],\n            a = n[s];\n      o |= c << i, i += a, 32 === i ? (t.__setDigit(r++, o), i = 0, o = 0) : 32 < i && (t.__setDigit(r++, o), i -= 32, o = c >>> a - i);\n    }\n\n    if (0 !== o) {\n      if (r >= t.length) throw new Error(\"implementation bug\");\n\n      t.__setDigit(r++, o);\n    }\n\n    for (; r < t.length; r++) t.__setDigit(r, 0);\n  }\n\n  static __toStringBasePowerOfTwo(t, e) {\n    var n = Math.clz32;\n    const r = t.length;\n    let o = e - 1;\n    o = (85 & o >>> 1) + (85 & o), o = (51 & o >>> 2) + (51 & o), o = (15 & o >>> 4) + (15 & o);\n\n    const i = o,\n          s = e - 1,\n          c = t.__digit(r - 1);\n\n    let a = 0 | (32 * r - n(c) + i - 1) / i;\n    if (t.sign && a++, 268435456 < a) throw new Error(\"string too long\");\n    const u = Array(a);\n    let l = a - 1,\n        h = 0,\n        f = 0;\n\n    for (let e = 0; e < r - 1; e++) {\n      const n = t.__digit(e),\n            r = (h | n << f) & s;\n\n      u[l--] = qt.__kConversionChars[r];\n      const o = i - f;\n\n      for (h = n >>> o, f = 32 - o; f >= i;) u[l--] = qt.__kConversionChars[h & s], h >>>= i, f -= i;\n    }\n\n    const d = (h | c << f) & s;\n\n    for (u[l--] = qt.__kConversionChars[d], h = c >>> i - f; 0 !== h;) u[l--] = qt.__kConversionChars[h & s], h >>>= i;\n\n    if (t.sign && (u[l--] = \"-\"), -1 != l) throw new Error(\"implementation bug\");\n    return u.join(\"\");\n  }\n\n  static __toStringGeneric(t, e, n) {\n    var r = Math.clz32;\n    const o = t.length;\n    if (0 === o) return \"\";\n\n    if (1 === o) {\n      let r = t.__unsignedDigit(0).toString(e);\n\n      return !1 === n && t.sign && (r = \"-\" + r), r;\n    }\n\n    const i = 32 * o - r(t.__digit(o - 1)),\n          s = qt.__kMaxBitsPerChar[e] - 1;\n    let c = i * qt.__kBitsPerCharTableMultiplier;\n    c += s - 1, c = 0 | c / s;\n    const a = c + 1 >> 1,\n          u = qt.exponentiate(qt.__oneDigit(e, !1), qt.__oneDigit(a, !1));\n    let l, h;\n\n    const f = u.__unsignedDigit(0);\n\n    if (1 === u.length && 65535 >= f) {\n      l = new qt(t.length, !1), l.__initializeDigits();\n      let n = 0;\n\n      for (let e = 2 * t.length - 1; 0 <= e; e--) {\n        const r = n << 16 | t.__halfDigit(e);\n\n        l.__setHalfDigit(e, 0 | r / f), n = 0 | r % f;\n      }\n\n      h = n.toString(e);\n    } else {\n      const n = qt.__absoluteDivLarge(t, u, !0, !0);\n\n      l = n.quotient;\n\n      const r = n.remainder.__trim();\n\n      h = qt.__toStringGeneric(r, e, !0);\n    }\n\n    l.__trim();\n\n    let d = qt.__toStringGeneric(l, e, !0);\n\n    for (; h.length < a;) h = \"0\" + h;\n\n    return !1 === n && t.sign && (d = \"-\" + d), d + h;\n  }\n\n  static __unequalSign(t) {\n    return t ? -1 : 1;\n  }\n\n  static __absoluteGreater(t) {\n    return t ? -1 : 1;\n  }\n\n  static __absoluteLess(t) {\n    return t ? 1 : -1;\n  }\n\n  static __compareToBigInt(t, e) {\n    const n = t.sign;\n    if (n !== e.sign) return qt.__unequalSign(n);\n\n    const r = qt.__absoluteCompare(t, e);\n\n    return 0 < r ? qt.__absoluteGreater(n) : 0 > r ? qt.__absoluteLess(n) : 0;\n  }\n\n  static __compareToNumber(t, e) {\n    if (!0 | e) {\n      const n = t.sign,\n            r = 0 > e;\n      if (n !== r) return qt.__unequalSign(n);\n\n      if (0 === t.length) {\n        if (r) throw new Error(\"implementation bug\");\n        return 0 === e ? 0 : -1;\n      }\n\n      if (1 < t.length) return qt.__absoluteGreater(n);\n\n      const o = Math.abs(e),\n            i = t.__unsignedDigit(0);\n\n      return i > o ? qt.__absoluteGreater(n) : i < o ? qt.__absoluteLess(n) : 0;\n    }\n\n    return qt.__compareToDouble(t, e);\n  }\n\n  static __compareToDouble(t, e) {\n    var n = Math.clz32;\n    if (e != e) return e;\n    if (e === 1 / 0) return -1;\n    if (e === -1 / 0) return 1;\n    const r = t.sign;\n    if (r !== 0 > e) return qt.__unequalSign(r);\n    if (0 === e) throw new Error(\"implementation bug: should be handled elsewhere\");\n    if (0 === t.length) return -1;\n    qt.__kBitConversionDouble[0] = e;\n    const o = 2047 & qt.__kBitConversionInts[1] >>> 20;\n    if (2047 == o) throw new Error(\"implementation bug: handled elsewhere\");\n    const i = o - 1023;\n    if (0 > i) return qt.__absoluteGreater(r);\n    const s = t.length;\n\n    let c = t.__digit(s - 1);\n\n    const a = n(c),\n          u = 32 * s - a,\n          l = i + 1;\n    if (u < l) return qt.__absoluteLess(r);\n    if (u > l) return qt.__absoluteGreater(r);\n    let h = 1048576 | 1048575 & qt.__kBitConversionInts[1],\n        f = qt.__kBitConversionInts[0];\n    const d = 31 - a;\n    if (d !== (u - 1) % 31) throw new Error(\"implementation bug\");\n    let p,\n        _ = 0;\n\n    if (20 > d) {\n      const t = 20 - d;\n      _ = t + 32, p = h >>> t, h = h << 32 - t | f >>> t, f <<= 32 - t;\n    } else if (20 === d) _ = 32, p = h, h = f;else {\n      const t = d - 20;\n      _ = 32 - t, p = h << t | f >>> 32 - t, h = f << t;\n    }\n\n    if (c >>>= 0, p >>>= 0, c > p) return qt.__absoluteGreater(r);\n    if (c < p) return qt.__absoluteLess(r);\n\n    for (let e = s - 2; 0 <= e; e--) {\n      0 < _ ? (_ -= 32, p = h >>> 0, h = f, f = 0) : p = 0;\n\n      const n = t.__unsignedDigit(e);\n\n      if (n > p) return qt.__absoluteGreater(r);\n      if (n < p) return qt.__absoluteLess(r);\n    }\n\n    if (0 !== h || 0 !== f) {\n      if (0 === _) throw new Error(\"implementation bug\");\n      return qt.__absoluteLess(r);\n    }\n\n    return 0;\n  }\n\n  static __equalToNumber(t, e) {\n    var n = Math.abs;\n    return e | 0 === e ? 0 === e ? 0 === t.length : 1 === t.length && t.sign === 0 > e && t.__unsignedDigit(0) === n(e) : 0 === qt.__compareToDouble(t, e);\n  }\n\n  static __comparisonResultToBool(t, e) {\n    switch (e) {\n      case 0:\n        return 0 > t;\n\n      case 1:\n        return 0 >= t;\n\n      case 2:\n        return 0 < t;\n\n      case 3:\n        return 0 <= t;\n    }\n\n    throw new Error(\"unreachable\");\n  }\n\n  static __compare(t, e, n) {\n    if (t = qt.__toPrimitive(t), e = qt.__toPrimitive(e), \"string\" == typeof t && \"string\" == typeof e) switch (n) {\n      case 0:\n        return t < e;\n\n      case 1:\n        return t <= e;\n\n      case 2:\n        return t > e;\n\n      case 3:\n        return t >= e;\n    }\n    if (qt.__isBigInt(t) && \"string\" == typeof e) return null !== (e = qt.__fromString(e)) && qt.__comparisonResultToBool(qt.__compareToBigInt(t, e), n);\n    if (\"string\" == typeof t && qt.__isBigInt(e)) return null !== (t = qt.__fromString(t)) && qt.__comparisonResultToBool(qt.__compareToBigInt(t, e), n);\n\n    if (t = qt.__toNumeric(t), e = qt.__toNumeric(e), qt.__isBigInt(t)) {\n      if (qt.__isBigInt(e)) return qt.__comparisonResultToBool(qt.__compareToBigInt(t, e), n);\n      if (\"number\" != typeof e) throw new Error(\"implementation bug\");\n      return qt.__comparisonResultToBool(qt.__compareToNumber(t, e), n);\n    }\n\n    if (\"number\" != typeof t) throw new Error(\"implementation bug\");\n    if (qt.__isBigInt(e)) return qt.__comparisonResultToBool(qt.__compareToNumber(e, t), 2 ^ n);\n    if (\"number\" != typeof e) throw new Error(\"implementation bug\");\n    return 0 === n ? t < e : 1 === n ? t <= e : 2 === n ? t > e : 3 === n ? t >= e : void 0;\n  }\n\n  __clzmsd() {\n    return Math.clz32(this[this.length - 1]);\n  }\n\n  static __absoluteAdd(t, e, n) {\n    if (t.length < e.length) return qt.__absoluteAdd(e, t, n);\n    if (0 === t.length) return t;\n    if (0 === e.length) return t.sign === n ? t : qt.unaryMinus(t);\n    let r = t.length;\n    (0 === t.__clzmsd() || e.length === t.length && 0 === e.__clzmsd()) && r++;\n    const o = new qt(r, n);\n    let i = 0,\n        s = 0;\n\n    for (; s < e.length; s++) {\n      const n = e.__digit(s),\n            r = t.__digit(s),\n            c = (65535 & r) + (65535 & n) + i,\n            a = (r >>> 16) + (n >>> 16) + (c >>> 16);\n\n      i = a >>> 16, o.__setDigit(s, 65535 & c | a << 16);\n    }\n\n    for (; s < t.length; s++) {\n      const e = t.__digit(s),\n            n = (65535 & e) + i,\n            r = (e >>> 16) + (n >>> 16);\n\n      i = r >>> 16, o.__setDigit(s, 65535 & n | r << 16);\n    }\n\n    return s < o.length && o.__setDigit(s, i), o.__trim();\n  }\n\n  static __absoluteSub(t, e, n) {\n    if (0 === t.length) return t;\n    if (0 === e.length) return t.sign === n ? t : qt.unaryMinus(t);\n    const r = new qt(t.length, n);\n    let o = 0,\n        i = 0;\n\n    for (; i < e.length; i++) {\n      const n = t.__digit(i),\n            s = e.__digit(i),\n            c = (65535 & n) - (65535 & s) - o;\n\n      o = 1 & c >>> 16;\n      const a = (n >>> 16) - (s >>> 16) - o;\n      o = 1 & a >>> 16, r.__setDigit(i, 65535 & c | a << 16);\n    }\n\n    for (; i < t.length; i++) {\n      const e = t.__digit(i),\n            n = (65535 & e) - o;\n\n      o = 1 & n >>> 16;\n      const s = (e >>> 16) - o;\n      o = 1 & s >>> 16, r.__setDigit(i, 65535 & n | s << 16);\n    }\n\n    return r.__trim();\n  }\n\n  static __absoluteAddOne(t, e, n = null) {\n    const r = t.length;\n    null === n ? n = new qt(r, e) : n.sign = e;\n    let o = !0;\n\n    for (let e, i = 0; i < r; i++) {\n      e = t.__digit(i);\n      const r = -1 === e;\n      o && (e = 0 | e + 1), o = r, n.__setDigit(i, e);\n    }\n\n    return o && n.__setDigitGrow(r, 1), n;\n  }\n\n  static __absoluteSubOne(t, e) {\n    const n = t.length,\n          r = new qt(e = e || n, !1);\n    let o = !0;\n\n    for (let e, i = 0; i < n; i++) {\n      e = t.__digit(i);\n      const n = 0 === e;\n      o && (e = 0 | e - 1), o = n, r.__setDigit(i, e);\n    }\n\n    for (let t = n; t < e; t++) r.__setDigit(t, 0);\n\n    return r;\n  }\n\n  static __absoluteAnd(t, e, n = null) {\n    let r = t.length,\n        o = e.length,\n        i = o;\n\n    if (r < o) {\n      i = r;\n      const n = t,\n            s = r;\n      t = e, r = o, e = n, o = s;\n    }\n\n    let s = i;\n    null === n ? n = new qt(s, !1) : s = n.length;\n    let c = 0;\n\n    for (; c < i; c++) n.__setDigit(c, t.__digit(c) & e.__digit(c));\n\n    for (; c < s; c++) n.__setDigit(c, 0);\n\n    return n;\n  }\n\n  static __absoluteAndNot(t, e, n = null) {\n    const r = t.length,\n          o = e.length;\n    let i = o;\n    r < o && (i = r);\n    let s = r;\n    null === n ? n = new qt(s, !1) : s = n.length;\n    let c = 0;\n\n    for (; c < i; c++) n.__setDigit(c, t.__digit(c) & ~e.__digit(c));\n\n    for (; c < r; c++) n.__setDigit(c, t.__digit(c));\n\n    for (; c < s; c++) n.__setDigit(c, 0);\n\n    return n;\n  }\n\n  static __absoluteOr(t, e, n = null) {\n    let r = t.length,\n        o = e.length,\n        i = o;\n\n    if (r < o) {\n      i = r;\n      const n = t,\n            s = r;\n      t = e, r = o, e = n, o = s;\n    }\n\n    let s = r;\n    null === n ? n = new qt(s, !1) : s = n.length;\n    let c = 0;\n\n    for (; c < i; c++) n.__setDigit(c, t.__digit(c) | e.__digit(c));\n\n    for (; c < r; c++) n.__setDigit(c, t.__digit(c));\n\n    for (; c < s; c++) n.__setDigit(c, 0);\n\n    return n;\n  }\n\n  static __absoluteXor(t, e, n = null) {\n    let r = t.length,\n        o = e.length,\n        i = o;\n\n    if (r < o) {\n      i = r;\n      const n = t,\n            s = r;\n      t = e, r = o, e = n, o = s;\n    }\n\n    let s = r;\n    null === n ? n = new qt(s, !1) : s = n.length;\n    let c = 0;\n\n    for (; c < i; c++) n.__setDigit(c, t.__digit(c) ^ e.__digit(c));\n\n    for (; c < r; c++) n.__setDigit(c, t.__digit(c));\n\n    for (; c < s; c++) n.__setDigit(c, 0);\n\n    return n;\n  }\n\n  static __absoluteCompare(t, e) {\n    const n = t.length - e.length;\n    if (0 != n) return n;\n    let r = t.length - 1;\n\n    for (; 0 <= r && t.__digit(r) === e.__digit(r);) r--;\n\n    return 0 > r ? 0 : t.__unsignedDigit(r) > e.__unsignedDigit(r) ? 1 : -1;\n  }\n\n  static __multiplyAccumulate(t, e, n, r) {\n    var o = Math.imul;\n    if (0 === e) return;\n    const i = 65535 & e,\n          s = e >>> 16;\n    let c = 0,\n        a = 0,\n        u = 0;\n\n    for (let e = 0; e < t.length; e++, r++) {\n      let l = n.__digit(r),\n          h = 65535 & l,\n          f = l >>> 16;\n\n      const d = t.__digit(e),\n            p = 65535 & d,\n            _ = d >>> 16,\n            g = o(p, i),\n            m = o(p, s),\n            v = o(_, i),\n            y = o(_, s);\n\n      h += a + (65535 & g), f += u + c + (h >>> 16) + (g >>> 16) + (65535 & m) + (65535 & v), c = f >>> 16, a = (m >>> 16) + (v >>> 16) + (65535 & y) + c, c = a >>> 16, a &= 65535, u = y >>> 16, l = 65535 & h | f << 16, n.__setDigit(r, l);\n    }\n\n    for (; 0 != c || 0 !== a || 0 !== u; r++) {\n      let t = n.__digit(r);\n\n      const e = (65535 & t) + a,\n            o = (t >>> 16) + (e >>> 16) + u + c;\n      a = 0, u = 0, c = o >>> 16, t = 65535 & e | o << 16, n.__setDigit(r, t);\n    }\n  }\n\n  static __internalMultiplyAdd(t, e, n, r, o) {\n    var i = Math.imul;\n    let s = n,\n        c = 0;\n\n    for (let n = 0; n < r; n++) {\n      const r = t.__digit(n),\n            a = i(65535 & r, e),\n            u = (65535 & a) + c + s;\n\n      s = u >>> 16;\n      const l = i(r >>> 16, e),\n            h = (65535 & l) + (a >>> 16) + s;\n      s = h >>> 16, c = l >>> 16, o.__setDigit(n, h << 16 | 65535 & u);\n    }\n\n    if (o.length > r) for (o.__setDigit(r++, s + c); r < o.length;) o.__setDigit(r++, 0);else if (0 !== s + c) throw new Error(\"implementation bug\");\n  }\n\n  __inplaceMultiplyAdd(t, e, n) {\n    var r = Math.imul;\n    n > this.length && (n = this.length);\n    const o = 65535 & t,\n          i = t >>> 16;\n    let s = 0,\n        c = 65535 & e,\n        a = e >>> 16;\n\n    for (let t = 0; t < n; t++) {\n      const e = this.__digit(t),\n            n = 65535 & e,\n            u = e >>> 16,\n            l = r(n, o),\n            h = r(n, i),\n            f = r(u, o),\n            d = r(u, i),\n            p = c + (65535 & l),\n            _ = a + s + (p >>> 16) + (l >>> 16) + (65535 & h) + (65535 & f);\n\n      c = (h >>> 16) + (f >>> 16) + (65535 & d) + (_ >>> 16), s = c >>> 16, c &= 65535, a = d >>> 16, this.__setDigit(t, 65535 & p | _ << 16);\n    }\n\n    if (0 != s || 0 !== c || 0 !== a) throw new Error(\"implementation bug\");\n  }\n\n  static __absoluteDivSmall(t, e, n) {\n    null === n && (n = new qt(t.length, !1));\n    let r = 0;\n\n    for (let o, i = 2 * t.length - 1; 0 <= i; i -= 2) {\n      o = (r << 16 | t.__halfDigit(i)) >>> 0;\n      const s = 0 | o / e;\n      r = 0 | o % e, o = (r << 16 | t.__halfDigit(i - 1)) >>> 0;\n      const c = 0 | o / e;\n      r = 0 | o % e, n.__setDigit(i >>> 1, s << 16 | c);\n    }\n\n    return n;\n  }\n\n  static __absoluteModSmall(t, e) {\n    let n = 0;\n\n    for (let r = 2 * t.length - 1; 0 <= r; r--) {\n      n = 0 | ((n << 16 | t.__halfDigit(r)) >>> 0) % e;\n    }\n\n    return n;\n  }\n\n  static __absoluteDivLarge(t, e, n, r) {\n    var o = Math.imul;\n\n    const i = e.__halfDigitLength(),\n          s = e.length,\n          c = t.__halfDigitLength() - i;\n\n    let a = null;\n    n && (a = new qt(c + 2 >>> 1, !1), a.__initializeDigits());\n    const u = new qt(i + 2 >>> 1, !1);\n\n    u.__initializeDigits();\n\n    const l = qt.__clz16(e.__halfDigit(i - 1));\n\n    0 < l && (e = qt.__specialLeftShift(e, l, 0));\n\n    const h = qt.__specialLeftShift(t, l, 1),\n          f = e.__halfDigit(i - 1);\n\n    let d = 0;\n\n    for (let t, r = c; 0 <= r; r--) {\n      t = 65535;\n\n      const c = h.__halfDigit(r + i);\n\n      if (c !== f) {\n        const n = (c << 16 | h.__halfDigit(r + i - 1)) >>> 0;\n        t = 0 | n / f;\n        let s = 0 | n % f;\n\n        const a = e.__halfDigit(i - 2),\n              u = h.__halfDigit(r + i - 2);\n\n        for (; o(t, a) >>> 0 > (s << 16 | u) >>> 0 && (t--, s += f, !(65535 < s)););\n      }\n\n      qt.__internalMultiplyAdd(e, t, 0, s, u);\n\n      let l = h.__inplaceSub(u, r, i + 1);\n\n      0 !== l && (l = h.__inplaceAdd(e, r, i), h.__setHalfDigit(r + i, h.__halfDigit(r + i) + l), t--), n && (1 & r ? d = t << 16 : a.__setDigit(r >>> 1, d | t));\n    }\n\n    return r ? (h.__inplaceRightShift(l), n ? {\n      quotient: a,\n      remainder: h\n    } : h) : n ? a : void 0;\n  }\n\n  static __clz16(t) {\n    return Math.clz32(t) - 16;\n  }\n\n  __inplaceAdd(t, e, n) {\n    let r = 0;\n\n    for (let o = 0; o < n; o++) {\n      const n = this.__halfDigit(e + o) + t.__halfDigit(o) + r;\n      r = n >>> 16, this.__setHalfDigit(e + o, n);\n    }\n\n    return r;\n  }\n\n  __inplaceSub(t, e, n) {\n    let r = 0;\n\n    if (1 & e) {\n      e >>= 1;\n\n      let o = this.__digit(e),\n          i = 65535 & o,\n          s = 0;\n\n      for (; s < n - 1 >>> 1; s++) {\n        const n = t.__digit(s),\n              c = (o >>> 16) - (65535 & n) - r;\n\n        r = 1 & c >>> 16, this.__setDigit(e + s, c << 16 | 65535 & i), o = this.__digit(e + s + 1), i = (65535 & o) - (n >>> 16) - r, r = 1 & i >>> 16;\n      }\n\n      const c = t.__digit(s),\n            a = (o >>> 16) - (65535 & c) - r;\n\n      if (r = 1 & a >>> 16, this.__setDigit(e + s, a << 16 | 65535 & i), e + s + 1 >= this.length) throw new RangeError(\"out of bounds\");\n      0 == (1 & n) && (o = this.__digit(e + s + 1), i = (65535 & o) - (c >>> 16) - r, r = 1 & i >>> 16, this.__setDigit(e + t.length, 4294901760 & o | 65535 & i));\n    } else {\n      e >>= 1;\n      let o = 0;\n\n      for (; o < t.length - 1; o++) {\n        const n = this.__digit(e + o),\n              i = t.__digit(o),\n              s = (65535 & n) - (65535 & i) - r;\n\n        r = 1 & s >>> 16;\n        const c = (n >>> 16) - (i >>> 16) - r;\n        r = 1 & c >>> 16, this.__setDigit(e + o, c << 16 | 65535 & s);\n      }\n\n      const i = this.__digit(e + o),\n            s = t.__digit(o),\n            c = (65535 & i) - (65535 & s) - r;\n\n      r = 1 & c >>> 16;\n      let a = 0;\n      0 == (1 & n) && (a = (i >>> 16) - (s >>> 16) - r, r = 1 & a >>> 16), this.__setDigit(e + o, a << 16 | 65535 & c);\n    }\n\n    return r;\n  }\n\n  __inplaceRightShift(t) {\n    if (0 === t) return;\n    let e = this.__digit(0) >>> t;\n    const n = this.length - 1;\n\n    for (let r = 0; r < n; r++) {\n      const n = this.__digit(r + 1);\n\n      this.__setDigit(r, n << 32 - t | e), e = n >>> t;\n    }\n\n    this.__setDigit(n, e);\n  }\n\n  static __specialLeftShift(t, e, n) {\n    const r = t.length,\n          o = new qt(r + n, !1);\n\n    if (0 === e) {\n      for (let e = 0; e < r; e++) o.__setDigit(e, t.__digit(e));\n\n      return 0 < n && o.__setDigit(r, 0), o;\n    }\n\n    let i = 0;\n\n    for (let n = 0; n < r; n++) {\n      const r = t.__digit(n);\n\n      o.__setDigit(n, r << e | i), i = r >>> 32 - e;\n    }\n\n    return 0 < n && o.__setDigit(r, i), o;\n  }\n\n  static __leftShiftByAbsolute(t, e) {\n    const n = qt.__toShiftAmount(e);\n\n    if (0 > n) throw new RangeError(\"BigInt too big\");\n    const r = n >>> 5,\n          o = 31 & n,\n          i = t.length,\n          s = 0 !== o && 0 != t.__digit(i - 1) >>> 32 - o,\n          c = i + r + (s ? 1 : 0),\n          a = new qt(c, t.sign);\n\n    if (0 === o) {\n      let e = 0;\n\n      for (; e < r; e++) a.__setDigit(e, 0);\n\n      for (; e < c; e++) a.__setDigit(e, t.__digit(e - r));\n    } else {\n      let e = 0;\n\n      for (let t = 0; t < r; t++) a.__setDigit(t, 0);\n\n      for (let n = 0; n < i; n++) {\n        const i = t.__digit(n);\n\n        a.__setDigit(n + r, i << o | e), e = i >>> 32 - o;\n      }\n\n      if (s) a.__setDigit(i + r, e);else if (0 != e) throw new Error(\"implementation bug\");\n    }\n\n    return a.__trim();\n  }\n\n  static __rightShiftByAbsolute(t, e) {\n    const n = t.length,\n          r = t.sign,\n          o = qt.__toShiftAmount(e);\n\n    if (0 > o) return qt.__rightShiftByMaximum(r);\n    const i = o >>> 5,\n          s = 31 & o;\n    let c = n - i;\n    if (0 >= c) return qt.__rightShiftByMaximum(r);\n    let a = !1;\n    if (r) if (0 != (t.__digit(i) & (1 << s) - 1)) a = !0;else for (let e = 0; e < i; e++) if (0 !== t.__digit(e)) {\n      a = !0;\n      break;\n    }\n\n    if (a && 0 === s) {\n      0 == ~t.__digit(n - 1) && c++;\n    }\n\n    let u = new qt(c, r);\n    if (0 === s) for (let e = i; e < n; e++) u.__setDigit(e - i, t.__digit(e));else {\n      let e = t.__digit(i) >>> s;\n      const r = n - i - 1;\n\n      for (let n = 0; n < r; n++) {\n        const r = t.__digit(n + i + 1);\n\n        u.__setDigit(n, r << 32 - s | e), e = r >>> s;\n      }\n\n      u.__setDigit(r, e);\n    }\n    return a && (u = qt.__absoluteAddOne(u, !0, u)), u.__trim();\n  }\n\n  static __rightShiftByMaximum(t) {\n    return t ? qt.__oneDigit(1, !0) : qt.__zero();\n  }\n\n  static __toShiftAmount(t) {\n    if (1 < t.length) return -1;\n\n    const e = t.__unsignedDigit(0);\n\n    return e > qt.__kMaxLengthBits ? -1 : e;\n  }\n\n  static __toPrimitive(t, e = \"default\") {\n    if (\"object\" != typeof t) return t;\n    if (t.constructor === qt) return t;\n    const n = t[Symbol.toPrimitive];\n\n    if (n) {\n      const t = n(e);\n      if (\"object\" != typeof t) return t;\n      throw new TypeError(\"Cannot convert object to primitive value\");\n    }\n\n    const r = t.valueOf;\n\n    if (r) {\n      const e = r.call(t);\n      if (\"object\" != typeof e) return e;\n    }\n\n    const o = t.toString;\n\n    if (o) {\n      const e = o.call(t);\n      if (\"object\" != typeof e) return e;\n    }\n\n    throw new TypeError(\"Cannot convert object to primitive value\");\n  }\n\n  static __toNumeric(t) {\n    return qt.__isBigInt(t) ? t : +t;\n  }\n\n  static __isBigInt(t) {\n    return \"object\" == typeof t && t.constructor === qt;\n  }\n\n  static __truncateToNBits(t, e) {\n    const n = t + 31 >>> 5,\n          r = new qt(n, e.sign),\n          o = n - 1;\n\n    for (let t = 0; t < o; t++) r.__setDigit(t, e.__digit(t));\n\n    let i = e.__digit(o);\n\n    if (0 != (31 & t)) {\n      const e = 32 - (31 & t);\n      i = i << e >>> e;\n    }\n\n    return r.__setDigit(o, i), r.__trim();\n  }\n\n  static __truncateAndSubFromPowerOfTwo(t, e, n) {\n    var r = Math.min;\n    const o = t + 31 >>> 5,\n          i = new qt(o, n);\n    let s = 0;\n    const c = o - 1;\n    let a = 0;\n\n    for (const t = r(c, e.length); s < t; s++) {\n      const t = e.__digit(s),\n            n = 0 - (65535 & t) - a;\n\n      a = 1 & n >>> 16;\n      const r = 0 - (t >>> 16) - a;\n      a = 1 & r >>> 16, i.__setDigit(s, 65535 & n | r << 16);\n    }\n\n    for (; s < c; s++) i.__setDigit(s, 0 | -a);\n\n    let u = c < e.length ? e.__digit(c) : 0;\n    const l = 31 & t;\n    let h;\n\n    if (0 == l) {\n      const t = 0 - (65535 & u) - a;\n      a = 1 & t >>> 16, h = 65535 & t | 0 - (u >>> 16) - a << 16;\n    } else {\n      const t = 32 - l;\n      u = u << t >>> t;\n      const e = 1 << 32 - t,\n            n = (65535 & e) - (65535 & u) - a;\n      a = 1 & n >>> 16, h = 65535 & n | (e >>> 16) - (u >>> 16) - a << 16, h &= e - 1;\n    }\n\n    return i.__setDigit(c, h), i.__trim();\n  }\n\n  __digit(t) {\n    return this[t];\n  }\n\n  __unsignedDigit(t) {\n    return this[t] >>> 0;\n  }\n\n  __setDigit(t, e) {\n    this[t] = 0 | e;\n  }\n\n  __setDigitGrow(t, e) {\n    this[t] = 0 | e;\n  }\n\n  __halfDigitLength() {\n    const t = this.length;\n    return 65535 >= this.__unsignedDigit(t - 1) ? 2 * t - 1 : 2 * t;\n  }\n\n  __halfDigit(t) {\n    return 65535 & this[t >>> 1] >>> ((1 & t) << 4);\n  }\n\n  __setHalfDigit(t, e) {\n    const n = t >>> 1,\n          r = this.__digit(n),\n          o = 1 & t ? 65535 & r | e << 16 : 4294901760 & r | 65535 & e;\n\n    this.__setDigit(n, o);\n  }\n\n  static __digitPow(t, e) {\n    let n = 1;\n\n    for (; 0 < e;) 1 & e && (n *= t), e >>>= 1, t *= t;\n\n    return n;\n  }\n\n}\n\nqt.__kMaxLength = 33554432, qt.__kMaxLengthBits = qt.__kMaxLength << 5, qt.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], qt.__kBitsPerCharTableShift = 5, qt.__kBitsPerCharTableMultiplier = 1 << qt.__kBitsPerCharTableShift, qt.__kConversionChars = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"], qt.__kBitConversionBuffer = new ArrayBuffer(8), qt.__kBitConversionDouble = new Float64Array(qt.__kBitConversionBuffer), qt.__kBitConversionInts = new Int32Array(qt.__kBitConversionBuffer);\n\nvar $t = function (t) {\n  var e, n;\n\n  function r(e) {\n    var n,\n        r = (void 0 === e ? {} : e).supportedChainIds;\n    return (n = t.call(this) || this).supportedChainIds = r, n;\n  }\n\n  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, e.__proto__ = n;\n  var o = r.prototype;\n  return o.emitUpdate = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + st.Update + \"' with payload\", t), this.emit(st.Update, t);\n  }, o.emitError = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + st.Error + \"' with payload\", t), this.emit(st.Error, t);\n  }, o.emitDeactivate = function () {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + st.Deactivate + \"'\"), this.emit(st.Deactivate);\n  }, r;\n}(f);\n\nfunction zt() {\n  return (zt = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nvar Wt = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  5: \"goerli\",\n  42: \"kovan\"\n},\n    Gt = function (t) {\n  var e, n;\n\n  function r(e) {\n    var n,\n        r = e.chainId,\n        o = e.config,\n        i = void 0 === o ? {} : o;\n    return (n = t.call(this, {\n      supportedChainIds: [r]\n    }) || this).chainId = r, n.config = i, n;\n  }\n\n  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, e.__proto__ = n;\n  var o = r.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.authereum.getProvider().enable().then(function (t) {\n          return t[0];\n        })).then(function () {\n          return {\n            provider: e.authereum.getProvider()\n          };\n        });\n      },\n          e = this,\n          n = function () {\n        if (!e.authereum) return Promise.resolve(import(\"./index-465d2d1c.js\")).then(function (t) {\n          var n = t.default;\n          e.authereum = new n(zt({\n            networkName: Wt[e.chainId]\n          }, e.config));\n        });\n      }();\n\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.authereum.getProvider());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.authereum.getNetworkId());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.authereum.getAccountAddress());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, o.close = function () {\n    try {\n      return this.authereum.logout(), this.emitDeactivate(), Promise.resolve();\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r;\n}($t);\n\nvar Ht = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  42: \"kovan\"\n},\n    Jt = function (t) {\n  var e, n;\n\n  function r(e) {\n    var n,\n        r = e.apiKey,\n        o = e.chainId;\n    return Object.keys(Ht).includes(o.toString()) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Unsupported chainId \" + o) : ut(!1)), (n = t.call(this, {\n      supportedChainIds: [o]\n    }) || this).apiKey = r, n.chainId = o, n;\n  }\n\n  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, e.__proto__ = n;\n  var o = r.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.fortmatic.getProvider().enable().then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.fortmatic.getProvider(),\n            chainId: e.chainId,\n            account: t\n          };\n        });\n      },\n          e = this,\n          n = function () {\n        if (!e.fortmatic) return Promise.resolve(import(\"./fortmatic-083107e5.js\")).then(function (t) {\n          var n = t.default;\n          e.fortmatic = new n(e.apiKey, 1 === e.chainId || 4 === e.chainId ? void 0 : Ht[e.chainId]);\n        });\n      }();\n\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.fortmatic.getProvider());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.chainId);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.fortmatic.getProvider().send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, o.close = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.fortmatic.user.logout()).then(function () {\n        t.emitDeactivate();\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r;\n}($t);\n\nconst Kt = t => \"injected\" === t ? \"injected\" : t.endsWith(\".ipc\") ? \"ipc\" : t.startsWith(\"wss://\") || t.startsWith(\"ws://\") ? \"ws\" : t.startsWith(\"https://\") || t.startsWith(\"http://\") ? \"http\" : \"\";\n\nvar Xt = class extends h {\n  constructor(t) {\n    super(), this.connected = !1, this.nextId = 0, this.promises = {}, this.subscriptions = [], this.connection = t, this.connection.on(\"connect\", () => this.checkConnection()), this.connection.on(\"close\", () => this.emit(\"close\")), this.connection.on(\"payload\", t => {\n      const {\n        id: e,\n        method: n,\n        error: r,\n        result: o\n      } = t;\n      void 0 !== e ? this.promises[e] && (t.error ? this.promises[e].reject(r) : this.promises[e].resolve(o), delete this.promises[e]) : n && n.indexOf(\"_subscription\") > -1 && (this.emit(t.params.subscription, t.params.result), this.emit(n, t.params), this.emit(\"data\", t));\n    }), this.on(\"newListener\", (t, e) => {\n      \"networkChanged\" === t ? !this.attemptedNetworkSubscription && this.connected && this.startNetworkSubscription() : \"accountsChanged\" === t && !this.attemptedAccountsSubscription && this.connected && this.startAccountsSubscription();\n    });\n  }\n\n  async checkConnection() {\n    try {\n      this.emit(\"connect\", (await this._send(\"net_version\"))), this.connected = !0, this.listenerCount(\"networkChanged\") && !this.attemptedNetworkSubscription && this.startNetworkSubscription(), this.listenerCount(\"accountsChanged\") && !this.attemptedAccountsSubscription && this.startAccountsSubscription();\n    } catch (t) {\n      this.connected = !1;\n    }\n  }\n\n  async startNetworkSubscription() {\n    this.attemptedNetworkSubscription = !0;\n\n    try {\n      let t = await this.subscribe(\"eth_subscribe\", \"networkChanged\");\n      this.on(t, t => this.emit(\"networkChanged\", t));\n    } catch (t) {\n      console.warn(\"Unable to subscribe to networkChanged\", t);\n    }\n  }\n\n  async startAccountsSubscription() {\n    this.attemptedAccountsSubscription = !0;\n\n    try {\n      let t = await this.subscribe(\"eth_subscribe\", \"accountsChanged\");\n      this.on(t, t => this.emit(\"accountsChanged\", t));\n    } catch (t) {\n      console.warn(\"Unable to subscribe to accountsChanged\", t);\n    }\n  }\n\n  enable() {\n    return new Promise((t, e) => {\n      this._send(\"eth_accounts\").then(n => {\n        if (n.length > 0) this.accounts = n, this.coinbase = n[0], this.emit(\"enable\"), t(n);else {\n          const t = new Error(\"User Denied Full Provider\");\n          t.code = 4001, e(t);\n        }\n      }).catch(e);\n    });\n  }\n\n  _send(t, e = []) {\n    if (!t || \"string\" != typeof t) return new Error(\"Method is not a valid string.\");\n    if (!(e instanceof Array)) return new Error(\"Params is not a valid array.\");\n    const n = {\n      jsonrpc: \"2.0\",\n      id: this.nextId++,\n      method: t,\n      params: e\n    },\n          r = new Promise((t, e) => {\n      this.promises[n.id] = {\n        resolve: t,\n        reject: e\n      };\n    });\n    return this.connection.send(n), r;\n  }\n\n  send(...t) {\n    return this._send(...t);\n  }\n\n  _sendBatch(t) {\n    return Promise.all(t.map(t => this._send(t.method, t.params)));\n  }\n\n  subscribe(t, e, n = []) {\n    return this._send(t, [e, ...n]).then(t => (this.subscriptions.push(t), t));\n  }\n\n  unsubscribe(t, e) {\n    return this._send(t, [e]).then(t => {\n      if (t) return this.subscriptions = this.subscriptions.filter(t => t !== e), this.removeAllListeners(e), t;\n    });\n  }\n\n  sendAsync(t, e) {\n    return e && \"function\" == typeof e ? t ? t instanceof Array ? this.sendAsyncBatch(t, e) : this._send(t.method, t.params).then(n => {\n      e(null, {\n        id: t.id,\n        jsonrpc: t.jsonrpc,\n        result: n\n      });\n    }).catch(t => {\n      e(t);\n    }) : e(new Error(\"Invalid Payload\")) : e(new Error(\"Invalid or undefined callback provided to sendAsync\"));\n  }\n\n  sendAsyncBatch(t, e) {\n    return this._sendBatch(t).then(n => {\n      let r = n.map((e, n) => ({\n        id: t[n].id,\n        jsonrpc: t[n].jsonrpc,\n        result: e\n      }));\n      e(null, r);\n    }).catch(t => {\n      e(t);\n    });\n  }\n\n  isConnected() {\n    return this.connected;\n  }\n\n  close() {\n    this.connection.close(), this.connected = !1;\n    let t = new Error(\"Provider closed, subscription lost, please subscribe again.\");\n    this.subscriptions.forEach(e => this.emit(e, t)), this.subscriptions = [];\n  }\n\n};\nconst Yt = \"development\" === process.env.NODE_ENV;\nvar Qt = class extends h {\n  constructor(t, e, n) {\n    super(), this.targets = e, this.connections = t, this.connected = !1, this.status = \"loading\", this.interval = n.interval || 5e3, this.name = n.name || \"default\", this.inSetup = !0, this.connect();\n  }\n\n  connect(t = 0) {\n    if (Yt && 0 === t && console.log(`\\n\\n\\n\\nA connection cycle started for provider with name: ${this.name}`), this.connection && \"connected\" === this.connection.status && t >= this.connection.index) Yt && console.log(\"Stopping connection cycle becasuse we're already connected to a higher priority provider\");else if (0 === this.targets.length) Yt && console.log(\"No valid targets supplied\");else {\n      const {\n        protocol: e,\n        location: n\n      } = this.targets[t];\n      this.connection = this.connections[e](n), this.connection.on(\"error\", e => this.connected ? this.listenerCount(\"error\") ? this.emit(\"error\", e) : void console.warn(\"eth-provider - Uncaught connection error: \" + e.message) : this.connectionError(t, e)), this.connection.on(\"close\", t => {\n        this.connected = !1, this.emit(\"close\"), this.closing || this.refresh();\n      }), this.connection.on(\"connect\", () => {\n        this.connection.target = this.targets[t], this.connection.index = t, this.targets[t].status = this.connection.status, this.connected = !0, this.inSetup = !1, Yt && console.log(\"Successfully connected to: \" + this.targets[t].location), this.emit(\"connect\");\n      }), this.connection.on(\"data\", t => this.emit(\"data\", t)), this.connection.on(\"payload\", t => this.emit(\"payload\", t));\n    }\n  }\n\n  refresh(t = this.interval) {\n    Yt && console.log(`Reconnect queued for ${(t / 1e3).toFixed(2)}s in the future`), clearTimeout(this.connectTimer), this.connectTimer = setTimeout(() => this.connect(), t);\n  }\n\n  connectionError(t, e) {\n    this.targets[t].status = e, this.targets.length - 1 === t ? (this.inSetup = !1, Yt && console.warn(\"eth-provider unable to connect to any targets, view connection cycle summary: \", this.targets), this.refresh()) : this.connect(++t);\n  }\n\n  close() {\n    this.closing = !0, this.connection ? this.connection.close() : this.emit(\"close\"), clearTimeout(this.connectTimer);\n  }\n\n  error(t, e, n = -1) {\n    this.emit(\"payload\", {\n      id: t.id,\n      jsonrpc: t.jsonrpc,\n      error: {\n        message: e,\n        code: n\n      }\n    });\n  }\n\n  send(t) {\n    this.inSetup ? setTimeout(() => this.send(t), 100) : this.connection.closed ? this.error(t, \"Not connected\") : this.connection.send(t);\n  }\n\n};\n\nconst Zt = t => {\n  function e(e) {\n    t.status = e, t instanceof h && t.emit(\"status\", e);\n  }\n\n  async function n() {\n    if (t.inSetup) return setTimeout(n, 1e3);\n\n    try {\n      (await t.send(\"eth_syncing\")) ? (e(\"syncing\"), setTimeout(() => n(), 5e3)) : e(\"connected\");\n    } catch (t) {\n      e(\"disconnected\");\n    }\n  }\n\n  return e(\"loading\"), n(), t.on(\"connect\", () => n()), t.on(\"close\", () => e(\"disconnected\")), t;\n};\n\nvar te = {\n  injected: [\"injected\"],\n  frame: [\"ws://127.0.0.1:1248\", \"http://127.0.0.1:1248\"],\n  direct: [\"ws://127.0.0.1:8546\", \"http://127.0.0.1:8545\"],\n  infura: [\"wss://mainnet.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://mainnet.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"],\n  infuraRopsten: [\"wss://ropsten.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://ropsten.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"],\n  infuraRinkeby: [\"wss://rinkeby.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://rinkeby.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"],\n  infuraKovan: [\"wss://kovan.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://kovan.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"]\n};\n\nclass ee extends h {\n  constructor(t, e) {\n    super(), t ? setTimeout(() => this.emit(\"error\", new Error(\"Injected web3 provider is not currently supported\")), 0) : setTimeout(() => this.emit(\"error\", new Error(\"No injected provider found\")), 0);\n  }\n\n}\n\nclass ne extends h {\n  constructor(t) {\n    super(), setTimeout(() => this.emit(\"error\", new Error(t)), 0);\n  }\n\n}\n\nlet re, oe;\nconst ie = \"development\" === process.env.NODE_ENV;\nlet se;\n\nclass ce extends h {\n  constructor(t, e, n) {\n    super(), se = t, setTimeout(() => this.create(e, n), 0);\n  }\n\n  create(t, e) {\n    se || this.emit(\"error\", new Error(\"No WebSocket transport available\"));\n\n    try {\n      this.socket = new se(t);\n    } catch (t) {\n      return this.emit(\"error\", t);\n    }\n\n    this.socket.addEventListener(\"error\", t => this.emit(\"error\", t)), this.socket.addEventListener(\"open\", () => {\n      this.emit(\"connect\"), this.socket.addEventListener(\"message\", t => {\n        ((t, e) => {\n          const n = [];\n          t.replace(/\\}[\\n\\r]?\\{/g, \"}|--|{\").replace(/\\}\\][\\n\\r]?\\[\\{/g, \"}]|--|[{\").replace(/\\}[\\n\\r]?\\[\\{/g, \"}|--|[{\").replace(/\\}\\][\\n\\r]?\\{/g, \"}]|--|{\").split(\"|--|\").forEach(t => {\n            let r;\n            re && (t = re + t);\n\n            try {\n              r = JSON.parse(t);\n            } catch (n) {\n              return re = t, clearTimeout(oe), void (oe = setTimeout(() => e(new Error(\"Parse response timeout\")), 15e3));\n            }\n\n            clearTimeout(oe), re = null, r && n.push(r);\n          }), e(null, n);\n        })(\"string\" == typeof t.data ? t.data : \"\", (t, e) => {\n          t || e.forEach(t => {\n            Array.isArray(t) ? t.forEach(t => this.emit(\"payload\", t)) : this.emit(\"payload\", t);\n          });\n        });\n      }), this.socket.addEventListener(\"close\", () => this.onClose());\n    });\n  }\n\n  onClose() {\n    this.socket = null, this.closed = !0, ie && console.log(\"Closing WebSocket connection\"), this.emit(\"close\"), this.removeAllListeners();\n  }\n\n  close() {\n    this.socket ? this.socket.close() : this.onClose();\n  }\n\n  error(t, e, n = -1) {\n    this.emit(\"payload\", {\n      id: t.id,\n      jsonrpc: t.jsonrpc,\n      error: {\n        message: e,\n        code: n\n      }\n    });\n  }\n\n  send(t) {\n    this.socket && this.socket.readyState === this.socket.CONNECTING ? setTimeout(e => this.send(t), 10) : !this.socket || this.socket.readyState > 1 ? (this.connected = !1, this.error(t, \"Not connected\")) : this.socket.send(JSON.stringify(t));\n  }\n\n}\n\nfor (var ae = g(function (t) {\n  var e = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || \"undefined\" != typeof msCrypto && \"function\" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);\n\n  if (e) {\n    var n = new Uint8Array(16);\n\n    t.exports = function () {\n      return e(n), n;\n    };\n  } else {\n    var r = new Array(16);\n\n    t.exports = function () {\n      for (var t, e = 0; e < 16; e++) 0 == (3 & e) && (t = 4294967296 * Math.random()), r[e] = t >>> ((3 & e) << 3) & 255;\n\n      return r;\n    };\n  }\n}), ue = [], le = 0; le < 256; ++le) ue[le] = (le + 256).toString(16).substr(1);\n\nvar he = function (t, e) {\n  var n = e || 0,\n      r = ue;\n  return [r[t[n++]], r[t[n++]], r[t[n++]], r[t[n++]], \"-\", r[t[n++]], r[t[n++]], \"-\", r[t[n++]], r[t[n++]], \"-\", r[t[n++]], r[t[n++]], \"-\", r[t[n++]], r[t[n++]], r[t[n++]], r[t[n++]], r[t[n++]], r[t[n++]]].join(\"\");\n};\n\nvar fe = function (t, e, n) {\n  var r = e && n || 0;\n  \"string\" == typeof t && (e = \"binary\" === t ? new Array(16) : null, t = null);\n  var o = (t = t || {}).random || (t.rng || ae)();\n  if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, e) for (var i = 0; i < 16; ++i) e[r + i] = o[i];\n  return e || he(o);\n};\n\nconst de = \"development\" === process.env.NODE_ENV;\nlet pe;\n\nclass _e extends h {\n  constructor(t, e, n) {\n    super(), pe = t, this.connected = !1, this.subscriptions = !1, this.status = \"loading\", this.url = e, this.pollId = fe(), setTimeout(() => this.create(), 0);\n  }\n\n  create() {\n    if (!pe) return this.emit(\"error\", new Error(\"No HTTP transport available\"));\n    this.on(\"error\", () => {\n      this.connected && this.close();\n    }), this.init();\n  }\n\n  init() {\n    this.send({\n      jsonrpc: \"2.0\",\n      method: \"eth_syncing\",\n      params: [],\n      id: 1\n    }, (t, e) => {\n      if (t) return this.emit(\"error\", t);\n      this.send({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"eth_pollSubscriptions\",\n        params: [this.pollId, \"immediate\"]\n      }, (t, e) => {\n        t || (this.subscriptions = !0, this.pollSubscriptions()), this.connected = !0, this.emit(\"connect\");\n      });\n    });\n  }\n\n  pollSubscriptions() {\n    this.send({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"eth_pollSubscriptions\",\n      params: [this.pollId]\n    }, (t, e) => {\n      if (t) return this.subscriptionTimeout = setTimeout(() => this.pollSubscriptions(), 1e4), this.emit(\"error\", t);\n      this.closed || (this.subscriptionTimeout = this.pollSubscriptions()), e && e.map(t => {\n        let e;\n\n        try {\n          e = JSON.parse(t);\n        } catch (t) {\n          e = !1;\n        }\n\n        return e;\n      }).filter(t => t).forEach(t => this.emit(\"payload\", t));\n    });\n  }\n\n  close() {\n    de && console.log(\"Closing HTTP connection\"), this.closed = !0, this.emit(\"close\"), clearTimeout(this.subscriptionTimeout), this.removeAllListeners();\n  }\n\n  filterStatus(t) {\n    if (t.status >= 200 && t.status < 300) return t;\n    const e = new Error(t.statusText);\n    throw e.res = t, e.message;\n  }\n\n  error(t, e, n = -1) {\n    this.emit(\"payload\", {\n      id: t.id,\n      jsonrpc: t.jsonrpc,\n      error: {\n        message: e,\n        code: n\n      }\n    });\n  }\n\n  send(t, e) {\n    if (this.closed) return this.error(t, \"Not connected\");\n\n    if (\"eth_subscribe\" === t.method) {\n      if (!this.subscriptions) return this.error(t, \"Subscriptions are not supported by this HTTP endpoint\");\n      t.pollId = this.pollId;\n    }\n\n    const n = new pe();\n    let r = !1;\n\n    const o = (o, i) => {\n      if (!r) if (n.abort(), r = !0, e) e(o, i);else {\n        const {\n          id: e,\n          jsonrpc: n\n        } = t,\n              r = o ? {\n          id: e,\n          jsonrpc: n,\n          error: {\n            message: o.message,\n            code: o.code\n          }\n        } : {\n          id: e,\n          jsonrpc: n,\n          result: i\n        };\n        this.emit(\"payload\", r);\n      }\n    };\n\n    n.open(\"POST\", this.url, !0), n.setRequestHeader(\"Content-Type\", \"application/json\"), n.timeout = 6e4, n.onerror = o, n.ontimeout = o, n.onreadystatechange = () => {\n      if (4 === n.readyState) try {\n        const t = JSON.parse(n.responseText);\n        o(t.error, t.result);\n      } catch (t) {\n        o(t);\n      }\n    }, n.send(JSON.stringify(t));\n  }\n\n}\n\nconst ge = {\n  ethereum: \"undefined\" != typeof window && void 0 !== window.ethereum ? window.ethereum : null,\n  web3: \"undefined\" != typeof window && void 0 !== window.web3 ? window.web3.currentProvider : null\n},\n      me = \"undefined\" != typeof window && void 0 !== window.WebSocket ? window.WebSocket : null,\n      ve = \"undefined\" != typeof window && void 0 !== window.XMLHttpRequest ? window.XMLHttpRequest : null;\nge.ethereum && (ge.ethereum.__isProvider = !0);\nconst ye = {\n  injected: ge.ethereum || (t => e => new ee(t, e))(ge.web3),\n  ipc: (be = \"IPC connections are unavliable in the browser\", () => new ne(be)),\n  ws: (t => (e, n) => new ce(t, e, n))(me),\n  http: (t => (e, n) => new _e(t, e, n))(ve)\n};\n\nvar be,\n    we = (t = [\"injected\", \"frame\"], e = {}) => ((t, e, n) => {\n  if (t.injected.__isProvider && e.map(t => t.type).indexOf(\"injected\") > -1) return delete t.injected.__isProvider, Zt(t.injected);\n  const r = new Xt(new Qt(t, e, n));\n  return r.setMaxListeners(128), Zt(r);\n})(ye, ((t, e) => [].concat(...[].concat(t).map(t => e[t] ? e[t].map(e => ({\n  type: t,\n  location: e,\n  protocol: Kt(e)\n})) : {\n  type: \"custom\",\n  location: t,\n  protocol: Kt(t)\n})).filter(t => !(!t.protocol && \"injected\" !== t.type) || (console.log('eth-provider | Invalid provider preset/location: \"' + t.location + '\"'), !1)))(t, te), e);\n\nfunction Ee(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction Ce(t) {\n  return (Ce = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction Oe(t, e) {\n  return (Oe = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction Pe() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction Ne(t, e, n) {\n  return (Ne = Pe() ? Reflect.construct : function (t, e, n) {\n    var r = [null];\n    r.push.apply(r, e);\n    var o = new (Function.bind.apply(t, r))();\n    return n && Oe(o, n.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction Ie(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (Ie = function (t) {\n    if (null === t || (n = t, -1 === Function.toString.call(n).indexOf(\"[native code]\"))) return t;\n    var n;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, r);\n    }\n\n    function r() {\n      return Ne(t, arguments, Ce(this).constructor);\n    }\n\n    return r.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: r,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), Oe(r, t);\n  })(t);\n}\n\nfunction Se(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nvar De = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"The user rejected the request.\", e;\n  }\n\n  return Ee(e, t), e;\n}(Ie(Error)),\n    Ae = function (t) {\n  function e(e) {\n    var n;\n    return 1 !== e.supportedChainIds.length && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"This connector only supports 1 chainId at the moment.\") : ut(!1)), (n = t.call(this, e) || this).handleNetworkChanged = n.handleNetworkChanged.bind(Se(n)), n.handleChainChanged = n.handleChainChanged.bind(Se(n)), n.handleAccountsChanged = n.handleAccountsChanged.bind(Se(n)), n.handleClose = n.handleClose.bind(Se(n)), n;\n  }\n\n  Ee(e, t);\n  var n = e.prototype;\n  return n.handleNetworkChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'networkChanged' event with payload\", t), this.emitUpdate({\n      provider: this.provider,\n      chainId: t\n    });\n  }, n.handleChainChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'chainChanged' event with payload\", t), this.emitUpdate({\n      chainId: t\n    });\n  }, n.handleAccountsChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'accountsChanged' event with payload\", t), this.emitUpdate({\n      account: 0 === t.length ? null : t[0]\n    });\n  }, n.handleClose = function (t, e) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'close' event with payload\", t, e), this.emitDeactivate();\n  }, n.activate = function () {\n    try {\n      var t = this;\n      return t.provider || (t.provider = we(\"frame\")), t.provider.on(\"networkChanged\", t.handleNetworkChanged).on(\"chainChanged\", t.handleChainChanged).on(\"accountsChanged\", t.handleAccountsChanged).on(\"close\", t.handleClose), Promise.resolve(t.provider.enable().then(function (t) {\n        return t[0];\n      }).catch(function (t) {\n        throw t && 4001 === t.code ? new De() : t;\n      })).then(function (e) {\n        return {\n          provider: t.provider,\n          account: e\n        };\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getProvider = function () {\n    try {\n      return Promise.resolve(this.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getChainId = function () {\n    try {\n      return Promise.resolve(this.provider.send(\"eth_chainId\"));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getAccount = function () {\n    try {\n      return Promise.resolve(this.provider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.deactivate = function () {\n    this.provider.removeListener(\"networkChanged\", this.handleNetworkChanged).removeListener(\"chainChanged\", this.handleChainChanged).removeListener(\"accountsChanged\", this.handleAccountsChanged).removeListener(\"close\", this.handleClose);\n  }, e;\n}($t);\n\nfunction Re() {\n  return (Re = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction ke(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction Te(t) {\n  return (Te = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction je(t, e) {\n  return (je = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction xe() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction Be(t, e, n) {\n  return (Be = xe() ? Reflect.construct : function (t, e, n) {\n    var r = [null];\n    r.push.apply(r, e);\n    var o = new (Function.bind.apply(t, r))();\n    return n && je(o, n.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction Me(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (Me = function (t) {\n    if (null === t || (n = t, -1 === Function.toString.call(n).indexOf(\"[native code]\"))) return t;\n    var n;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, r);\n    }\n\n    function r() {\n      return Be(t, arguments, Te(this).constructor);\n    }\n\n    return r.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: r,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), je(r, t);\n  })(t);\n}\n\nfunction Ue(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\n\"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")));\n\nfunction Le(t, e) {\n  try {\n    var n = t();\n  } catch (t) {\n    return e(t);\n  }\n\n  return n && n.then ? n.then(void 0, e) : n;\n}\n\nfunction Ve(t) {\n  return t.hasOwnProperty(\"result\") ? t.result : t;\n}\n\nvar Fe = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"No Ethereum provider was found on window.ethereum.\", e;\n  }\n\n  return ke(e, t), e;\n}(Me(Error)),\n    qe = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"The user rejected the request.\", e;\n  }\n\n  return ke(e, t), e;\n}(Me(Error)),\n    $e = function (t) {\n  function e(e) {\n    var n;\n    return (n = t.call(this, e) || this).handleNetworkChanged = n.handleNetworkChanged.bind(Ue(n)), n.handleChainChanged = n.handleChainChanged.bind(Ue(n)), n.handleAccountsChanged = n.handleAccountsChanged.bind(Ue(n)), n.handleClose = n.handleClose.bind(Ue(n)), n;\n  }\n\n  ke(e, t);\n  var n = e.prototype;\n  return n.handleChainChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'chainChanged' event with payload\", t), this.emitUpdate({\n      chainId: t,\n      provider: window.ethereum\n    });\n  }, n.handleAccountsChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'accountsChanged' event with payload\", t), 0 === t.length ? this.emitDeactivate() : this.emitUpdate({\n      account: t[0]\n    });\n  }, n.handleClose = function (t, e) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'close' event with payload\", t, e), this.emitDeactivate();\n  }, n.handleNetworkChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'networkChanged' event with payload\", t), this.emitUpdate({\n      chainId: t,\n      provider: window.ethereum\n    });\n  }, n.activate = function () {\n    try {\n      var t,\n          e = function (e) {\n        if (n) return e;\n\n        function r() {\n          return Re({\n            provider: window.ethereum\n          }, t ? {\n            account: t\n          } : {});\n        }\n\n        var o = function () {\n          if (!t) return Promise.resolve(window.ethereum.enable().then(function (t) {\n            return t && Ve(t)[0];\n          })).then(function (e) {\n            t = e;\n          });\n        }();\n\n        return o && o.then ? o.then(r) : r();\n      },\n          n = !1;\n\n      if (!window.ethereum) throw new Fe();\n      window.ethereum.on && (window.ethereum.on(\"chainChanged\", this.handleChainChanged), window.ethereum.on(\"accountsChanged\", this.handleAccountsChanged), window.ethereum.on(\"close\", this.handleClose), window.ethereum.on(\"networkChanged\", this.handleNetworkChanged)), window.ethereum.isMetaMask && (window.ethereum.autoRefreshOnNetworkChange = !1);\n      var r = Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_requestAccounts\").then(function (t) {\n          return Ve(t)[0];\n        })).then(function (e) {\n          t = e;\n        });\n      }, function (t) {\n        if (4001 === t.code) throw new qe();\n        \"production\" !== process.env.NODE_ENV && ht(!1, \"eth_requestAccounts was unsuccessful, falling back to enable\");\n      });\n      return Promise.resolve(r && r.then ? r.then(e) : e(r));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getProvider = function () {\n    try {\n      return Promise.resolve(window.ethereum);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getChainId = function () {\n    try {\n      var t,\n          e = function () {\n        function e() {\n          if (!t) try {\n            t = Ve(window.ethereum.send({\n              method: \"net_version\"\n            }));\n          } catch (t) {\n            \"production\" !== process.env.NODE_ENV && ht(!1, \"net_version v2 was unsuccessful, falling back to manual matches and static properties\");\n          }\n          return t || (t = window.ethereum.isDapper ? Ve(window.ethereum.cachedResults.net_version) : window.ethereum.chainId || window.ethereum.netVersion || window.ethereum.networkVersion || window.ethereum._chainId), t;\n        }\n\n        var n = function () {\n          if (!t) {\n            var e = Le(function () {\n              return Promise.resolve(window.ethereum.send(\"net_version\").then(Ve)).then(function (e) {\n                t = e;\n              });\n            }, function () {\n              \"production\" !== process.env.NODE_ENV && ht(!1, \"net_version was unsuccessful, falling back to net version v2\");\n            });\n            if (e && e.then) return e.then(function () {});\n          }\n        }();\n\n        return n && n.then ? n.then(e) : e();\n      };\n\n      if (!window.ethereum) throw new Fe();\n      var n = Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_chainId\").then(Ve)).then(function (e) {\n          t = e;\n        });\n      }, function () {\n        \"production\" !== process.env.NODE_ENV && ht(!1, \"eth_chainId was unsuccessful, falling back to net_version\");\n      });\n      return Promise.resolve(n && n.then ? n.then(e) : e());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getAccount = function () {\n    try {\n      var t,\n          e = function () {\n        function e() {\n          return t || (t = Ve(window.ethereum.send({\n            method: \"eth_accounts\"\n          }))[0]), t;\n        }\n\n        var n = function () {\n          if (!t) {\n            var e = Le(function () {\n              return Promise.resolve(window.ethereum.enable().then(function (t) {\n                return Ve(t)[0];\n              })).then(function (e) {\n                t = e;\n              });\n            }, function () {\n              \"production\" !== process.env.NODE_ENV && ht(!1, \"enable was unsuccessful, falling back to eth_accounts v2\");\n            });\n            if (e && e.then) return e.then(function () {});\n          }\n        }();\n\n        return n && n.then ? n.then(e) : e();\n      };\n\n      if (!window.ethereum) throw new Fe();\n      var n = Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_accounts\").then(function (t) {\n          return Ve(t)[0];\n        })).then(function (e) {\n          t = e;\n        });\n      }, function () {\n        \"production\" !== process.env.NODE_ENV && ht(!1, \"eth_accounts was unsuccessful, falling back to enable\");\n      });\n      return Promise.resolve(n && n.then ? n.then(e) : e());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.deactivate = function () {\n    window.ethereum && window.ethereum.removeListener && (window.ethereum.removeListener(\"chainChanged\", this.handleChainChanged), window.ethereum.removeListener(\"accountsChanged\", this.handleAccountsChanged), window.ethereum.removeListener(\"close\", this.handleClose), window.ethereum.removeListener(\"networkChanged\", this.handleNetworkChanged));\n  }, n.isAuthorized = function () {\n    try {\n      return window.ethereum ? Promise.resolve(Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_accounts\").then(function (t) {\n          return Ve(t).length > 0;\n        }));\n      }, function () {\n        return !1;\n      })) : Promise.resolve(!1);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}($t);\n\nfunction ze(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nvar We = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  5: \"goerli\",\n  42: \"kovan\",\n  100: \"xdai\",\n  30: \"orchid\",\n  31: \"orchidTestnet\",\n  99: \"core\",\n  77: \"sokol\",\n  61: \"classic\",\n  8: \"ubiq\",\n  108: \"thundercore\",\n  18: \"thundercoreTestnet\",\n  163: \"lightstreams\",\n  122: \"fuse\",\n  15001: \"maticTestnet\"\n},\n    Ge = function (t) {\n  var e, n;\n\n  function r(e) {\n    var n,\n        r = e.dAppId,\n        o = e.networks,\n        i = e.config,\n        s = void 0 === i ? {} : i,\n        c = o.map(function (t) {\n      return \"number\" == typeof t ? t : Number(t.chainId);\n    });\n    return c.every(function (t) {\n      return !!We[t];\n    }) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"One or more unsupported networks \" + o) : ut(!1)), (n = t.call(this, {\n      supportedChainIds: c\n    }) || this).dAppId = r, n.networks = o, n.config = s, n.handleOnLogout = n.handleOnLogout.bind(ze(n)), n.handleOnActiveWalletChanged = n.handleOnActiveWalletChanged.bind(ze(n)), n.handleOnError = n.handleOnError.bind(ze(n)), n;\n  }\n\n  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, e.__proto__ = n;\n  var o = r.prototype;\n  return o.handleOnLogout = function () {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'onLogout' event\"), this.emitDeactivate();\n  }, o.handleOnActiveWalletChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'onActiveWalletChanged' event with payload\", t), this.emitUpdate({\n      account: t\n    });\n  }, o.handleOnError = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'onError' event\"), this.emitError(t);\n  }, o.activate = function () {\n    try {\n      var t = function () {\n        return e.portis.onLogout(e.handleOnLogout), e.portis.onActiveWalletChanged(e.handleOnActiveWalletChanged), e.portis.onError(e.handleOnError), Promise.resolve(e.portis.provider.enable().then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.portis.provider,\n            account: t\n          };\n        });\n      },\n          e = this,\n          n = function () {\n        if (!e.portis) return Promise.resolve(import(\"./index-6329c83f.js\")).then(function (t) {\n          var n = t.default;\n          e.portis = new n(e.dAppId, \"number\" == typeof e.networks[0] ? We[e.networks[0]] : e.networks[0], e.config);\n        });\n      }();\n\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.portis.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.portis.provider.send(\"eth_chainId\"));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.portis.provider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {\n    this.portis.onLogout(function () {}), this.portis.onActiveWalletChanged(function () {}), this.portis.onError(function () {});\n  }, o.changeNetwork = function (t, e) {\n    try {\n      return \"number\" == typeof t ? (We[t] || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Invalid chainId \" + t) : ut(!1)), this.portis.changeNetwork(We[t], e), this.emitUpdate({\n        chainId: t\n      })) : (this.portis.changeNetwork(t, e), this.emitUpdate({\n        chainId: Number(t.chainId)\n      })), Promise.resolve();\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.close = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.portis.logout()).then(function () {\n        t.emitDeactivate();\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r;\n}($t);\n\nvar He = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  5: \"goerli\",\n  42: \"kovan\",\n  100: \"xdai\"\n},\n    Je = function (t) {\n  var e, n;\n\n  function r(e) {\n    var n,\n        r = e.clientId,\n        o = e.networks,\n        i = e.options,\n        s = void 0 === i ? {} : i,\n        c = o.map(function (t) {\n      return \"number\" == typeof t ? t : t.chainId;\n    });\n    return c.every(function (t) {\n      return !!He[t];\n    }) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"One or more unsupported networks \" + o) : ut(!1)), (n = t.call(this, {\n      supportedChainIds: c\n    }) || this).clientId = r, n.networks = o, n.options = s, n;\n  }\n\n  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, e.__proto__ = n;\n  var o = r.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.squarelink.getProvider()).then(function (t) {\n          return Promise.resolve(t.enable().then(function (t) {\n            return t[0];\n          })).then(function (e) {\n            return {\n              provider: t,\n              account: e\n            };\n          });\n        });\n      },\n          e = this,\n          n = function () {\n        if (!e.squarelink) return Promise.resolve(import(\"squarelink\")).then(function (t) {\n          var n = t.default;\n          e.squarelink = new n(e.clientId, \"number\" == typeof e.networks[0] ? He[e.networks[0]] : e.networks[0], e.options);\n        });\n      }();\n\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.squarelink.getProvider());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.squarelink.getProvider().then(function (t) {\n        return t.send(\"eth_chainId\");\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.squarelink.getProvider().then(function (t) {\n        return t.send(\"eth_accounts\").then(function (t) {\n          return t[0];\n        });\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, r;\n}($t);\n\nfunction Ke() {\n  return (Ke = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n\n      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nvar Xe = function (t) {\n  var e, n;\n\n  function r(e) {\n    var n,\n        r = e.url,\n        o = e.appName,\n        i = e.appLogoUrl,\n        s = e.darkMode;\n    return (n = t.call(this, {\n      supportedChainIds: [1]\n    }) || this).url = r, n.appName = o, n.appLogoUrl = i, n.darkMode = s || !1, n;\n  }\n\n  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, e.__proto__ = n;\n  var o = r.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.provider.send(\"eth_requestAccounts\").then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.provider,\n            chainId: 1,\n            account: t\n          };\n        });\n      },\n          e = this,\n          n = function () {\n        if (!e.walletLink) return Promise.resolve(import(\"./index-53cdd08b.js\")).then(function (t) {\n          var n = t.default;\n          e.walletLink = new n(Ke({\n            appName: e.appName,\n            darkMode: e.darkMode\n          }, e.appLogoUrl ? {\n            appLogoUrl: e.appLogoUrl\n          } : {})), e.provider = e.walletLink.makeWeb3Provider(e.url, 1);\n        });\n      }();\n\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    return Promise.resolve(1);\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.provider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, o.close = function () {\n    try {\n      return this.provider.close(), this.emitDeactivate(), Promise.resolve();\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r;\n}($t);\n\nconst Ye = new Map([[\"1\", \"Mainnet\"], [\"3\", \"Ropsten\"], [\"4\", \"Rinkeby\"], [\"5\", \"Goerli\"], [\"100\", \"xDai\"], [\"1337\", \"Local\"]]);\n\nfunction Qe(t) {\n  return t = String(t), Ye.get(t) || \"Unknown\";\n}\n\nfunction Ze(t) {\n  if (\"object\" == typeof t && \"jsonrpc\" in t) {\n    if (t.error) throw new Error(t.error);\n    return t.result || null;\n  }\n\n  return t || null;\n}\n\nasync function tn(t, e, n) {\n  return t.sendAsync && t.selectedAddress ? new Promise((r, o) => {\n    t.sendAsync({\n      method: e,\n      params: n,\n      from: t.selectedAddress,\n      jsonrpc: \"2.0\",\n      id: 0\n    }, (t, e) => {\n      t ? o(t) : r(e);\n    });\n  }).then(Ze) : t.send(e, n).then(Ze);\n}\n\nfunction en(t, e) {\n  let n = -1,\n      r = !1;\n\n  const o = async (t, i) => {\n    const s = await t();\n    r || (i(s), n = setTimeout(o.bind(null, t, i), e));\n  };\n\n  return (...e) => {\n    const {\n      request: i,\n      onResult: s\n    } = t(...e);\n    return r = !1, o(i, s), () => {\n      r = !0, clearTimeout(n);\n    };\n  };\n}\n\nclass nn extends Error {\n  constructor(t, e, ...n) {\n    super(...n), this.name = \"ChainUnsupportedError\", this.message = `Unsupported chain: ${Qe(t)}${-1 === t ? \"\" : ` (Chain ID: ${t})`}. ` + `Required chain: ${Qe(e)} (Chain ID: ${e}).`;\n  }\n\n}\n\nclass rn extends Error {\n  constructor(t, ...e) {\n    super(...e), this.name = \"ConnectorUnsupportedError\", this.message = `Unsupported connector: ${t}.`;\n  }\n\n}\n\nclass on extends Error {\n  constructor(...t) {\n    super(...t), this.name = \"ConnectionRejectedError\", this.message = \"The activation has been rejected by the provider.\";\n  }\n\n}\n\nclass sn extends Error {\n  constructor(...t) {\n    super(...t), this.name = \"ConnectorConfigError\";\n  }\n\n}\n\nfunction cn(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction an(t) {\n  return (an = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction un(t, e) {\n  return (un = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction ln() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction hn(t, e, n) {\n  return (hn = ln() ? Reflect.construct : function (t, e, n) {\n    var r = [null];\n    r.push.apply(r, e);\n    var o = new (Function.bind.apply(t, r))();\n    return n && un(o, n.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction fn(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (fn = function (t) {\n    if (null === t || (n = t, -1 === Function.toString.call(n).indexOf(\"[native code]\"))) return t;\n    var n;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, r);\n    }\n\n    function r() {\n      return hn(t, arguments, an(this).constructor);\n    }\n\n    return r.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: r,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), un(r, t);\n  })(t);\n}\n\nfunction dn(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nvar pn = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"The user rejected the request.\", e;\n  }\n\n  return cn(e, t), e;\n}(fn(Error)),\n    _n = function (t) {\n  function e(e) {\n    var n,\n        r = e.rpc,\n        o = e.bridge,\n        i = e.qrcode,\n        s = e.pollingInterval;\n    return 1 !== Object.keys(r).length && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"@walletconnect/web3-provider is broken with >1 chainId, please use 1\") : ut(!1)), (n = t.call(this, {\n      supportedChainIds: Object.keys(r).map(function (t) {\n        return Number(t);\n      })\n    }) || this).rpc = r, n.bridge = o, n.qrcode = i, n.pollingInterval = s, n.handleChainChanged = n.handleChainChanged.bind(dn(n)), n.handleAccountsChanged = n.handleAccountsChanged.bind(dn(n)), n.handleDisconnect = n.handleDisconnect.bind(dn(n)), n;\n  }\n\n  cn(e, t);\n  var n = e.prototype;\n  return n.handleChainChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'chainChanged' event with payload\", t), this.emitUpdate({\n      chainId: t\n    });\n  }, n.handleAccountsChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'accountsChanged' event with payload\", t), this.emitUpdate({\n      account: t[0]\n    });\n  }, n.handleDisconnect = function () {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'disconnect' event\"), this.emitDeactivate(), this.walletConnectProvider && (this.walletConnectProvider.stop(), this.walletConnectProvider.removeListener(\"chainChanged\", this.handleChainChanged), this.walletConnectProvider.removeListener(\"accountsChanged\", this.handleAccountsChanged), this.walletConnectProvider = void 0), this.emitDeactivate();\n  }, n.activate = function () {\n    try {\n      var t = function () {\n        function t() {\n          return Promise.resolve(e.walletConnectProvider.enable().then(function (t) {\n            return t[0];\n          }).catch(function (t) {\n            if (\"User closed modal\" === t.message) throw new pn();\n            throw t;\n          })).then(function (t) {\n            return e.walletConnectProvider.on(\"disconnect\", e.handleDisconnect), e.walletConnectProvider.on(\"chainChanged\", e.handleChainChanged), e.walletConnectProvider.on(\"accountsChanged\", e.handleAccountsChanged), {\n              provider: e.walletConnectProvider,\n              account: t\n            };\n          });\n        }\n\n        var n = function () {\n          if (!e.walletConnectProvider.wc.connected) return Promise.resolve(e.walletConnectProvider.wc.createSession({\n            chainId: Number(Object.keys(e.rpc)[0])\n          })).then(function () {\n            e.emit(\"URI_AVAILABLE\", e.walletConnectProvider.wc.uri);\n          });\n        }();\n\n        return n && n.then ? n.then(t) : t();\n      },\n          e = this,\n          n = function () {\n        if (!e.walletConnectProvider) return Promise.resolve(import(\"./index-de390270.js\")).then(function (t) {\n          var n = t.default;\n          e.walletConnectProvider = new n({\n            bridge: e.bridge,\n            rpc: e.rpc,\n            qrcode: e.qrcode,\n            pollingInterval: e.pollingInterval\n          });\n        });\n      }();\n\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getProvider = function () {\n    try {\n      return Promise.resolve(this.walletConnectProvider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getChainId = function () {\n    try {\n      return Promise.resolve(this.walletConnectProvider.send(\"eth_chainId\"));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.getAccount = function () {\n    try {\n      return Promise.resolve(this.walletConnectProvider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n.deactivate = function () {\n    this.walletConnectProvider && (this.walletConnectProvider.stop(), this.walletConnectProvider.removeListener(\"disconnect\", this.handleDisconnect), this.walletConnectProvider.removeListener(\"chainChanged\", this.handleChainChanged), this.walletConnectProvider.removeListener(\"accountsChanged\", this.handleAccountsChanged));\n  }, n.close = function () {\n    try {\n      var t;\n      return Promise.resolve(null == (t = this.walletConnectProvider) ? void 0 : t.close()).then(function () {});\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}($t);\n\nvar gn = function (t) {\n  var e, n;\n\n  function r(e) {\n    var n,\n        r = e.chainId,\n        o = e.initOptions,\n        i = void 0 === o ? {} : o,\n        s = e.constructorOptions,\n        c = void 0 === s ? {} : s,\n        a = e.loginOptions,\n        u = void 0 === a ? {} : a;\n    return (n = t.call(this, {\n      supportedChainIds: [r]\n    }) || this).chainId = r, n.initOptions = i, n.constructorOptions = c, n.loginOptions = u, n;\n  }\n\n  n = t, (e = r).prototype = Object.create(n.prototype), e.prototype.constructor = e, e.__proto__ = n;\n  var o = r.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.torus.login(e.loginOptions).then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.torus.provider,\n            account: t\n          };\n        });\n      },\n          e = this,\n          n = function () {\n        if (!e.torus) return Promise.resolve(import(\"./torus.cjs-a3af3155.js\")).then(function (t) {\n          var n = t.default;\n          return e.torus = new n(e.constructorOptions), Promise.resolve(e.torus.init(e.initOptions)).then(function () {});\n        });\n      }();\n\n      return Promise.resolve(n && n.then ? n.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.torus.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.chainId);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.torus.ethereum.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.torus.cleanUp()).then(function () {\n        t.torus = void 0;\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.close = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.torus.logout()).then(function () {\n        t.emitDeactivate();\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r;\n}($t);\n\nconst mn = t.createContext(null);\n\nfunction vn() {\n  const t = n(mn);\n  if (null === t) throw new Error(\"useWallet() can only be used inside of <UseWalletProvider />, please declare it at a higher level.\");\n\n  const r = function () {\n    const t = n(mn),\n          [e, r] = a(null),\n          c = o(!1),\n          u = i(() => (c.current = !0, t.addBlockNumberListener(r), e), [t, e]);\n    return s(() => {\n      if (c.current) return t.addBlockNumberListener(r), () => {\n        t.removeBlockNumberListener(r);\n      };\n    }, [c, t]), u;\n  }(),\n        {\n    wallet: c\n  } = t;\n\n  return e(() => ({ ...c,\n    getBlockNumber: r\n  }), [r, c]);\n}\n\nfunction yn({\n  account: t,\n  ethereum: e,\n  pollBalanceInterval: n\n}) {\n  const [r, o] = a(\"-1\");\n  return s(() => {\n    if (!t || !e) return;\n    let r = !1;\n    const i = en((t, e, n) => {\n      let o = \"-1\";\n      return {\n        request: async () => async function (t, e) {\n          return tn(t, \"eth_getBalance\", [e, \"latest\"]);\n        }(e, t).then(t => t ? qt.BigInt(t).toString() : \"-1\").catch(() => \"-1\"),\n\n        onResult(t) {\n          r || t === o || (o = t, n(t));\n        }\n\n      };\n    }, n)(t, e, o);\n    return () => {\n      r = !0, i(), o(\"-1\");\n    };\n  }, [t, e, n]), r;\n}\n\nfunction bn({\n  ethereum: t,\n  pollBlockNumberInterval: e\n}) {\n  const n = o(null),\n        r = o(new Set()),\n        c = i(t => {\n    r.current.has(t) || (t(n.current), r.current.add(t));\n  }, []),\n        a = i(t => {\n    r.current.delete(t);\n  }, []),\n        u = i(t => {\n    n.current !== t && (n.current = t, r.current.forEach(e => e(t)));\n  }, []);\n  return s(() => {\n    if (!t) return void u(null);\n    let n = !1;\n    const r = en(() => ({\n      request: () => async function (t) {\n        return tn(t, \"eth_blockNumber\", []);\n      }(t),\n      onResult: t => {\n        n || u(null === t ? null : qt.BigInt(t).toString());\n      }\n    }), e)();\n    return () => {\n      n = !0, r();\n    };\n  }, [t, e, u]), {\n    addBlockNumberListener: c,\n    removeBlockNumberListener: a\n  };\n}\n\nfunction wn({\n  chainId: r,\n  children: c,\n  connectors: h,\n  pollBalanceInterval: f,\n  pollBlockNumberInterval: d\n}) {\n  if (null !== n(mn)) throw new Error(\"<UseWalletProvider /> has already been declared.\");\n  const [p, _] = a(null),\n        [g, m] = a(null),\n        [v, y] = a(null),\n        [b, w] = a(\"disconnected\"),\n        E = Ft(),\n        C = o(0),\n        {\n    account: O,\n    library: P\n  } = E,\n        N = yn({\n    account: O,\n    ethereum: P,\n    pollBalanceInterval: f\n  }),\n        {\n    addBlockNumberListener: I,\n    removeBlockNumberListener: S\n  } = bn({\n    ethereum: P,\n    pollBlockNumberInterval: d\n  }),\n        D = e(() => function (t, e = {}) {\n    const [n, r] = Object.entries(e).reduce(([t, e], [n, r]) => \"function\" == typeof r.web3ReactConnector ? [{ ...t,\n      [n]: r\n    }, e] : [t, [...e, [n, r]]], [{}, []]),\n          o = {\n      injected: {\n        web3ReactConnector: ({\n          chainId: t\n        }) => new $e({\n          supportedChainIds: [t]\n        }),\n\n        handleActivationError(t) {\n          if (t instanceof qe) return new on();\n        }\n\n      },\n      frame: {\n        web3ReactConnector: ({\n          chainId: t\n        }) => new Ae({\n          supportedChainIds: [t]\n        }),\n        handleActivationError: t => t instanceof De ? new on() : t.message.startsWith(\"JSON.parse\") ? new Error(\"There seems to be an issue when trying to connect to Frame.\") : void 0\n      },\n      fortmatic: {\n        web3ReactConnector({\n          chainId: t,\n          apiKey: e\n        }) {\n          if (!e) throw new sn(\"The Fortmatic connector requires apiKey to be set.\");\n          return new Jt({\n            apiKey: e,\n            chainId: t\n          });\n        }\n\n      },\n      portis: {\n        web3ReactConnector({\n          chainId: t,\n          dAppId: e\n        }) {\n          if (!e) throw new sn(\"The Portis connector requires dAppId to be set.\");\n          return new Ge({\n            dAppId: e,\n            networks: [t]\n          });\n        }\n\n      },\n      provided: {\n        web3ReactConnector: ({\n          chainId: t,\n          provider: e\n        }) => new u({\n          provider: e,\n          supportedChainIds: [t]\n        }),\n\n        handleActivationError(t) {\n          if (t instanceof l) return new on();\n        }\n\n      },\n      authereum: {\n        web3ReactConnector: ({\n          chainId: t\n        }) => new Gt({\n          chainId: t\n        })\n      },\n      squarelink: {\n        web3ReactConnector: ({\n          chainId: t,\n          clientId: e,\n          options: n\n        }) => new Je({\n          clientId: e,\n          networks: [t],\n          options: n\n        })\n      },\n      torus: {\n        web3ReactConnector: ({\n          chainId: t,\n          initOptions: e,\n          constructorOptions: n\n        }) => new gn({\n          chainId: t,\n          constructorOptions: n,\n          initOptions: e\n        })\n      },\n      walletconnect: {\n        web3ReactConnector({\n          chainId: t,\n          rpcUrl: e,\n          bridge: n,\n          pollingInterval: r\n        }) {\n          if (!e) throw new sn(\"The WalletConnect connector requires rpcUrl to be set.\");\n          if (!/^https?:\\/\\//.test(e)) throw new sn(\"The WalletConnect connector requires rpcUrl to be an HTTP URL.\");\n          return new _n({\n            bridge: n,\n            pollingInterval: r,\n            qrcode: !0,\n            rpc: {\n              [t]: e\n            }\n          });\n        },\n\n        handleActivationError(t) {\n          if (t instanceof pn) return new on();\n        }\n\n      },\n      walletlink: {\n        web3ReactConnector({\n          chainId: t,\n          url: e,\n          appName: n,\n          appLogoUrl: r\n        }) {\n          if (1 !== t) throw new sn(\"The WalletLink connector requires chainId to be 1.\");\n          if (!/^https?:\\/\\//.test(e)) throw new sn(\"The WalletLink connector requires url to be an HTTP URL.\");\n          return new Xe({\n            url: e,\n            appName: n,\n            appLogoUrl: r\n          });\n        }\n\n      },\n      ...n\n    };\n\n    for (const [t, e] of r) o[t] && (o[t].config = e);\n\n    return o;\n  }(0, h), [r, h]),\n        A = i(() => {\n    E.active && E.deactivate(), _(null), m(null), w(\"disconnected\");\n  }, [E]),\n        R = i(async (t = \"injected\") => {\n    const e = ++C.current;\n    if (A(), e !== C.current) return;\n    if (!D[t]) return w(\"error\"), void m(new rn(t));\n    w(\"connecting\");\n    const n = D[t],\n          o = n && n.web3ReactConnector && n.web3ReactConnector({\n      chainId: r,\n      ...(n.config || {})\n    });\n    if (!o) return w(\"error\"), void m(new rn(t));\n\n    try {\n      _(t), await E.activate(o, null, !0), w(\"connected\");\n    } catch (t) {\n      if (e !== C.current) return;\n      if (_(null), w(\"error\"), t instanceof Bt) return void m(new nn(-1, r));\n\n      if (n.handleActivationError) {\n        const e = n.handleActivationError(t);\n        if (e) return void m(e);\n      }\n\n      m(t);\n    }\n  }, [r, D, A, E]);\n  s(() => {\n    if (!O || !P) return;\n    let t = !1;\n    return y(null), async function (t, e) {\n      try {\n        return \"0x\" !== (await tn(t, \"eth_getCode\", [e]));\n      } catch (t) {\n        return !1;\n      }\n    }(P, O).then(e => {\n      t || (w(\"connected\"), y(e ? \"contract\" : \"normal\"));\n    }), () => {\n      t = !0, w(\"disconnected\"), y(null);\n    };\n  }, [O, P]);\n  const k = e(() => ({\n    _web3ReactContext: E,\n    account: O || null,\n    balance: N,\n    chainId: r,\n    connect: R,\n    connector: p,\n    connectors: D,\n    error: g,\n    ethereum: P,\n    networkName: Qe(r),\n    reset: A,\n    status: b,\n    type: v\n  }), [O, N, r, R, p, D, g, P, v, A, b, E]);\n  return t.createElement(mn.Provider, {\n    value: {\n      addBlockNumberListener: I,\n      pollBalanceInterval: f,\n      pollBlockNumberInterval: d,\n      removeBlockNumberListener: S,\n      wallet: k\n    }\n  }, c);\n}\n\nfunction En(e) {\n  return t.createElement(Vt, {\n    getLibrary: t => t\n  }, t.createElement(wn, e));\n}\n\nwn.propTypes = {\n  chainId: ct.number,\n  children: ct.node,\n  connectors: ct.objectOf(ct.object),\n  pollBalanceInterval: ct.number,\n  pollBlockNumberInterval: ct.number\n}, wn.defaultProps = {\n  chainId: 1,\n  connectors: {},\n  pollBalanceInterval: 2e3,\n  pollBlockNumberInterval: 5e3\n}, En.propTypes = wn.propTypes, En.defaultProps = wn.defaultProps;\nexport { on as C, En as U, nn as a, rn as b, vn as c, g as d, _ as e, d as f, p as g, m as h, h as r, vn as u };","map":null,"metadata":{},"sourceType":"module"}