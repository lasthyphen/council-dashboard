{"ast":null,"code":"import { ethers } from 'ethers';\nimport { erc20ABI, forwarderAbi, forwarderFeeAbi } from './abis';\nimport { isFullMethodSignature } from './app';\nexport async function createDirectTransaction(sender, destination, methodAbiFragment, params) {\n  let transactionOptions = {}; // If an extra parameter has been provided, it is the transaction options if it is an object\n\n  if (methodAbiFragment.inputs.length + 1 === params.length && typeof params[params.length - 1] === 'object') {\n    const options = params.pop();\n    transactionOptions = { ...transactionOptions,\n      ...options\n    };\n  }\n\n  const ethersInterface = new ethers.utils.Interface([methodAbiFragment]); // The direct transaction we eventually want to perform\n\n  return { ...transactionOptions,\n    from: sender,\n    to: destination,\n    data: ethersInterface.encodeFunctionData(ethers.utils.FunctionFragment.from(methodAbiFragment), params)\n  };\n}\nexport async function createDirectTransactionForApp(sender, app, methodSignature, params) {\n  if (!app) {\n    throw new Error(`Could not create transaction due to missing app artifact`);\n  }\n\n  const destination = app.address;\n\n  if (!app.abi) {\n    throw new Error(`No ABI specified in artifact for ${destination}`);\n  }\n\n  const methodAbiFragment = app.abi.find(method => {\n    // If the full signature isn't given, just find the first overload declared\n    if (!isFullMethodSignature(methodSignature)) {\n      return method.name === methodSignature;\n    } // Fallback functions don't have inputs in the ABI\n\n\n    const currentParameterTypes = Array.isArray(method.inputs) ? method.inputs.map(({\n      type\n    }) => type) : [];\n    const currentMethodSignature = `${method.name}(${currentParameterTypes.join(',')})`;\n    return currentMethodSignature === methodSignature;\n  });\n\n  if (!methodAbiFragment) {\n    throw new Error(`${methodSignature} not found on ABI for ${destination}`);\n  }\n\n  return createDirectTransaction(sender, destination, methodAbiFragment, params);\n}\nexport function createForwarderTransactionBuilder(sender, directTransaction) {\n  const forwarder = new ethers.utils.Interface(forwarderAbi);\n  return (forwarderAddress, script) => ({ ...directTransaction,\n    from: sender,\n    to: forwarderAddress,\n    data: forwarder.encodeFunctionData('forward', [script])\n  });\n}\nexport async function buildPretransaction(transaction, provider) {\n  // Token allowance pretransactionn\n  const {\n    from,\n    to,\n    token: {\n      address: tokenAddress,\n      value: tokenValue,\n      spender\n    }\n  } = transaction; // Approve the transaction destination unless an spender is passed to approve a different contract\n\n  const approveSpender = spender || to;\n  const tokenContract = new ethers.Contract(tokenAddress, erc20ABI, provider);\n  const balance = await tokenContract.balanceOf(from);\n  const tokenValueBN = BigInt(tokenValue);\n\n  if (BigInt(balance) < tokenValueBN) {\n    throw new Error(`Balance too low. ${from} balance of ${tokenAddress} token is ${balance} (attempting to send ${tokenValue})`);\n  }\n\n  const allowance = await tokenContract.allowance(from, approveSpender);\n  const allowanceBN = BigInt(allowance); // If allowance is already greater than or equal to amount, there is no need to do an approve transaction\n\n  if (allowanceBN < tokenValueBN) {\n    if (allowanceBN > BigInt(0)) {\n      // TODO: Actually handle existing approvals (some tokens fail when the current allowance is not 0)\n      console.warn(`${from} already approved ${approveSpender}. In some tokens, approval will fail unless the allowance is reset to 0 before re-approving again.`);\n    }\n\n    const erc20 = new ethers.utils.Interface(erc20ABI);\n    return {\n      from,\n      to: tokenAddress,\n      data: erc20.encodeFunctionData('approve', [approveSpender, tokenValue])\n    };\n  }\n\n  return undefined;\n}\nexport async function buildForwardingFeePretransaction(forwardingTransaction, provider) {\n  const {\n    to: forwarderAddress,\n    from\n  } = forwardingTransaction;\n  const forwarderFee = new ethers.Contract(forwarderAddress, forwarderFeeAbi, provider);\n  const feeDetails = {\n    amount: BigInt(0),\n    tokenAddress: ''\n  };\n\n  try {\n    const overrides = {\n      from\n    }; // Passing the EOA as `msg.sender` to the forwardFee call is useful for use cases where the fee differs relative to the account\n\n    const [tokenAddress, amount] = await forwarderFee.forwardFee(overrides); // forwardFee() returns (address, uint256)\n\n    feeDetails.tokenAddress = tokenAddress;\n    feeDetails.amount = BigInt(amount);\n  } catch (err) {// Not all forwarders implement the `forwardFee()` interface\n  }\n\n  if (feeDetails.tokenAddress && feeDetails.amount > BigInt(0)) {\n    // Needs a token approval pretransaction\n    const forwardingTxWithTokenData = { ...forwardingTransaction,\n      token: {\n        address: feeDetails.tokenAddress,\n        spender: forwarderAddress,\n        value: feeDetails.amount.toString()\n      }\n    };\n    return buildPretransaction(forwardingTxWithTokenData, provider);\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"module"}