{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkConnection = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst types_1 = require(\"../types\");\n\nconst ClientMessage_1 = require(\"./ClientMessage\");\n\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\n\nconst ServerMessage_1 = require(\"./ServerMessage\");\n\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * WalletLink Connection\n */\n\nclass WalletLinkConnection {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param serverUrl Walletlinkd RPC URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(sessionId, sessionKey, serverUrl, WebSocketClass = WebSocket) {\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = types_1.IntNumber(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(serverUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws; // attempt to reconnect every 5 seconds when disconnected\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED state\n    operators_1.skip(1), // if DISCONNECTED and not destroyed\n    operators_1.filter(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), // wait 5 seconds\n    operators_1.delay(5000), // check whether it's destroyed again\n    operators_1.filter(_ => !this.destroyed), // reconnect\n    operators_1.flatMap(_ => ws.connect()), operators_1.retry()).subscribe()); // perform authentication upon connection\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED and CONNECTING states\n    operators_1.skip(2), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe(operators_1.tap(_ => this.sendIsLinked()), operators_1.tap(_ => this.sendGetSessionConfig()), operators_1.map(_ => true)), // if not CONNECTED, emit false immediately\n    rxjs_1.of(false))), operators_1.distinctUntilChanged(), operators_1.catchError(_ => rxjs_1.of(false))).subscribe(connected => this.connectedSubject.next(connected))); // send heartbeat every n seconds while connected\n\n    this.subscriptions.add(ws.connectionState$.pipe( // ignore initial DISCONNECTED state\n    operators_1.skip(1), operators_1.switchMap(cs => rxjs_1.iif(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, // if CONNECTED, start the heartbeat timer\n    rxjs_1.timer(0, HEARTBEAT_INTERVAL)))).subscribe(i => // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat())); // handle server's heartbeat responses\n\n    this.subscriptions.add(ws.incomingData$.pipe(operators_1.filter(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat())); // handle link status updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe(operators_1.filter(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    })); // handle session config updates\n\n    this.subscriptions.add(ws.incomingJSONData$.pipe(operators_1.filter(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      const msg = m;\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n\n\n  connect() {\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n\n    this.ws.connect().subscribe();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletLinkConnection\n   */\n\n\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    this.destroyed = true;\n  }\n  /**\n   * Emit true if connected and authenticated, else false\n   * @returns an Observable\n   */\n\n\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\n   * Emit once connected\n   * @returns an Observable\n   */\n\n\n  get onceConnected$() {\n    return this.connected$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n  }\n  /**\n   * Emit true if linked (a guest has joined before)\n   * @returns an Observable\n   */\n\n\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\n   * Emit once when linked\n   * @returns an Observable\n   */\n\n\n  get onceLinked$() {\n    return this.linked$.pipe(operators_1.filter(v => v), operators_1.take(1), operators_1.map(() => void 0));\n  }\n  /**\n   * Emit current session config if available, and subsequent updates\n   * @returns an Observable for the session config\n   */\n\n\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\n   * Emit incoming Event messages\n   * @returns an Observable for the messages\n   */\n\n\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe(operators_1.filter(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), operators_1.map(m => m));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns an Observable that completes when successful\n   */\n\n\n  setSessionMetadata(key, value) {\n    const message = ClientMessage_1.ClientMessageSetSessionConfig({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param data event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns an Observable that emits event ID when successful\n   */\n\n\n  publishEvent(event, data, callWebhook = false) {\n    const message = ClientMessage_1.ClientMessagePublishEvent({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe(operators_1.flatMap(_ => this.makeRequest(message)), operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n\n      return res.eventId;\n    }));\n  }\n\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n\n  makeRequest(message, timeout = REQUEST_TIMEOUT) {\n    const reqId = message.id;\n\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return rxjs_1.throwError(err);\n    } // await server message with corresponding id\n\n\n    return this.ws.incomingJSONData$.pipe(operators_1.timeoutWith(timeout, rxjs_1.throwError(new Error(`request ${reqId} timed out`))), operators_1.filter(m => m.id === reqId), operators_1.take(1));\n  }\n\n  authenticate() {\n    const msg = ClientMessage_1.ClientMessageHostSession({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe(operators_1.map(res => {\n      if (ServerMessage_1.isServerMessageFail(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n\n  sendIsLinked() {\n    const msg = ClientMessage_1.ClientMessageIsLinked({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n  sendGetSessionConfig() {\n    const msg = ClientMessage_1.ClientMessageGetSessionConfig({\n      id: types_1.IntNumber(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n\n}\n\nexports.WalletLinkConnection = WalletLinkConnection;","map":null,"metadata":{},"sourceType":"script"}