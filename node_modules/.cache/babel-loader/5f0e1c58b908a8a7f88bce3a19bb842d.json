{"ast":null,"code":"var inherits = require('util').inherits;\n\nvar ethUtil = require('ethereumjs-util');\n\nvar BN = ethUtil.BN;\n\nvar clone = require('clone');\n\nvar cacheUtils = require('../util/rpc-cache-utils.js');\n\nvar Stoplight = require('../util/stoplight.js');\n\nvar Subprovider = require('./subprovider.js');\n\nmodule.exports = BlockCacheProvider;\ninherits(BlockCacheProvider, Subprovider);\n\nfunction BlockCacheProvider(opts) {\n  var self = this;\n  opts = opts || {}; // set initialization blocker\n\n  self._ready = new Stoplight();\n  self.strategies = {\n    perma: new ConditionalPermaCacheStrategy({\n      eth_getTransactionByHash: containsBlockhash,\n      eth_getTransactionReceipt: containsBlockhash\n    }),\n    block: new BlockCacheStrategy(self),\n    fork: new BlockCacheStrategy(self)\n  };\n} // setup a block listener on 'setEngine'\n\n\nBlockCacheProvider.prototype.setEngine = function (engine) {\n  var self = this;\n  self.engine = engine; // unblock initialization after first block\n\n  engine.once('block', function (block) {\n    self.currentBlock = block;\n\n    self._ready.go(); // from now on, empty old cache every block\n\n\n    engine.on('block', clearOldCache);\n  });\n\n  function clearOldCache(newBlock) {\n    var previousBlock = self.currentBlock;\n    self.currentBlock = newBlock;\n    if (!previousBlock) return;\n    self.strategies.block.cacheRollOff(previousBlock);\n    self.strategies.fork.cacheRollOff(previousBlock);\n  }\n};\n\nBlockCacheProvider.prototype.handleRequest = function (payload, next, end) {\n  var self = this; // skip cache if told to do so\n\n  if (payload.skipCache) {\n    // console.log('CACHE SKIP - skip cache if told to do so')\n    return next();\n  } // Ignore block polling requests.\n\n\n  if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {\n    // console.log('CACHE SKIP - Ignore block polling requests.')\n    return next();\n  } // wait for first block\n\n\n  self._ready.await(function () {\n    // actually handle the request\n    self._handleRequest(payload, next, end);\n  });\n};\n\nBlockCacheProvider.prototype._handleRequest = function (payload, next, end) {\n  var self = this;\n  var type = cacheUtils.cacheTypeForPayload(payload);\n  var strategy = this.strategies[type]; // If there's no strategy in place, pass it down the chain.\n\n  if (!strategy) {\n    return next();\n  } // If the strategy can't cache this request, ignore it.\n\n\n  if (!strategy.canCache(payload)) {\n    return next();\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload);\n  if (!blockTag) blockTag = 'latest';\n  var requestedBlockNumber;\n\n  if (blockTag === 'earliest') {\n    requestedBlockNumber = '0x00';\n  } else if (blockTag === 'latest') {\n    requestedBlockNumber = ethUtil.bufferToHex(self.currentBlock.number);\n  } else {\n    // We have a hex number\n    requestedBlockNumber = blockTag;\n  } //console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))\n  // end on a hit, continue on a miss\n\n\n  strategy.hitCheck(payload, requestedBlockNumber, end, function () {\n    // miss fallthrough to provider chain, caching the result on the way back up.\n    next(function (err, result, cb) {\n      // err is already handled by engine\n      if (err) return cb();\n      strategy.cacheResult(payload, result, requestedBlockNumber, cb);\n    });\n  });\n}; //\n// Cache Strategies\n//\n\n\nfunction PermaCacheStrategy() {\n  var self = this;\n  self.cache = {}; // clear cache every ten minutes\n\n  var timeout = setInterval(function () {\n    self.cache = {};\n  }, 10 * 60 * 1e3); // do not require the Node.js event loop to remain active\n\n  if (timeout.unref) timeout.unref();\n}\n\nPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n  var cached = this.cache[identifier];\n  if (!cached) return miss(); // If the block number we're requesting at is greater than or\n  // equal to the block where we cached a previous response,\n  // the cache is valid. If it's from earlier than the cache,\n  // send it back down to the client (where it will be recached.)\n\n  var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0;\n\n  if (cacheIsEarlyEnough) {\n    var clonedValue = clone(cached.result);\n    return hit(null, clonedValue);\n  } else {\n    return miss();\n  }\n};\n\nPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n\n  if (result) {\n    var clonedValue = clone(result);\n    this.cache[identifier] = {\n      blockNumber: requestedBlockNumber,\n      result: clonedValue\n    };\n  }\n\n  callback();\n};\n\nPermaCacheStrategy.prototype.canCache = function (payload) {\n  return cacheUtils.canCache(payload);\n}; //\n// ConditionalPermaCacheStrategy\n//\n\n\nfunction ConditionalPermaCacheStrategy(conditionals) {\n  this.strategy = new PermaCacheStrategy();\n  this.conditionals = conditionals;\n}\n\nConditionalPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss);\n};\n\nConditionalPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  var conditional = this.conditionals[payload.method];\n\n  if (conditional) {\n    if (conditional(result)) {\n      this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);\n    } else {\n      callback();\n    }\n  } else {\n    // Cache all requests that don't have a conditional\n    this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);\n  }\n};\n\nConditionalPermaCacheStrategy.prototype.canCache = function (payload) {\n  return this.strategy.canCache(payload);\n}; //\n// BlockCacheStrategy\n//\n\n\nfunction BlockCacheStrategy() {\n  this.cache = {};\n}\n\nBlockCacheStrategy.prototype.getBlockCacheForPayload = function (payload, blockNumberHex) {\n  var blockNumber = Number.parseInt(blockNumberHex, 16);\n  var blockCache = this.cache[blockNumber]; // create new cache if necesary\n\n  if (!blockCache) {\n    var newCache = {};\n    this.cache[blockNumber] = newCache;\n    blockCache = newCache;\n  }\n\n  return blockCache;\n};\n\nBlockCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {\n  var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n\n  if (!blockCache) {\n    return miss();\n  }\n\n  var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n  var cached = blockCache[identifier];\n\n  if (cached) {\n    return hit(null, cached);\n  } else {\n    return miss();\n  }\n};\n\nBlockCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {\n  if (result) {\n    var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    var identifier = cacheUtils.cacheIdentifierForPayload(payload);\n    blockCache[identifier] = result;\n  }\n\n  callback();\n};\n\nBlockCacheStrategy.prototype.canCache = function (payload) {\n  if (!cacheUtils.canCache(payload)) {\n    return false;\n  }\n\n  var blockTag = cacheUtils.blockTagForPayload(payload);\n  return blockTag !== 'pending';\n}; // naively removes older block caches\n\n\nBlockCacheStrategy.prototype.cacheRollOff = function (previousBlock) {\n  var self = this;\n  var previousHex = ethUtil.bufferToHex(previousBlock.number);\n  var oldBlockNumber = Number.parseInt(previousHex, 16); // clear old caches\n\n  Object.keys(self.cache).map(Number).filter(function (num) {\n    return num <= oldBlockNumber;\n  }).forEach(function (num) {\n    return delete self.cache[num];\n  });\n}; // util\n\n\nfunction compareHex(hexA, hexB) {\n  var numA = parseInt(hexA, 16);\n  var numB = parseInt(hexB, 16);\n  return numA === numB ? 0 : numA > numB ? 1 : -1;\n}\n\nfunction hexToBN(hex) {\n  return new BN(ethUtil.toBuffer(hex));\n}\n\nfunction containsBlockhash(result) {\n  if (!result) return false;\n  if (!result.blockHash) return false;\n  var hasNonZeroHash = hexToBN(result.blockHash).gt(new BN(0));\n  return hasNonZeroHash;\n}","map":null,"metadata":{},"sourceType":"script"}