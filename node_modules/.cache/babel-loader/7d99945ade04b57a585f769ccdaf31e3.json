{"ast":null,"code":"function normalizeConnectorConfig(connector) {\n  var _a;\n\n  if (Array.isArray(connector)) {\n    // Returning `{} as Config` shouldn’t be an issue, because the config type\n    // of an app connector should have all its properties declared as optional.\n    return [connector[0], (_a = connector[1]) !== null && _a !== void 0 ? _a : {}];\n  }\n\n  if (typeof connector === 'string') {\n    return [connector, {}];\n  }\n\n  throw new Error('The connector should be passed as a string or an array.');\n} // Check if an app is valid. We are not using instanceof here, because the\n// passed app might come from the final app dependency, while @connect-core\n// might come from the app connector they are using, with two different\n// versions. It also makes it easier to work with linked dependencies, as it\n// creates the same kind of issues.\n\n\nfunction isAppValid(app) {\n  return app && app.name && app.address && app.appId && app.version;\n}\n\nexport function createAppConnector(callback) {\n  return async function connect(app, connector) {\n    app = await app;\n\n    if (!isAppValid(app)) {\n      throw new Error(`App connector: the passed value doesn’t appear to be an App.`);\n    }\n\n    const {\n      connection\n    } = app.organization;\n    const {\n      orgConnector\n    } = connection; // App connector config.\n\n    const [connectorName, connectorConfig] = normalizeConnectorConfig( // Contrary to the main connect() function, app connectors don’t require\n    // the connector to be passed. In this case, the name of the org\n    // connector (e.g. `name`) is used instead.\n    connector || orgConnector.name);\n    const connectedApp = await callback({\n      app,\n      config: connectorConfig,\n      connector: connectorName,\n      ipfs: connection.ipfs,\n      network: orgConnector.network,\n      orgConnector,\n      verbose: connection.verbose\n    });\n    return Object.assign(connectedApp, app);\n  };\n}","map":null,"metadata":{},"sourceType":"module"}