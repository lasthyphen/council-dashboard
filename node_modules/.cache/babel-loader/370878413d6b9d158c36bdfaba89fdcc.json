{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.evaluate = evaluate, exports.Evaluator = void 0;\n\nvar _ethers = require(\"ethers\"),\n    _types = _interopRequireDefault(require(\"../types\")),\n    _HelperManager = _interopRequireDefault(require(\"../helpers/HelperManager\")),\n    _defaults = require(\"../defaults\");\n/**\n* @module radspec/evaluator\n*/\n\n/**\n* A value coupled with a type\n*\n* @class TypedValue\n* @param {string} type The type of the value\n* @param {*} value The value\n* @property {string} type\n* @property {*} value\n*/\n\n\nclass TypedValue {\n  constructor(type, value) {\n    if (this.type = type, this.value = value, _types.default.isInteger(this.type) && !_ethers.BigNumber.isBigNumber(this.value) && (this.value = _ethers.BigNumber.from(this.value)), \"address\" === this.type) {\n      if (!_ethers.ethers.utils.isAddress(this.value)) throw new Error(`Invalid address \"${this.value}\"`);\n      this.value = _ethers.ethers.utils.getAddress(this.value);\n    }\n  }\n  /**\n  * Get the string representation of the wrapped value\n  *\n  * @return {string}\n  */\n\n\n  toString() {\n    return this.value.toString();\n  }\n\n}\n/**\n* Walks an AST and evaluates each node.\n*\n* @class Evaluator\n* @param {radspec/parser/AST} ast The AST to evaluate\n* @param {radspec/Bindings} bindings An object of bindings and their values\n* @param {?Object} options An options object\n* @param {?Object} options.availablehelpers Available helpers\n* @param {?ethers.providers.Provider} options.provider EIP 1193 provider\n* @param {?string} options.to The destination address for this expression's transaction\n* @property {radspec/parser/AST} ast\n* @property {radspec/Bindings} bindings\n*/\n\n\nclass Evaluator {\n  constructor(ast, bindings, {\n    availableHelpers = {},\n    provider,\n    from,\n    to,\n    value = \"0\",\n    data\n  } = {}) {\n    this.ast = ast, this.bindings = bindings, this.provider = provider || new _ethers.ethers.providers.WebSocketProvider(_defaults.DEFAULT_ETH_NODE), this.from = from && new TypedValue(\"address\", from), this.to = to && new TypedValue(\"address\", to), this.value = new TypedValue(\"uint\", _ethers.BigNumber.from(value)), this.data = data && new TypedValue(\"bytes\", data), this.helpers = new _HelperManager.default(availableHelpers);\n  }\n  /**\n  * Evaluate an array of AST nodes.\n  *\n  * @param  {Array<radspec/parser/Node>} nodes\n  * @return {Promise<Array<string>>}\n  */\n\n\n  async evaluateNodes(nodes) {\n    return Promise.all(nodes.map(this.evaluateNode.bind(this)));\n  }\n  /**\n  * Evaluate a single node.\n  *\n  * @param  {radspec/parser/Node} node\n  * @return {Promise<string>}\n  */\n\n\n  async evaluateNode(node) {\n    var _Mathceil = Math.ceil;\n    if (\"ExpressionStatement\" === node.type) return (await this.evaluateNodes(node.body)).join(\" \");\n    if (\"GroupedExpression\" === node.type) return this.evaluateNode(node.body);\n    if (\"MonologueStatement\" === node.type) return new TypedValue(\"string\", node.value);\n    if (\"StringLiteral\" === node.type) return new TypedValue(\"string\", node.value || \"\");\n    if (\"NumberLiteral\" === node.type) return new TypedValue(\"int256\", node.value);\n\n    if (\"BytesLiteral\" === node.type) {\n      const length = _Mathceil((node.value.length - 2) / 2);\n\n      return 32 < length && this.panic(\"Byte literal represents more than 32 bytes\"), new TypedValue(`bytes${length}`, node.value);\n    }\n\n    if (\"BoolLiteral\" === node.type) return new TypedValue(\"bool\", \"true\" === node.value);\n\n    if (\"BinaryExpression\" === node.type) {\n      const left = await this.evaluateNode(node.left),\n            right = await this.evaluateNode(node.right); // String concatenation\n\n      if ((\"string\" === left.type || \"string\" === right.type) && \"PLUS\" === node.operator) return new TypedValue(\"string\", left.value.toString() + right.value.toString()); // TODO Additionally check that the type is signed if subtracting\n\n      switch (_types.default.isInteger(left.type) && _types.default.isInteger(right.type) || this.panic(`Cannot evaluate binary expression \"${node.operator}\" for non-integer types \"${left.type}\" and \"${right.type}\"`), node.operator) {\n        case \"PLUS\":\n          return new TypedValue(\"int256\", left.value.add(right.value));\n\n        case \"MINUS\":\n          return new TypedValue(\"int256\", left.value.sub(right.value));\n\n        case \"STAR\":\n          return new TypedValue(\"int256\", left.value.mul(right.value));\n\n        case \"POWER\":\n          return new TypedValue(\"int256\", left.value.pow(right.value));\n\n        case \"SLASH\":\n          return new TypedValue(\"int256\", left.value.div(right.value));\n\n        case \"MODULO\":\n          return new TypedValue(\"int256\", left.value.mod(right.value));\n\n        default:\n          this.panic(`Undefined binary operator \"${node.operator}\"`);\n      }\n    }\n\n    if (\"ComparisonExpression\" === node.type) {\n      const left = await this.evaluateNode(node.left),\n            right = await this.evaluateNode(node.right);\n      let leftValue = left.value,\n          rightValue = right.value;\n\n      const bothTypesAddress = (left, right) => // isAddress is true if type is address or bytes with size less than 20\n      _types.default.isAddress(left.type) && _types.default.isAddress(right.type),\n            bothTypesBytes = (left, right) => _types.default.types.bytes.isType(left.type) && _types.default.types.bytes.isType(right.type);\n\n      switch (bothTypesAddress(left, right) || bothTypesBytes(left, right) ? (leftValue = _ethers.BigNumber.from(leftValue), rightValue = _ethers.BigNumber.from(rightValue)) : (!_types.default.isInteger(left.type) || !_types.default.isInteger(right.type)) && this.panic(`Cannot evaluate binary expression \"${node.operator}\" for non-integer or fixed-size bytes types \"${left.type}\" and \"${right.type}\"`), node.operator) {\n        case \"GREATER\":\n          return new TypedValue(\"bool\", leftValue.gt(rightValue));\n\n        case \"GREATER_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.gte(rightValue));\n\n        case \"LESS\":\n          return new TypedValue(\"bool\", leftValue.lt(rightValue));\n\n        case \"LESS_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.lte(rightValue));\n\n        case \"EQUAL_EQUAL\":\n          return new TypedValue(\"bool\", leftValue.eq(rightValue));\n\n        case \"BANG_EQUAL\":\n          return new TypedValue(\"bool\", !leftValue.eq(rightValue));\n      }\n    }\n\n    if (\"TernaryExpression\" === node.type) return (await this.evaluateNode(node.predicate)).value ? this.evaluateNode(node.left) : this.evaluateNode(node.right);\n\n    if (\"DefaultExpression\" === node.type) {\n      const left = await this.evaluateNode(node.left);\n      let leftFalsey;\n      return leftFalsey = _types.default.isInteger(left.type) ? left.value.isZero() : \"address\" === left.type || left.type.startsWith(\"bytes\") ? /^0x[0]*$/.test(left.value) : !left.value, leftFalsey ? this.evaluateNode(node.right) : left;\n    }\n\n    if (\"CallExpression\" === node.type) {\n      let target; // Inject self\n\n      target = \"Identifier\" === node.target.type && \"self\" === node.target.value ? this.to : await this.evaluateNode(node.target), \"bytes20\" !== target.type && \"address\" !== target.type ? this.panic(\"Target of call expression was not an address\") : !_ethers.ethers.utils.isAddress(target.value) && this.panic(`Invalid address \"${this.value}\"`);\n      const inputs = await this.evaluateNodes(node.inputs),\n            outputs = node.outputs,\n            selectedReturnValueIndex = outputs.findIndex(output => output.selected);\n      -1 === selectedReturnValueIndex && this.panic(`No selected return value for function call \"${node.callee}\"`);\n      const returnType = outputs[selectedReturnValueIndex].type,\n            abi = [{\n        name: node.callee,\n        type: \"function\",\n        inputs: inputs.map(({\n          type\n        }) => ({\n          type\n        })),\n        outputs: outputs.map(({\n          type\n        }) => ({\n          type\n        })),\n        stateMutability: \"view\"\n      }],\n            ethersInterface = new _ethers.ethers.utils.Interface(abi),\n            txData = ethersInterface.encodeFunctionData(node.callee, inputs.map(input => input.value.toString())),\n            data = await this.provider.call({\n        to: target.value,\n        data: txData\n      }),\n            decodeData = ethersInterface.decodeFunctionResult(node.callee, data);\n      return new TypedValue(returnType, decodeData[selectedReturnValueIndex]);\n    }\n\n    if (\"HelperFunction\" === node.type) {\n      const helperName = node.name;\n      this.helpers.exists(helperName) || this.panic(`${helperName} helper function is not defined`);\n      const inputs = await this.evaluateNodes(node.inputs),\n            result = await this.helpers.execute(helperName, inputs, {\n        provider: this.provider,\n        evaluator: this\n      });\n      return new TypedValue(result.type, result.value);\n    }\n\n    if (\"PropertyAccessExpression\" === node.type && \"msg\" === node.target.value) {\n      if (\"value\" === node.property) return this.value;\n      if (\"sender\" === node.property) return this.from;\n      if (\"data\" === node.property) return this.data;\n      this.panic(`Expecting value, sender or data property for msg identifier but got: ${node.property}`);\n    }\n\n    if (\"Identifier\" === node.type) {\n      if (\"self\" === node.value) return this.to;\n      this.bindings.hasOwnProperty(node.value) || this.panic(`Undefined binding \"${node.value}\"`);\n      const binding = this.bindings[node.value];\n      return new TypedValue(binding.type, binding.value);\n    }\n  }\n  /**\n  * Evaluate the entire AST.\n  *\n  * @return {string}\n  */\n\n\n  async evaluate() {\n    return this.evaluateNodes(this.ast.body).then(evaluatedNodes => evaluatedNodes.join(\"\"));\n  }\n  /**\n  * Report an error and abort evaluation.\n  *\n  * @param  {string} msg\n  */\n\n\n  panic(msg) {\n    throw new Error(`Error: ${msg}`);\n  }\n\n}\n/**\n* Evaluates an AST\n*\n* @memberof radspec/evaluator\n* @param {radspec/parser/AST} ast The AST to evaluate\n* @param {radspec/Bindings} bindings An object of bindings and their values\n* @param {?Object} options An options object\n* @param {?Object} options.availablehelpers Available helpers\n* @param {?ethers.providers.Provider} options.provider EIP 1193 provider\n* @param {?string} options.to The destination address for this expression's transaction\n* @return {string}\n*/\n\n\nexports.Evaluator = Evaluator;\n\nfunction evaluate(ast, bindings, options) {\n  return new Evaluator(ast, bindings, options).evaluate();\n}","map":null,"metadata":{},"sourceType":"script"}