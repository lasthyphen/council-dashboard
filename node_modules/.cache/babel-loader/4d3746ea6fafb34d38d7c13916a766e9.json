{"ast":null,"code":"const EventEmitter = require('events');\n\nconst uuid = require('uuid/v4');\n\nconst dev = process.env.NODE_ENV === 'development';\nlet XHR;\n\nclass HTTPConnection extends EventEmitter {\n  constructor(_XHR, url, options) {\n    super();\n    XHR = _XHR;\n    this.connected = false;\n    this.subscriptions = false;\n    this.status = 'loading';\n    this.url = url;\n    this.pollId = uuid();\n    setTimeout(() => this.create(), 0);\n  }\n\n  create() {\n    if (!XHR) return this.emit('error', new Error('No HTTP transport available'));\n    this.on('error', () => {\n      if (this.connected) this.close();\n    });\n    this.init();\n  }\n\n  init() {\n    this.send({\n      jsonrpc: '2.0',\n      method: 'eth_syncing',\n      params: [],\n      id: 1\n    }, (err, response) => {\n      if (err) return this.emit('error', err);\n      this.send({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'eth_pollSubscriptions',\n        params: [this.pollId, 'immediate']\n      }, (err, response) => {\n        if (!err) {\n          this.subscriptions = true;\n          this.pollSubscriptions();\n        }\n\n        this.connected = true;\n        this.emit('connect');\n      });\n    });\n  }\n\n  pollSubscriptions() {\n    this.send({\n      jsonrpc: '2.0',\n      id: 1,\n      method: 'eth_pollSubscriptions',\n      params: [this.pollId]\n    }, (err, result) => {\n      if (err) {\n        this.subscriptionTimeout = setTimeout(() => this.pollSubscriptions(), 10000);\n        return this.emit('error', err);\n      } else {\n        if (!this.closed) this.subscriptionTimeout = this.pollSubscriptions();\n\n        if (result) {\n          result.map(p => {\n            let parse;\n\n            try {\n              parse = JSON.parse(p);\n            } catch (e) {\n              parse = false;\n            }\n\n            return parse;\n          }).filter(n => n).forEach(p => this.emit('payload', p));\n        }\n      }\n    });\n  }\n\n  close() {\n    if (dev) console.log('Closing HTTP connection');\n    this.closed = true;\n    this.emit('close');\n    clearTimeout(this.subscriptionTimeout);\n    this.removeAllListeners();\n  }\n\n  filterStatus(res) {\n    if (res.status >= 200 && res.status < 300) return res;\n    const error = new Error(res.statusText);\n    error.res = res;\n    throw error.message;\n  }\n\n  error(payload, message, code = -1) {\n    this.emit('payload', {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        message,\n        code\n      }\n    });\n  }\n\n  send(payload, internal) {\n    if (this.closed) return this.error(payload, 'Not connected');\n\n    if (payload.method === 'eth_subscribe') {\n      if (this.subscriptions) {\n        payload.pollId = this.pollId;\n      } else {\n        return this.error(payload, 'Subscriptions are not supported by this HTTP endpoint');\n      }\n    }\n\n    const xhr = new XHR();\n    let responded = false;\n\n    const res = (err, result) => {\n      if (!responded) {\n        xhr.abort();\n        responded = true;\n\n        if (internal) {\n          internal(err, result);\n        } else {\n          const {\n            id,\n            jsonrpc\n          } = payload;\n          const load = err ? {\n            id,\n            jsonrpc,\n            error: {\n              message: err.message,\n              code: err.code\n            }\n          } : {\n            id,\n            jsonrpc,\n            result\n          };\n          this.emit('payload', load);\n        }\n      }\n    };\n\n    xhr.open('POST', this.url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    xhr.timeout = 60 * 1000;\n    xhr.onerror = res;\n    xhr.ontimeout = res;\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        try {\n          const response = JSON.parse(xhr.responseText);\n          res(response.error, response.result);\n        } catch (e) {\n          res(e);\n        }\n      }\n    };\n\n    xhr.send(JSON.stringify(payload));\n  }\n\n}\n\nmodule.exports = XHR => (url, options) => new HTTPConnection(XHR, url, options);","map":null,"metadata":{},"sourceType":"script"}