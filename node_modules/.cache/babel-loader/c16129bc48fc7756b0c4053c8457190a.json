{"ast":null,"code":"import { useMemo } from 'react';\nimport { useDashboardState } from '../components/Dashboard/DashboardStateProvider';\nimport { useCourtConfig } from '../providers/CourtConfig';\nimport { bigNum } from '../lib/math-utils';\nimport { isJurorCoherent } from '../utils/juror-draft-utils';\nimport { getAppealerFees, shouldAppealerBeRewarded } from '../utils/appeal-utils';\nimport { getRoundFees } from '../utils/dispute-utils';\nimport { useWallet } from '../providers/Wallet';\nimport { useJurorLastWithdrawalTimeSubscription } from './subscription-hooks';\nexport default function useJurorRewards() {\n  const courtConfig = useCourtConfig();\n  const wallet = useWallet();\n  const {\n    jurorDrafts,\n    appeals\n  } = useDashboardState();\n  const lastWithdrawalTime = useJurorLastWithdrawalTimeSubscription(wallet.account); // For arbitrable and appeal fees we will use a map where map = [disputeId, { amount, rounds }]\n  // Where `rounds` is the array of roundIds of non settled rounds\n  // This is useful as jurors could have rewards from many rounds for the same dispute\n  // which will need to be settled (in case they aren't) before withdrawing them from the treasury\n\n  return useMemo(() => {\n    if (!jurorDrafts || !appeals || !lastWithdrawalTime) return null; // Get ruling and disputes fees\n    // Only jurors that voted in consensus with the winning outcome can claim rewards (coherent jurors)\n    // We also include already settled rewards which have not been withdrawn from the treasury yet.\n\n    const {\n      rulingFees,\n      arbitrableFees\n    } = jurorDrafts.filter(jurorDraft => jurorDraft.round.settledPenalties && (!jurorDraft.rewarded || jurorDraft.rewardedAt > lastWithdrawalTime) && isJurorCoherent(jurorDraft)).reduce(({\n      rulingFees,\n      arbitrableFees\n    }, {\n      rewarded,\n      round,\n      weight\n    }) => {\n      const {\n        jurorFees,\n        coherentJurors,\n        collectedTokens,\n        dispute\n      } = round; // Calculate fees\n\n      const rulingFeesAmount = collectedTokens.mul(weight).div(coherentJurors);\n      const disputeFeesAmount = jurorFees.mul(weight).div(coherentJurors);\n      return {\n        rulingFees: rulingFees.add(rulingFeesAmount),\n        arbitrableFees: setOrUpdateFee(arbitrableFees, dispute.id, round.number, disputeFeesAmount, rewarded)\n      };\n    }, {\n      rulingFees: bigNum(0),\n      arbitrableFees: new Map()\n    }); // Before settling appeals it's required that the penalties for the round are settled, so we need to filter the ones that aren't\n    // We also need to check that the appealer should be rewarded.\n\n    const appealFees = appeals.filter(appeal => appeal.round.settledPenalties && (!appeal.settled || appeal.settledAt > lastWithdrawalTime) && shouldAppealerBeRewarded(appeal, wallet.account)).reduce((appealsFee, appeal) => {\n      const {\n        round,\n        settled\n      } = appeal; // We need to calculate the totalFees of the next round since this amount will be discounted from the appeal reward for the appealer\n\n      const nextRoundId = round.number + 1;\n      const nextRound = round.dispute.rounds[nextRoundId]; // It could happen that the appeal is never confirmed. In this case the appealer should get the entire appeal deposit\n\n      const totalFees = nextRound ? getRoundFees(nextRound, courtConfig) : bigNum(0);\n      const appealerFees = getAppealerFees(appeal, totalFees, wallet.account);\n      return setOrUpdateFee(appealsFee, round.dispute.id, round.number, appealerFees, settled);\n    }, new Map());\n    return {\n      anjRewards: rulingFees,\n      feeRewards: {\n        arbitrableFees: feeMapToArray(arbitrableFees),\n        appealFees: feeMapToArray(appealFees),\n        distribution: getDisputesFeesDistribution(arbitrableFees, appealFees)\n      }\n    };\n  }, [appeals, courtConfig, jurorDrafts, lastWithdrawalTime, wallet]);\n}\n/**\n * Adds or updates a fee entry on the map\n * @param {Map} feeMap Map contianing fee data\n * @param {Number} disputeId Id of the dispute\n * @param {Number} roundId Id of the round\n * @param {BigNum} feeAmount Amount of fees to add to the entry\n * @param {Boolean} settled True if fees for the given round are settled\n * @returns {Map} Updated map with the new entry or the amount updated\n */\n\nfunction setOrUpdateFee(feeMap, disputeId, roundId, feeAmount, settled = false) {\n  let feeEntry;\n\n  if (feeMap.has(disputeId)) {\n    const {\n      amount,\n      rounds,\n      settledAmount\n    } = feeMap.get(disputeId);\n    feeEntry = {\n      amount: amount.add(feeAmount),\n      settledAmount: settled ? settledAmount.add(feeAmount) : settledAmount,\n      rounds: [...rounds, ...(settled ? [] : [roundId])]\n    };\n  } else {\n    feeEntry = {\n      amount: feeAmount,\n      settledAmount: settled ? feeAmount : bigNum(0),\n      rounds: settled ? [] : [roundId]\n    };\n  }\n\n  feeMap.set(disputeId, feeEntry);\n  return feeMap;\n}\n/**\n * Creates a new array containing the total amount of fees per dispute\n * @param {Map} artbitrableFeesMap Map of arbitrable fees\n * @param {Map} appealFeesMap Map of appeal fees\n * @returns {Array} New array with the total fees for each dispute\n */\n\n\nfunction getDisputesFeesDistribution(artbitrableFeesMap, appealFeesMap) {\n  const appealFeesMapCopy = new Map([...appealFeesMap]);\n  const disputeFees = [];\n\n  for (const [disputeId, {\n    amount\n  }] of artbitrableFeesMap.entries()) {\n    let totalFeeAmount = amount;\n\n    if (appealFeesMapCopy.has(disputeId)) {\n      const appealFee = appealFeesMap.get(disputeId);\n      totalFeeAmount = totalFeeAmount.add(appealFee.amount);\n      appealFeesMapCopy.delete(disputeId);\n    }\n\n    disputeFees.push({\n      disputeId,\n      amount: totalFeeAmount\n    });\n  } // Add the reaminaing appealing fees in case there wasn't an arbitrable reward in the remaining disputes\n\n\n  for (const [disputeId, {\n    amount\n  }] of appealFeesMapCopy.entries()) {\n    disputeFees.push({\n      disputeId,\n      amount\n    });\n  }\n\n  return disputeFees;\n}\n/**\n * Converts Map into Array\n * @param {Map} feeMap Map to convert to an array\n * @returns {Array} New array containing map data\n */\n\n\nfunction feeMapToArray(feeMap) {\n  const arr = [];\n\n  for (const [disputeId, {\n    rounds,\n    ...feeEntry\n  }] of feeMap) {\n    arr.push({\n      disputeId,\n      ...feeEntry,\n      rounds: rounds.sort()\n    });\n  }\n\n  return arr;\n}","map":{"version":3,"sources":["/Users/saleemfareed/oneds/court-dashboard/src/hooks/useJurorRewards.js"],"names":["useMemo","useDashboardState","useCourtConfig","bigNum","isJurorCoherent","getAppealerFees","shouldAppealerBeRewarded","getRoundFees","useWallet","useJurorLastWithdrawalTimeSubscription","useJurorRewards","courtConfig","wallet","jurorDrafts","appeals","lastWithdrawalTime","account","rulingFees","arbitrableFees","filter","jurorDraft","round","settledPenalties","rewarded","rewardedAt","reduce","weight","jurorFees","coherentJurors","collectedTokens","dispute","rulingFeesAmount","mul","div","disputeFeesAmount","add","setOrUpdateFee","id","number","Map","appealFees","appeal","settled","settledAt","appealsFee","nextRoundId","nextRound","rounds","totalFees","appealerFees","anjRewards","feeRewards","feeMapToArray","distribution","getDisputesFeesDistribution","feeMap","disputeId","roundId","feeAmount","feeEntry","has","amount","settledAmount","get","set","artbitrableFeesMap","appealFeesMap","appealFeesMapCopy","disputeFees","entries","totalFeeAmount","appealFee","delete","push","arr","sort"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\nimport { useDashboardState } from '../components/Dashboard/DashboardStateProvider'\nimport { useCourtConfig } from '../providers/CourtConfig'\nimport { bigNum } from '../lib/math-utils'\nimport { isJurorCoherent } from '../utils/juror-draft-utils'\nimport {\n  getAppealerFees,\n  shouldAppealerBeRewarded,\n} from '../utils/appeal-utils'\nimport { getRoundFees } from '../utils/dispute-utils'\nimport { useWallet } from '../providers/Wallet'\nimport { useJurorLastWithdrawalTimeSubscription } from './subscription-hooks'\n\nexport default function useJurorRewards() {\n  const courtConfig = useCourtConfig()\n  const wallet = useWallet()\n  const { jurorDrafts, appeals } = useDashboardState()\n  const lastWithdrawalTime = useJurorLastWithdrawalTimeSubscription(\n    wallet.account\n  )\n\n  // For arbitrable and appeal fees we will use a map where map = [disputeId, { amount, rounds }]\n  // Where `rounds` is the array of roundIds of non settled rounds\n  // This is useful as jurors could have rewards from many rounds for the same dispute\n  // which will need to be settled (in case they aren't) before withdrawing them from the treasury\n  return useMemo(() => {\n    if (!jurorDrafts || !appeals || !lastWithdrawalTime) return null\n\n    // Get ruling and disputes fees\n    // Only jurors that voted in consensus with the winning outcome can claim rewards (coherent jurors)\n    // We also include already settled rewards which have not been withdrawn from the treasury yet.\n    const { rulingFees, arbitrableFees } = jurorDrafts\n      .filter(\n        jurorDraft =>\n          jurorDraft.round.settledPenalties &&\n          (!jurorDraft.rewarded ||\n            jurorDraft.rewardedAt > lastWithdrawalTime) &&\n          isJurorCoherent(jurorDraft)\n      )\n      .reduce(\n        ({ rulingFees, arbitrableFees }, { rewarded, round, weight }) => {\n          const { jurorFees, coherentJurors, collectedTokens, dispute } = round\n\n          // Calculate fees\n          const rulingFeesAmount = collectedTokens\n            .mul(weight)\n            .div(coherentJurors)\n\n          const disputeFeesAmount = jurorFees.mul(weight).div(coherentJurors)\n\n          return {\n            rulingFees: rulingFees.add(rulingFeesAmount),\n            arbitrableFees: setOrUpdateFee(\n              arbitrableFees,\n              dispute.id,\n              round.number,\n              disputeFeesAmount,\n              rewarded\n            ),\n          }\n        },\n        { rulingFees: bigNum(0), arbitrableFees: new Map() }\n      )\n\n    // Before settling appeals it's required that the penalties for the round are settled, so we need to filter the ones that aren't\n    // We also need to check that the appealer should be rewarded.\n    const appealFees = appeals\n      .filter(\n        appeal =>\n          appeal.round.settledPenalties &&\n          (!appeal.settled || appeal.settledAt > lastWithdrawalTime) &&\n          shouldAppealerBeRewarded(appeal, wallet.account)\n      )\n      .reduce((appealsFee, appeal) => {\n        const { round, settled } = appeal\n\n        // We need to calculate the totalFees of the next round since this amount will be discounted from the appeal reward for the appealer\n        const nextRoundId = round.number + 1\n        const nextRound = round.dispute.rounds[nextRoundId]\n\n        // It could happen that the appeal is never confirmed. In this case the appealer should get the entire appeal deposit\n        const totalFees = nextRound\n          ? getRoundFees(nextRound, courtConfig)\n          : bigNum(0)\n\n        const appealerFees = getAppealerFees(appeal, totalFees, wallet.account)\n\n        return setOrUpdateFee(\n          appealsFee,\n          round.dispute.id,\n          round.number,\n          appealerFees,\n          settled\n        )\n      }, new Map())\n\n    return {\n      anjRewards: rulingFees,\n      feeRewards: {\n        arbitrableFees: feeMapToArray(arbitrableFees),\n        appealFees: feeMapToArray(appealFees),\n        distribution: getDisputesFeesDistribution(arbitrableFees, appealFees),\n      },\n    }\n  }, [appeals, courtConfig, jurorDrafts, lastWithdrawalTime, wallet])\n}\n\n/**\n * Adds or updates a fee entry on the map\n * @param {Map} feeMap Map contianing fee data\n * @param {Number} disputeId Id of the dispute\n * @param {Number} roundId Id of the round\n * @param {BigNum} feeAmount Amount of fees to add to the entry\n * @param {Boolean} settled True if fees for the given round are settled\n * @returns {Map} Updated map with the new entry or the amount updated\n */\nfunction setOrUpdateFee(\n  feeMap,\n  disputeId,\n  roundId,\n  feeAmount,\n  settled = false\n) {\n  let feeEntry\n\n  if (feeMap.has(disputeId)) {\n    const { amount, rounds, settledAmount } = feeMap.get(disputeId)\n    feeEntry = {\n      amount: amount.add(feeAmount),\n      settledAmount: settled ? settledAmount.add(feeAmount) : settledAmount,\n      rounds: [...rounds, ...(settled ? [] : [roundId])],\n    }\n  } else {\n    feeEntry = {\n      amount: feeAmount,\n      settledAmount: settled ? feeAmount : bigNum(0),\n      rounds: settled ? [] : [roundId],\n    }\n  }\n\n  feeMap.set(disputeId, feeEntry)\n  return feeMap\n}\n\n/**\n * Creates a new array containing the total amount of fees per dispute\n * @param {Map} artbitrableFeesMap Map of arbitrable fees\n * @param {Map} appealFeesMap Map of appeal fees\n * @returns {Array} New array with the total fees for each dispute\n */\n\nfunction getDisputesFeesDistribution(artbitrableFeesMap, appealFeesMap) {\n  const appealFeesMapCopy = new Map([...appealFeesMap])\n\n  const disputeFees = []\n  for (const [disputeId, { amount }] of artbitrableFeesMap.entries()) {\n    let totalFeeAmount = amount\n\n    if (appealFeesMapCopy.has(disputeId)) {\n      const appealFee = appealFeesMap.get(disputeId)\n      totalFeeAmount = totalFeeAmount.add(appealFee.amount)\n      appealFeesMapCopy.delete(disputeId)\n    }\n\n    disputeFees.push({ disputeId, amount: totalFeeAmount })\n  }\n\n  // Add the reaminaing appealing fees in case there wasn't an arbitrable reward in the remaining disputes\n  for (const [disputeId, { amount }] of appealFeesMapCopy.entries()) {\n    disputeFees.push({ disputeId, amount })\n  }\n\n  return disputeFees\n}\n\n/**\n * Converts Map into Array\n * @param {Map} feeMap Map to convert to an array\n * @returns {Array} New array containing map data\n */\nfunction feeMapToArray(feeMap) {\n  const arr = []\n  for (const [disputeId, { rounds, ...feeEntry }] of feeMap) {\n    arr.push({\n      disputeId,\n      ...feeEntry,\n      rounds: rounds.sort(),\n    })\n  }\n\n  return arr\n}\n"]},"metadata":{},"sourceType":"module"}