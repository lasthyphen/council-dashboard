{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\")),\n    _ethers = require(\"ethers\"),\n    _methodRegistry = _interopRequireDefault(require(\"./lib/methodRegistry\")),\n    _lib = require(\"../lib/\"),\n    _data = require(\"../data/\"),\n    _defaults = require(\"../defaults\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var source, i = 1; i < arguments.length; i++) {\n    source = null == arguments[i] ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      (0, _defineProperty2.default)(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar makeUnknownFunctionNode = function makeUnknownFunctionNode(methodId) {\n  return {\n    type: \"string\",\n    value: \"Unknown function (\".concat(methodId, \")\")\n  };\n},\n    parse = function parse(signature) {\n  var fragment = _ethers.ethers.utils.FunctionFragment.from(signature);\n\n  return {\n    name: fragment.name.charAt(0).toUpperCase() + fragment.name.slice(1).split(/(?=[A-Z])/).join(\" \"),\n    args: fragment.inputs.map(function (input) {\n      return {\n        type: input.type\n      };\n    })\n  };\n},\n    getSigHah = function getSigHah(sig) {\n  return _ethers.ethers.utils.hexDataSlice(_ethers.ethers.utils.id(sig), 0, 4);\n},\n    processFunctions = function processFunctions(functions) {\n  return Object.keys(functions).reduce(function (acc, key) {\n    var fragment = _ethers.ethers.utils.FunctionFragment.from(key);\n\n    return _objectSpread(_defineProperty({}, getSigHah(fragment.format()), {\n      source: functions[key],\n      fragment: fragment\n    }), acc);\n  }, {});\n};\n\nvar _default = function _default(provider, evaluator) {\n  return (\n    /*#__PURE__*/\n\n    /**\n    * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n    * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n    *\n    * @param {address} addr The target address of the call\n    * @param {bytes} data The calldata of the call\n    * @param {string} [registryAddress] The registry address to lookup descriptions\n    * @return {Promise<radspec/evaluator/TypedValue>}\n    */\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(addr, data, registryAddress) {\n        var functions, methodId, fn, registry, result, _parse, name, _ref2, results, _parse2, _name, source, fragment, ethersInterface, args, parameters;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                functions = processFunctions(_data.knownFunctions);\n\n                if (!(10 > data.length)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", makeUnknownFunctionNode(data));\n\n              case 3:\n                // Get method ID\n                methodId = data.substr(0, 10), fn = functions[methodId]; // If function is not a known function\n\n                if (fn) {\n                  _context.next = 37;\n                  break;\n                }\n\n                _context.prev = 5;\n                _context.t0 = _methodRegistry.default;\n                _context.t1 = registryAddress;\n                _context.t2 = provider;\n\n                if (!registryAddress) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.t3 = void 0;\n                _context.next = 16;\n                break;\n\n              case 13:\n                _context.next = 15;\n                return provider.getNetwork();\n\n              case 15:\n                _context.t3 = _context.sent.chainId;\n\n              case 16:\n                _context.t4 = _context.t3;\n                _context.t5 = {\n                  registryAddress: _context.t1,\n                  provider: _context.t2,\n                  network: _context.t4\n                };\n                registry = new _context.t0(_context.t5);\n                _context.next = 21;\n                return registry.lookup(methodId);\n\n              case 21:\n                result = _context.sent;\n                _parse = parse(result);\n                name = _parse.name;\n                return _context.abrupt(\"return\", {\n                  type: \"string\",\n                  value: name // TODO: should we decode and print the arguments as well?\n\n                });\n\n              case 27:\n                _context.prev = 27;\n                _context.t6 = _context[\"catch\"](5);\n                _context.next = 31;\n                return _ethers.ethers.utils.fetchJson(\"\".concat(_defaults.DEFAULT_API_4BYTES, \"?hex_signature=\").concat(methodId));\n\n              case 31:\n                _ref2 = _context.sent;\n                results = _ref2.results;\n\n                if (!(Array.isArray(results) && 0 < results.length)) {\n                  _context.next = 36;\n                  break;\n                }\n\n                _parse2 = parse(results[0].text_signature), _name = _parse2.name;\n                return _context.abrupt(\"return\", {\n                  type: \"string\",\n                  value: _name\n                });\n\n              case 36:\n                return _context.abrupt(\"return\", makeUnknownFunctionNode(methodId));\n\n              case 37:\n                // If the function was found in local radspec registry. Decode and evaluate.\n                source = fn.source, fragment = fn.fragment, ethersInterface = new _ethers.ethers.utils.Interface([fragment]), args = ethersInterface.decodeFunctionData(fragment.name, data), parameters = fragment.inputs.reduce(function (parameters, input, index) {\n                  return _objectSpread(_defineProperty({}, \"$\".concat(index + 1), {\n                    type: input.type,\n                    value: args[index]\n                  }), parameters);\n                }, {});\n                _context.next = 40;\n                return (0, _lib.evaluateRaw)(source, parameters, {\n                  provider: provider,\n                  availableHelpers: evaluator.helpers.getHelpers(),\n                  to: addr\n                });\n\n              case 40:\n                _context.t7 = _context.sent;\n                return _context.abrupt(\"return\", {\n                  type: \"string\",\n                  value: _context.t7\n                });\n\n              case 42:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[5, 27]]);\n      }));\n\n      return function (_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n};\n\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}