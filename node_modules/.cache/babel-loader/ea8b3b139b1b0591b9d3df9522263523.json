{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/saleemfareed/oneds/court-dashboard/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.evaluate = evaluate, exports.Evaluator = void 0;\n\nvar _ethers = require(\"ethers\"),\n    _types = _interopRequireDefault(require(\"../types\")),\n    _HelperManager = _interopRequireDefault(require(\"../helpers/HelperManager\")),\n    _defaults = require(\"../defaults\");\n/**\n* @module radspec/evaluator\n*/\n\n/**\n* A value coupled with a type\n*\n* @class TypedValue\n* @param {string} type The type of the value\n* @param {*} value The value\n* @property {string} type\n* @property {*} value\n*/\n\n\nvar TypedValue =\n/*#__PURE__*/\nfunction () {\n  function TypedValue(type, value) {\n    _classCallCheck(this, TypedValue);\n\n    if (this.type = type, this.value = value, _types.default.isInteger(this.type) && !_ethers.BigNumber.isBigNumber(this.value) && (this.value = _ethers.BigNumber.from(this.value)), \"address\" === this.type) {\n      if (!_ethers.ethers.utils.isAddress(this.value)) throw new Error(\"Invalid address \\\"\".concat(this.value, \"\\\"\"));\n      this.value = _ethers.ethers.utils.getAddress(this.value);\n    }\n  }\n  /**\n  * Get the string representation of the wrapped value\n  *\n  * @return {string}\n  */\n\n\n  _createClass(TypedValue, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.value.toString();\n    }\n  }]);\n\n  return TypedValue;\n}();\n/**\n* Walks an AST and evaluates each node.\n*\n* @class Evaluator\n* @param {radspec/parser/AST} ast The AST to evaluate\n* @param {radspec/Bindings} bindings An object of bindings and their values\n* @param {?Object} options An options object\n* @param {?Object} options.availablehelpers Available helpers\n* @param {?ethers.providers.Provider} options.provider EIP 1193 provider\n* @param {?string} options.to The destination address for this expression's transaction\n* @property {radspec/parser/AST} ast\n* @property {radspec/Bindings} bindings\n*/\n\n\nvar Evaluator =\n/*#__PURE__*/\nfunction () {\n  function Evaluator(ast, bindings) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref$availableHelpers = _ref.availableHelpers,\n        availableHelpers = _ref$availableHelpers === void 0 ? {} : _ref$availableHelpers,\n        provider = _ref.provider,\n        from = _ref.from,\n        to = _ref.to,\n        _ref$value = _ref.value,\n        value = _ref$value === void 0 ? \"0\" : _ref$value,\n        data = _ref.data;\n\n    _classCallCheck(this, Evaluator);\n\n    this.ast = ast, this.bindings = bindings, this.provider = provider || new _ethers.ethers.providers.WebSocketProvider(_defaults.DEFAULT_ETH_NODE), this.from = from && new TypedValue(\"address\", from), this.to = to && new TypedValue(\"address\", to), this.value = new TypedValue(\"uint\", _ethers.BigNumber.from(value)), this.data = data && new TypedValue(\"bytes\", data), this.helpers = new _HelperManager.default(availableHelpers);\n  }\n  /**\n  * Evaluate an array of AST nodes.\n  *\n  * @param  {Array<radspec/parser/Node>} nodes\n  * @return {Promise<Array<string>>}\n  */\n\n\n  _createClass(Evaluator, [{\n    key: \"evaluateNodes\",\n    value: function () {\n      var _evaluateNodes = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(nodes) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", Promise.all(nodes.map(this.evaluateNode.bind(this))));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function evaluateNodes(_x) {\n        return _evaluateNodes.apply(this, arguments);\n      }\n\n      return evaluateNodes;\n    }()\n    /**\n    * Evaluate a single node.\n    *\n    * @param  {radspec/parser/Node} node\n    * @return {Promise<string>}\n    */\n\n  }, {\n    key: \"evaluateNode\",\n    value: function () {\n      var _evaluateNode = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(node) {\n        var _Mathceil, length, left, right, _left, _right, leftValue, rightValue, bothTypesAddress, bothTypesBytes, _left2, leftFalsey, target, inputs, outputs, selectedReturnValueIndex, returnType, abi, ethersInterface, txData, data, decodeData, helperName, _inputs, result, binding;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _Mathceil = Math.ceil;\n\n                if (!(\"ExpressionStatement\" === node.type)) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return this.evaluateNodes(node.body);\n\n              case 4:\n                return _context2.abrupt(\"return\", _context2.sent.join(\" \"));\n\n              case 5:\n                if (!(\"GroupedExpression\" === node.type)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.evaluateNode(node.body));\n\n              case 7:\n                if (!(\"MonologueStatement\" === node.type)) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new TypedValue(\"string\", node.value));\n\n              case 9:\n                if (!(\"StringLiteral\" === node.type)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new TypedValue(\"string\", node.value || \"\"));\n\n              case 11:\n                if (!(\"NumberLiteral\" === node.type)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new TypedValue(\"int256\", node.value));\n\n              case 13:\n                if (!(\"BytesLiteral\" === node.type)) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                length = _Mathceil((node.value.length - 2) / 2);\n                return _context2.abrupt(\"return\", (32 < length && this.panic(\"Byte literal represents more than 32 bytes\"), new TypedValue(\"bytes\".concat(length), node.value)));\n\n              case 16:\n                if (!(\"BoolLiteral\" === node.type)) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new TypedValue(\"bool\", \"true\" === node.value));\n\n              case 18:\n                if (!(\"BinaryExpression\" === node.type)) {\n                  _context2.next = 37;\n                  break;\n                }\n\n                _context2.next = 21;\n                return this.evaluateNode(node.left);\n\n              case 21:\n                left = _context2.sent;\n                _context2.next = 24;\n                return this.evaluateNode(node.right);\n\n              case 24:\n                right = _context2.sent;\n\n                if (!((\"string\" === left.type || \"string\" === right.type) && \"PLUS\" === node.operator)) {\n                  _context2.next = 27;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new TypedValue(\"string\", left.value.toString() + right.value.toString()));\n\n              case 27:\n                _context2.t0 = (_types.default.isInteger(left.type) && _types.default.isInteger(right.type) || this.panic(\"Cannot evaluate binary expression \\\"\".concat(node.operator, \"\\\" for non-integer types \\\"\").concat(left.type, \"\\\" and \\\"\").concat(right.type, \"\\\"\")), node.operator);\n                _context2.next = _context2.t0 === \"PLUS\" ? 30 : _context2.t0 === \"MINUS\" ? 31 : _context2.t0 === \"STAR\" ? 32 : _context2.t0 === \"POWER\" ? 33 : _context2.t0 === \"SLASH\" ? 34 : _context2.t0 === \"MODULO\" ? 35 : 36;\n                break;\n\n              case 30:\n                return _context2.abrupt(\"return\", new TypedValue(\"int256\", left.value.add(right.value)));\n\n              case 31:\n                return _context2.abrupt(\"return\", new TypedValue(\"int256\", left.value.sub(right.value)));\n\n              case 32:\n                return _context2.abrupt(\"return\", new TypedValue(\"int256\", left.value.mul(right.value)));\n\n              case 33:\n                return _context2.abrupt(\"return\", new TypedValue(\"int256\", left.value.pow(right.value)));\n\n              case 34:\n                return _context2.abrupt(\"return\", new TypedValue(\"int256\", left.value.div(right.value)));\n\n              case 35:\n                return _context2.abrupt(\"return\", new TypedValue(\"int256\", left.value.mod(right.value)));\n\n              case 36:\n                this.panic(\"Undefined binary operator \\\"\".concat(node.operator, \"\\\"\"));\n\n              case 37:\n                if (!(\"ComparisonExpression\" === node.type)) {\n                  _context2.next = 55;\n                  break;\n                }\n\n                _context2.next = 40;\n                return this.evaluateNode(node.left);\n\n              case 40:\n                _left = _context2.sent;\n                _context2.next = 43;\n                return this.evaluateNode(node.right);\n\n              case 43:\n                _right = _context2.sent;\n                leftValue = _left.value, rightValue = _right.value;\n                bothTypesAddress = function bothTypesAddress(left, right) {\n                  return (// isAddress is true if type is address or bytes with size less than 20\n                    _types.default.isAddress(left.type) && _types.default.isAddress(right.type)\n                  );\n                }, bothTypesBytes = function bothTypesBytes(left, right) {\n                  return _types.default.types.bytes.isType(left.type) && _types.default.types.bytes.isType(right.type);\n                };\n                _context2.t1 = (bothTypesAddress(_left, _right) || bothTypesBytes(_left, _right) ? (leftValue = _ethers.BigNumber.from(leftValue), rightValue = _ethers.BigNumber.from(rightValue)) : (!_types.default.isInteger(_left.type) || !_types.default.isInteger(_right.type)) && this.panic(\"Cannot evaluate binary expression \\\"\".concat(node.operator, \"\\\" for non-integer or fixed-size bytes types \\\"\").concat(_left.type, \"\\\" and \\\"\").concat(_right.type, \"\\\"\")), node.operator);\n                _context2.next = _context2.t1 === \"GREATER\" ? 49 : _context2.t1 === \"GREATER_EQUAL\" ? 50 : _context2.t1 === \"LESS\" ? 51 : _context2.t1 === \"LESS_EQUAL\" ? 52 : _context2.t1 === \"EQUAL_EQUAL\" ? 53 : _context2.t1 === \"BANG_EQUAL\" ? 54 : 55;\n                break;\n\n              case 49:\n                return _context2.abrupt(\"return\", new TypedValue(\"bool\", leftValue.gt(rightValue)));\n\n              case 50:\n                return _context2.abrupt(\"return\", new TypedValue(\"bool\", leftValue.gte(rightValue)));\n\n              case 51:\n                return _context2.abrupt(\"return\", new TypedValue(\"bool\", leftValue.lt(rightValue)));\n\n              case 52:\n                return _context2.abrupt(\"return\", new TypedValue(\"bool\", leftValue.lte(rightValue)));\n\n              case 53:\n                return _context2.abrupt(\"return\", new TypedValue(\"bool\", leftValue.eq(rightValue)));\n\n              case 54:\n                return _context2.abrupt(\"return\", new TypedValue(\"bool\", !leftValue.eq(rightValue)));\n\n              case 55:\n                if (!(\"TernaryExpression\" === node.type)) {\n                  _context2.next = 64;\n                  break;\n                }\n\n                _context2.next = 58;\n                return this.evaluateNode(node.predicate);\n\n              case 58:\n                if (!_context2.sent.value) {\n                  _context2.next = 62;\n                  break;\n                }\n\n                _context2.t2 = this.evaluateNode(node.left);\n                _context2.next = 63;\n                break;\n\n              case 62:\n                _context2.t2 = this.evaluateNode(node.right);\n\n              case 63:\n                return _context2.abrupt(\"return\", _context2.t2);\n\n              case 64:\n                if (!(\"DefaultExpression\" === node.type)) {\n                  _context2.next = 69;\n                  break;\n                }\n\n                _context2.next = 67;\n                return this.evaluateNode(node.left);\n\n              case 67:\n                _left2 = _context2.sent;\n                return _context2.abrupt(\"return\", (leftFalsey = _types.default.isInteger(_left2.type) ? _left2.value.isZero() : \"address\" === _left2.type || _left2.type.startsWith(\"bytes\") ? /^0x[0]*$/.test(_left2.value) : !_left2.value, leftFalsey ? this.evaluateNode(node.right) : _left2));\n\n              case 69:\n                if (!(\"CallExpression\" === node.type)) {\n                  _context2.next = 94;\n                  break;\n                }\n\n                if (!(\"Identifier\" === node.target.type && \"self\" === node.target.value)) {\n                  _context2.next = 74;\n                  break;\n                }\n\n                _context2.t3 = this.to;\n                _context2.next = 77;\n                break;\n\n              case 74:\n                _context2.next = 76;\n                return this.evaluateNode(node.target);\n\n              case 76:\n                _context2.t3 = _context2.sent;\n\n              case 77:\n                target = _context2.t3;\n                \"bytes20\" !== target.type && \"address\" !== target.type ? this.panic(\"Target of call expression was not an address\") : !_ethers.ethers.utils.isAddress(target.value) && this.panic(\"Invalid address \\\"\".concat(this.value, \"\\\"\"));\n                _context2.next = 81;\n                return this.evaluateNodes(node.inputs);\n\n              case 81:\n                inputs = _context2.sent;\n                outputs = node.outputs;\n                selectedReturnValueIndex = outputs.findIndex(function (output) {\n                  return output.selected;\n                });\n                -1 === selectedReturnValueIndex && this.panic(\"No selected return value for function call \\\"\".concat(node.callee, \"\\\"\"));\n                returnType = outputs[selectedReturnValueIndex].type;\n                abi = [{\n                  name: node.callee,\n                  type: \"function\",\n                  inputs: inputs.map(function (_ref2) {\n                    var type = _ref2.type;\n                    return {\n                      type: type\n                    };\n                  }),\n                  outputs: outputs.map(function (_ref3) {\n                    var type = _ref3.type;\n                    return {\n                      type: type\n                    };\n                  }),\n                  stateMutability: \"view\"\n                }];\n                ethersInterface = new _ethers.ethers.utils.Interface(abi);\n                txData = ethersInterface.encodeFunctionData(node.callee, inputs.map(function (input) {\n                  return input.value.toString();\n                }));\n                _context2.next = 91;\n                return this.provider.call({\n                  to: target.value,\n                  data: txData\n                });\n\n              case 91:\n                data = _context2.sent;\n                decodeData = ethersInterface.decodeFunctionResult(node.callee, data);\n                return _context2.abrupt(\"return\", new TypedValue(returnType, decodeData[selectedReturnValueIndex]));\n\n              case 94:\n                if (!(\"HelperFunction\" === node.type)) {\n                  _context2.next = 104;\n                  break;\n                }\n\n                helperName = node.name;\n                this.helpers.exists(helperName) || this.panic(\"\".concat(helperName, \" helper function is not defined\"));\n                _context2.next = 99;\n                return this.evaluateNodes(node.inputs);\n\n              case 99:\n                _inputs = _context2.sent;\n                _context2.next = 102;\n                return this.helpers.execute(helperName, _inputs, {\n                  provider: this.provider,\n                  evaluator: this\n                });\n\n              case 102:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", new TypedValue(result.type, result.value));\n\n              case 104:\n                if (!(\"PropertyAccessExpression\" === node.type && \"msg\" === node.target.value)) {\n                  _context2.next = 112;\n                  break;\n                }\n\n                if (!(\"value\" === node.property)) {\n                  _context2.next = 107;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.value);\n\n              case 107:\n                if (!(\"sender\" === node.property)) {\n                  _context2.next = 109;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.from);\n\n              case 109:\n                if (!(\"data\" === node.property)) {\n                  _context2.next = 111;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.data);\n\n              case 111:\n                this.panic(\"Expecting value, sender or data property for msg identifier but got: \".concat(node.property));\n\n              case 112:\n                if (!(\"Identifier\" === node.type)) {\n                  _context2.next = 118;\n                  break;\n                }\n\n                if (!(\"self\" === node.value)) {\n                  _context2.next = 115;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.to);\n\n              case 115:\n                this.bindings.hasOwnProperty(node.value) || this.panic(\"Undefined binding \\\"\".concat(node.value, \"\\\"\"));\n                binding = this.bindings[node.value];\n                return _context2.abrupt(\"return\", new TypedValue(binding.type, binding.value));\n\n              case 118:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function evaluateNode(_x2) {\n        return _evaluateNode.apply(this, arguments);\n      }\n\n      return evaluateNode;\n    }()\n    /**\n    * Evaluate the entire AST.\n    *\n    * @return {string}\n    */\n\n  }, {\n    key: \"evaluate\",\n    value: function () {\n      var _evaluate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.evaluateNodes(this.ast.body).then(function (evaluatedNodes) {\n                  return evaluatedNodes.join(\"\");\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function evaluate() {\n        return _evaluate.apply(this, arguments);\n      }\n\n      return evaluate;\n    }()\n    /**\n    * Report an error and abort evaluation.\n    *\n    * @param  {string} msg\n    */\n\n  }, {\n    key: \"panic\",\n    value: function panic(msg) {\n      throw new Error(\"Error: \".concat(msg));\n    }\n  }]);\n\n  return Evaluator;\n}();\n/**\n* Evaluates an AST\n*\n* @memberof radspec/evaluator\n* @param {radspec/parser/AST} ast The AST to evaluate\n* @param {radspec/Bindings} bindings An object of bindings and their values\n* @param {?Object} options An options object\n* @param {?Object} options.availablehelpers Available helpers\n* @param {?ethers.providers.Provider} options.provider EIP 1193 provider\n* @param {?string} options.to The destination address for this expression's transaction\n* @return {string}\n*/\n\n\nexports.Evaluator = Evaluator;\n\nfunction evaluate(ast, bindings, options) {\n  return new Evaluator(ast, bindings, options).evaluate();\n}","map":null,"metadata":{},"sourceType":"script"}