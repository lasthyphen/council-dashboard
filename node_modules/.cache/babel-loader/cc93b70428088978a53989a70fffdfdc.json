{"ast":null,"code":"\"use strict\"; // Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>\n// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletLinkRelay = void 0;\n\nconst bind_decorator_1 = __importDefault(require(\"bind-decorator\"));\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst WalletLinkConnection_1 = require(\"../connection/WalletLinkConnection\");\n\nconst util_1 = require(\"../util\");\n\nconst aes256gcm = __importStar(require(\"./aes256gcm\"));\n\nconst Session_1 = require(\"./Session\");\n\nconst Web3Method_1 = require(\"./Web3Method\");\n\nconst Web3RequestCanceledMessage_1 = require(\"./Web3RequestCanceledMessage\");\n\nconst Web3RequestMessage_1 = require(\"./Web3RequestMessage\");\n\nconst Web3Response_1 = require(\"./Web3Response\");\n\nconst Web3ResponseMessage_1 = require(\"./Web3ResponseMessage\");\n\nconst WalletLinkRelayAbstract_1 = require(\"./WalletLinkRelayAbstract\");\n\nclass WalletLinkRelay {\n  constructor(options) {\n    this.accountsCallback = null;\n    this.chainIdCallback = null;\n    this.jsonRpcUrlCallback = null;\n    this.appName = \"\";\n    this.appLogoUrl = null;\n    this.walletLinkUrl = options.walletLinkUrl;\n    this.storage = options.storage;\n    this.session = Session_1.Session.load(options.storage) || new Session_1.Session(options.storage).save();\n    this.relayEventManager = options.relayEventManager;\n    this.connection = new WalletLinkConnection_1.WalletLinkConnection(this.session.id, this.session.key, this.walletLinkUrl);\n    this.connection.incomingEvent$.pipe(operators_1.filter(m => m.event === \"Web3Response\")).subscribe({\n      next: this.handleIncomingEvent\n    }); // if session is marked destroyed, reset and reload\n\n    this.connection.sessionConfig$.pipe(operators_1.filter(c => !!c.metadata && c.metadata.__destroyed === \"1\")).subscribe({\n      next: this.resetAndReload\n    });\n    this.connection.sessionConfig$.pipe(operators_1.filter(c => c.metadata && c.metadata.WalletUsername !== undefined)).pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.WalletUsername, this.session.secret))).subscribe({\n      next: walletUsername => {\n        this.storage.setItem(WalletLinkRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);\n      }\n    });\n    this.connection.sessionConfig$.pipe(operators_1.filter(c => c.metadata && c.metadata.ChainId !== undefined)).pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.ChainId, this.session.secret))).pipe(operators_1.distinctUntilChanged()).subscribe({\n      next: chainId => {\n        if (this.chainIdCallback) {\n          this.chainIdCallback(chainId);\n        }\n      }\n    });\n    this.connection.sessionConfig$.pipe(operators_1.filter(c => c.metadata && c.metadata.JsonRpcUrl !== undefined)).pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.JsonRpcUrl, this.session.secret))).pipe(operators_1.distinctUntilChanged()).subscribe({\n      next: jsonRpcURl => {\n        if (this.jsonRpcUrlCallback) {\n          this.jsonRpcUrlCallback(jsonRpcURl);\n        }\n      }\n    });\n    this.connection.sessionConfig$.pipe(operators_1.filter(c => c.metadata && c.metadata.EthereumAddress !== undefined)).pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.EthereumAddress, this.session.secret))).subscribe({\n      next: selectedAddress => {\n        if (this.accountsCallback) {\n          this.accountsCallback([selectedAddress]);\n        }\n\n        if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {\n          // We get the ethereum address from the metadata.  If for whatever\n          // reason we don't get a response via an explicit web3 message\n          // we can still fulfill the eip1102 request.\n          Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach(id => {\n            const message = Web3ResponseMessage_1.Web3ResponseMessage({\n              id,\n              response: Web3Response_1.RequestEthereumAccountsResponse([selectedAddress])\n            });\n            this.invokeCallback(Object.assign(Object.assign({}, message), {\n              id\n            }));\n          });\n          WalletLinkRelay.accountRequestCallbackIds.clear();\n        }\n      }\n    });\n    this.ui = options.walletLinkUIConstructor({\n      walletLinkUrl: options.walletLinkUrl,\n      version: options.version,\n      darkMode: options.darkMode,\n      session: this.session,\n      connected$: this.connection.connected$\n    });\n    this.connection.connect();\n  }\n\n  attachUI() {\n    this.ui.attach();\n  }\n\n  resetAndReload() {\n    this.connection.setSessionMetadata(\"__destroyed\", \"1\").pipe(operators_1.timeout(1000), operators_1.catchError(_ => rxjs_1.of(null))).subscribe(_ => {\n      this.connection.destroy();\n      this.storage.clear();\n      this.ui.reloadUI();\n    });\n  }\n\n  setAppInfo(appName, appLogoUrl) {\n    this.appName = appName;\n    this.appLogoUrl = appLogoUrl;\n  }\n\n  getStorageItem(key) {\n    return this.storage.getItem(key);\n  }\n\n  setStorageItem(key, value) {\n    this.storage.setItem(key, value);\n  }\n\n  childRequestEthereumAccounts(childSessionId, childSessionSecret, dappName, dappLogoURL, dappURL) {\n    return this.sendChildRequest({\n      method: Web3Method_1.Web3Method.childRequestEthereumAccounts,\n      params: {\n        sessionId: childSessionId,\n        sessionSecret: childSessionSecret,\n        appName: dappName,\n        appLogoURL: dappLogoURL,\n        appURL: dappURL\n      }\n    });\n  }\n\n  requestEthereumAccounts() {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.requestEthereumAccounts,\n      params: {\n        appName: this.appName,\n        appLogoUrl: this.appLogoUrl || null\n      }\n    });\n  }\n\n  signEthereumMessage(message, address, addPrefix, typedDataJson) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.signEthereumMessage,\n      params: {\n        message: util_1.hexStringFromBuffer(message, true),\n        address,\n        addPrefix,\n        typedDataJson: typedDataJson || null\n      }\n    });\n  }\n\n  ethereumAddressFromSignedMessage(message, signature, addPrefix) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,\n      params: {\n        message: util_1.hexStringFromBuffer(message, true),\n        signature: util_1.hexStringFromBuffer(signature, true),\n        addPrefix\n      }\n    });\n  }\n\n  signEthereumTransaction(params) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.signEthereumTransaction,\n      params: {\n        fromAddress: params.fromAddress,\n        toAddress: params.toAddress,\n        weiValue: util_1.bigIntStringFromBN(params.weiValue),\n        data: util_1.hexStringFromBuffer(params.data, true),\n        nonce: params.nonce,\n        gasPriceInWei: params.gasPriceInWei ? util_1.bigIntStringFromBN(params.gasPriceInWei) : null,\n        maxFeePerGas: params.gasPriceInWei ? util_1.bigIntStringFromBN(params.gasPriceInWei) : null,\n        maxPriorityFeePerGas: params.gasPriceInWei ? util_1.bigIntStringFromBN(params.gasPriceInWei) : null,\n        gasLimit: params.gasLimit ? util_1.bigIntStringFromBN(params.gasLimit) : null,\n        chainId: params.chainId,\n        shouldSubmit: false\n      }\n    });\n  }\n\n  signAndSubmitEthereumTransaction(params) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.signEthereumTransaction,\n      params: {\n        fromAddress: params.fromAddress,\n        toAddress: params.toAddress,\n        weiValue: util_1.bigIntStringFromBN(params.weiValue),\n        data: util_1.hexStringFromBuffer(params.data, true),\n        nonce: params.nonce,\n        gasPriceInWei: params.gasPriceInWei ? util_1.bigIntStringFromBN(params.gasPriceInWei) : null,\n        maxFeePerGas: params.maxFeePerGas ? util_1.bigIntStringFromBN(params.maxFeePerGas) : null,\n        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? util_1.bigIntStringFromBN(params.maxPriorityFeePerGas) : null,\n        gasLimit: params.gasLimit ? util_1.bigIntStringFromBN(params.gasLimit) : null,\n        chainId: params.chainId,\n        shouldSubmit: true\n      }\n    });\n  }\n\n  submitEthereumTransaction(signedTransaction, chainId) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.submitEthereumTransaction,\n      params: {\n        signedTransaction: util_1.hexStringFromBuffer(signedTransaction, true),\n        chainId\n      }\n    });\n  }\n\n  scanQRCode(regExp) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.scanQRCode,\n      params: {\n        regExp\n      }\n    });\n  }\n\n  arbitraryRequest(data) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.arbitrary,\n      params: {\n        data\n      }\n    });\n  }\n\n  addEthereumChain(chainId, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.addEthereumChain,\n      params: {\n        chainId,\n        blockExplorerUrls,\n        chainName,\n        iconUrls,\n        nativeCurrency\n      }\n    });\n  }\n  /**\n   *\n   * @param request a request to connect the child session using a parent session's connection\n   *\n   * A note on why we're not using the sendRequest method.  The sendRequest function doesn't have\n   * any way to tell when a message has been sent - it either times out after 60 seconds, or\n   * waits until it gets a response from the mobile client.  In the case of sending a child request,\n   * we don't wait for a response from the mobile client, we continue as soon as we know the server\n   * has received the message.  Hence why we have a separate method here.\n   */\n\n\n  sendChildRequest(request) {\n    return new Promise((resolve, reject) => {\n      const id = util_1.randomBytesHex(8);\n      const message = Web3RequestMessage_1.Web3RequestMessage({\n        id,\n        request\n      });\n      this.publishEvent(\"Web3Request\", message, true).subscribe({\n        next: ret => {\n          resolve(Web3Response_1.ChildRequestEthereumAccountsResponse(ret));\n        },\n        error: err => {\n          reject(new Error(err.message));\n        }\n      });\n    });\n  }\n\n  sendRequest(request) {\n    return new Promise((resolve, reject) => {\n      var _a;\n\n      let hideSnackbarItem = null;\n      const id = util_1.randomBytesHex(8);\n      const isRequestAccounts = request.method === Web3Method_1.Web3Method.requestEthereumAccounts;\n      const isSwitchEthereumChain = request.method === Web3Method_1.Web3Method.switchEthereumChain;\n\n      const cancel = () => {\n        this.publishWeb3RequestCanceledEvent(id);\n        this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({\n          id,\n          response: Web3Response_1.ErrorResponse(request.method, \"User rejected request\")\n        }));\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n      };\n\n      if (isRequestAccounts) {\n        const userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;\n\n        if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {\n          window.location.href = `https://go.cb-w.com/xoXnYwQimhb?cb_url=${window.location.href}`;\n          return;\n        }\n\n        if (this.ui.inlineAccountsResponse()) {\n          const onAccounts = accounts => {\n            this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({\n              id,\n              response: Web3Response_1.RequestEthereumAccountsResponse(accounts)\n            }));\n          };\n\n          this.ui.requestEthereumAccounts({\n            onCancel: cancel,\n            onAccounts\n          });\n        } else {\n          this.ui.requestEthereumAccounts({\n            onCancel: cancel\n          });\n        }\n\n        WalletLinkRelay.accountRequestCallbackIds.add(id);\n      } else if (request.method === Web3Method_1.Web3Method.switchEthereumChain || request.method === Web3Method_1.Web3Method.addEthereumChain) {\n        const cancel = () => {\n          this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({\n            id,\n            response: Web3Response_1.SwitchEthereumChainResponse(false)\n          }));\n        };\n\n        const approve = () => {\n          this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({\n            id,\n            response: Web3Response_1.SwitchEthereumChainResponse(true)\n          }));\n        };\n\n        this.ui.switchEthereumChain({\n          onCancel: cancel,\n          onApprove: approve,\n          chainId: request.params.chainId\n        });\n\n        if (!this.ui.inlineSwitchEthereumChain()) {\n          hideSnackbarItem = this.ui.showConnecting({\n            onCancel: cancel,\n            onResetConnection: this.resetAndReload\n          });\n        }\n      } else {\n        hideSnackbarItem = this.ui.showConnecting({\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload\n        });\n      }\n\n      this.relayEventManager.callbacks.set(id, response => {\n        this.ui.hideRequestEthereumAccounts();\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n\n        if (response.errorMessage) {\n          return reject(new Error(response.errorMessage));\n        }\n\n        resolve(response);\n      });\n\n      if (isRequestAccounts && this.ui.inlineAccountsResponse() || isSwitchEthereumChain && this.ui.inlineSwitchEthereumChain()) {\n        return;\n      }\n\n      this.publishWeb3RequestEvent(id, request);\n    });\n  }\n\n  setConnectDisabled(disabled) {\n    this.ui.setConnectDisabled(disabled);\n  }\n\n  setAccountsCallback(accountsCallback) {\n    this.accountsCallback = accountsCallback;\n  }\n\n  setChainIdCallback(chainIdCallback) {\n    this.chainIdCallback = chainIdCallback;\n  }\n\n  setJsonRpcUrlCallback(jsonRpcUrlCallback) {\n    this.jsonRpcUrlCallback = jsonRpcUrlCallback;\n  }\n\n  publishWeb3RequestEvent(id, request) {\n    const message = Web3RequestMessage_1.Web3RequestMessage({\n      id,\n      request\n    });\n    this.publishEvent(\"Web3Request\", message, true).subscribe({\n      error: err => {\n        this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({\n          id: message.id,\n          response: {\n            method: message.request.method,\n            errorMessage: err.message\n          }\n        }));\n      }\n    });\n  }\n\n  publishWeb3RequestCanceledEvent(id) {\n    const message = Web3RequestCanceledMessage_1.Web3RequestCanceledMessage(id);\n    this.publishEvent(\"Web3RequestCanceled\", message, false).subscribe();\n  }\n\n  publishEvent(event, message, callWebhook) {\n    const secret = this.session.secret;\n    return new rxjs_1.Observable(subscriber => {\n      aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), {\n        origin: location.origin\n      })), secret).then(encrypted => {\n        subscriber.next(encrypted);\n        subscriber.complete();\n      });\n    }).pipe(operators_1.mergeMap(encrypted => {\n      return this.connection.publishEvent(event, encrypted, callWebhook);\n    }));\n  }\n\n  handleIncomingEvent(event) {\n    try {\n      aes256gcm.decrypt(event.data, this.session.secret).pipe(operators_1.map(c => JSON.parse(c))).subscribe({\n        next: json => {\n          const message = Web3ResponseMessage_1.isWeb3ResponseMessage(json) ? json : null;\n\n          if (!message) {\n            return;\n          }\n\n          this.handleWeb3ResponseMessage(message);\n        }\n      });\n    } catch (_a) {\n      return;\n    }\n  }\n\n  handleWeb3ResponseMessage(message) {\n    const {\n      response\n    } = message;\n\n    if (Web3Response_1.isRequestEthereumAccountsResponse(response)) {\n      Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach(id => this.invokeCallback(Object.assign(Object.assign({}, message), {\n        id\n      })));\n      WalletLinkRelay.accountRequestCallbackIds.clear();\n      return;\n    }\n\n    this.invokeCallback(message);\n  }\n\n  invokeCallback(message) {\n    const callback = this.relayEventManager.callbacks.get(message.id);\n\n    if (callback) {\n      callback(message.response);\n      this.relayEventManager.callbacks.delete(message.id);\n    }\n  }\n\n  switchEthereumChain(chainId) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.switchEthereumChain,\n      params: {\n        chainId\n      }\n    });\n  }\n\n}\n\nWalletLinkRelay.accountRequestCallbackIds = new Set();\n\n__decorate([bind_decorator_1.default], WalletLinkRelay.prototype, \"resetAndReload\", null);\n\n__decorate([bind_decorator_1.default], WalletLinkRelay.prototype, \"handleIncomingEvent\", null);\n\nexports.WalletLinkRelay = WalletLinkRelay;","map":null,"metadata":{},"sourceType":"script"}