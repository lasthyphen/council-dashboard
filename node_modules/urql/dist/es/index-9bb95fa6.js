import { share, onPush, takeWhile, toPromise, take } from "wonka";

import { GraphQLError, parse, print, visit, Kind } from "graphql";

function _extends() {
  return (_extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

var rehydrateGraphQlError = function(error) {
  if ("string" == typeof error) {
    return new GraphQLError(error);
  } else if ("object" == typeof error && error.message) {
    return new GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});
  } else {
    return error;
  }
};

function _toString() {
  return this.message;
}

var CombinedError = function(Error) {
  function CombinedError(ref) {
    var networkError = ref.networkError;
    var response = ref.response;
    var normalizedGraphQLErrors = (ref.graphQLErrors || []).map(rehydrateGraphQlError);
    var message = function(networkErr, graphQlErrs) {
      var error = "";
      if (void 0 !== networkErr) {
        return error = "[Network] " + networkErr.message;
      }
      if (void 0 !== graphQlErrs) {
        graphQlErrs.forEach((function _ref(err) {
          error += "[GraphQL] " + err.message + "\n";
        }));
      }
      return error.trim();
    }(networkError, normalizedGraphQLErrors);
    Error.call(this, message);
    this.name = "CombinedError";
    this.message = message;
    this.graphQLErrors = normalizedGraphQLErrors;
    this.networkError = networkError;
    this.response = response;
  }
  if (Error) {
    CombinedError.__proto__ = Error;
  }
  (CombinedError.prototype = Object.create(Error && Error.prototype)).constructor = CombinedError;
  CombinedError.prototype.toString = _toString;
  return CombinedError;
}(Error);

var phash = function(h, x) {
  h |= 0;
  for (var i = 0, l = 0 | x.length; i < l; i++) {
    h = (h << 5) + h + x.charCodeAt(i);
  }
  return h;
};

var seen = new Set;

var stringify = function(x) {
  if (void 0 === x) {
    return "";
  } else if ("number" == typeof x) {
    return isFinite(x) ? "" + x : "null";
  } else if ("object" != typeof x) {
    return JSON.stringify(x);
  } else if (null === x) {
    return "null";
  } else if (x.toJSON) {
    return x.toJSON();
  }
  var out = "";
  if (Array.isArray(x)) {
    out = "[";
    for (var i = 0, l = x.length; i < l; i++) {
      if (i > 0) {
        out += ",";
      }
      var value = stringify(x[i]);
      out += value.length > 0 ? value : "null";
    }
    return out += "]";
  } else if (seen.has(x)) {
    throw new TypeError("Converting circular structure to JSON");
  }
  var keys = Object.keys(x).sort();
  seen.add(x);
  out = "{";
  for (var i$1 = 0, l$1 = keys.length; i$1 < l$1; i$1++) {
    var key = keys[i$1];
    var value$1 = stringify(x[key]);
    if (0 !== value$1.length) {
      if (out.length > 1) {
        out += ",";
      }
      out += stringify(key) + ":" + value$1;
    }
  }
  seen.delete(x);
  return out += "}";
};

var stringifyVariables = function(x) {
  seen.clear();
  return stringify(x);
};

var hashQuery = function(q) {
  return x = q.replace(/[\s,]+/g, " ").trim(), phash(5381, x) >>> 0;
  var x;
};

var docs = Object.create(null);

var createRequest = function(q, vars) {
  var key;
  var query;
  if ("string" == typeof q) {
    key = hashQuery(q);
    query = void 0 !== docs[key] ? docs[key] : parse(q);
  } else if (void 0 !== q.__key) {
    key = q.__key;
    query = q;
  } else {
    key = hashQuery(print(q));
    query = void 0 !== docs[key] ? docs[key] : q;
  }
  docs[key] = query;
  query.__key = key;
  return {
    key: vars ? phash(key, stringifyVariables(vars)) >>> 0 : key,
    query: query,
    variables: vars || {}
  };
};

var addMetadata = function(source, meta) {
  return _extends(_extends({}, source), {
    context: _extends(_extends({}, source.context), {
      meta: _extends(_extends({}, source.context.meta), meta)
    })
  });
};

var makeResult = function(operation, result, response) {
  return {
    operation: operation,
    data: result.data,
    error: Array.isArray(result.errors) ? new CombinedError({
      graphQLErrors: result.errors,
      response: response
    }) : void 0,
    extensions: "object" == typeof result.extensions && null !== result.extensions ? result.extensions : void 0
  };
};

var makeErrorResult = function(operation, error, response) {
  return {
    operation: operation,
    data: void 0,
    error: new CombinedError({
      networkError: error,
      response: response
    }),
    extensions: void 0
  };
};

var collectTypes = function(obj, types) {
  if (void 0 === types) {
    types = [];
  }
  if (Array.isArray(obj)) {
    obj.forEach((function _ref(inner) {
      collectTypes(inner, types);
    }));
  } else if ("object" == typeof obj && null !== obj) {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var val = obj[key];
        if ("__typename" === key && "string" == typeof val) {
          types.push(val);
        } else if ("object" == typeof val && null !== val) {
          collectTypes(val, types);
        }
      }
    }
  }
  return types;
};

function _ref2(v, i, a) {
  return a.indexOf(v) === i;
}

var collectTypesFromResponse = function(response) {
  return collectTypes(response).filter(_ref2);
};

function _ref3(s) {
  return "Field" === s.kind && "__typename" === s.name.value;
}

var formatNode = function(n) {
  if (void 0 === n.selectionSet) {
    return !1;
  }
  if (n.selectionSet.selections.some(_ref3)) {
    return n;
  }
  return _extends(_extends({}, n), {
    selectionSet: _extends(_extends({}, n.selectionSet), {
      selections: n.selectionSet.selections.concat([ {
        kind: Kind.FIELD,
        name: {
          kind: Kind.NAME,
          value: "__typename"
        }
      } ])
    })
  });
};

var formatDocument = function(astNode) {
  return visit(astNode, {
    Field: formatNode,
    InlineFragment: formatNode
  });
};

var toSuspenseSource = function(source) {
  return function(sink) {
    var shared = share(source);
    var hasResult = !1;
    var hasSuspended = !1;
    onPush((function() {
      return hasResult = !0;
    }))(takeWhile((function() {
      return !hasSuspended;
    }))(shared))(sink);
    if (!hasResult) {
      hasSuspended = !0;
      sink(0);
      throw toPromise(take(1)(shared));
    }
  };
};

function withPromise(source$) {
  source$.toPromise = function() {
    return toPromise(take(1)(source$));
  };
  return source$;
}

export { CombinedError as C, _extends as _, addMetadata as a, makeErrorResult as b, collectTypesFromResponse as c, createRequest as d, formatDocument as f, makeResult as m, stringifyVariables as s, toSuspenseSource as t, withPromise as w };
//# sourceMappingURL=index-9bb95fa6.js.map
