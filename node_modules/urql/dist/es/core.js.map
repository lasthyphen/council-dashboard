{"version":3,"file":"core.js","sources":["../../src/exchanges/ssr.ts","../../src/exchanges/cache.ts","../../src/exchanges/subscription.ts","../../src/exchanges/debug.ts","../../src/exchanges/dedup.ts","../../src/exchanges/fetch.ts","../../src/exchanges/fallback.ts","../../src/exchanges/compose.ts","../../src/exchanges/index.ts","../../src/client.ts"],"sourcesContent":["import { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: any;\n  error?: {\n    networkError?: string;\n    graphQLErrors: string[];\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'subscription' && operationName !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = { data, error: undefined };\n  if (error !== undefined) {\n    result.error = {\n      networkError: '' + error.networkError,\n      graphQLErrors: error.graphQLErrors.map(x => '' + x),\n    };\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data } = result;\n  const deserialized: OperationResult = {\n    operation,\n    data,\n    extensions: undefined,\n    error: undefined,\n  };\n  if (error !== undefined) {\n    deserialized.error = new CombinedError({\n      networkError: new Error(error.networkError),\n      graphQLErrors: error.graphQLErrors,\n    });\n  }\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(\n        cachedOps$,\n        tap((result: OperationResult) => {\n          delete data[result.operation.key];\n        })\n      );\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport {\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'mutation' && operationName !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => ({\n    ...operation,\n    query: formatDocument(operation.query),\n  });\n\n  const handleAfterMutation = afterMutation(\n    resultCache,\n    operationCache,\n    client\n  );\n\n  const handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  const isOperationCached = operation => {\n    const {\n      key,\n      operationName,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      operationName === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      forward,\n      tap(response => {\n        if (\n          response.operation &&\n          response.operation.operationName === 'mutation'\n        ) {\n          handleAfterMutation(response);\n        } else if (\n          response.operation &&\n          response.operation.operationName === 'query'\n        ) {\n          handleAfterQuery(response);\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation({\n    ...operation,\n    context: {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    },\n  });\n};\n\n// Invalidates the cache given a mutation's response\nexport const afterMutation = (\n  resultCache: ResultCache,\n  operationCache: OperationCache,\n  client: Client\n) => (response: OperationResult) => {\n  const pendingOperations = new Set<number>();\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.forEach(key => {\n      pendingOperations.add(key);\n    });\n    operations.clear();\n  });\n\n  pendingOperations.forEach(key => {\n    if (resultCache.has(key)) {\n      const operation = (resultCache.get(key) as OperationResult).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  });\n};\n\n// Mark typenames on typenameInvalidate for early invalidation\nconst afterQuery = (\n  resultCache: ResultCache,\n  operationCache: OperationCache\n) => (response: OperationResult) => {\n  const { operation, data, error } = response;\n\n  if (data === undefined || data === null) {\n    return;\n  }\n\n  resultCache.set(operation.key, { operation, data, error });\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.add(operation.key);\n  });\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: object;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n}\n\nconst isSubscriptionOperation = (operation: Operation) =>\n  operation.operationName === 'subscription';\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n\n      const sub = observableish.subscribe({\n        next: result => next(makeResult(operation, result)),\n        error: err => next(makeErrorResult(operation, err)),\n        complete: () => {\n          if (!isComplete) {\n            client.reexecuteOperation({\n              ...operation,\n              operationName: 'teardown',\n            });\n          }\n\n          complete();\n        },\n      });\n\n      return () => {\n        isComplete = true;\n        sub.unsubscribe();\n      };\n    });\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, operationName } = operation;\n    if (operationName === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    } else if (operationName !== 'query' && operationName !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Kind, DocumentNode, OperationDefinitionNode, print } from 'graphql';\nimport { filter, make, merge, mergeMap, pipe, share, takeUntil } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\n\ninterface Body {\n  query: string;\n  variables: void | object;\n  operationName?: string;\n}\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward }) => {\n  const isOperationFetchable = (operation: Operation) => {\n    const { operationName } = operation;\n    return operationName === 'query' || operationName === 'mutation';\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(isOperationFetchable),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createFetchSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isOperationFetchable(op)),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nconst getOperationName = (query: DocumentNode): string | null => {\n  const node = query.definitions.find(\n    (node: any): node is OperationDefinitionNode => {\n      return node.kind === Kind.OPERATION_DEFINITION && node.name;\n    }\n  );\n\n  return node !== undefined && node.name ? node.name.value : null;\n};\n\nconst createFetchSource = (operation: Operation) => {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    operation.operationName === 'subscription'\n  ) {\n    throw new Error(\n      'Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?'\n    );\n  }\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined'\n        ? new AbortController()\n        : undefined;\n\n    const { context } = operation;\n\n    const extraOptions =\n      typeof context.fetchOptions === 'function'\n        ? context.fetchOptions()\n        : context.fetchOptions || {};\n\n    const operationName = getOperationName(operation.query);\n\n    const body: Body = {\n      query: print(operation.query),\n      variables: operation.variables,\n    };\n\n    if (operationName !== null) {\n      body.operationName = operationName;\n    }\n\n    const fetchOptions = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      ...extraOptions,\n      headers: {\n        'content-type': 'application/json',\n        ...extraOptions.headers,\n      },\n      signal:\n        abortController !== undefined ? abortController.signal : undefined,\n    };\n\n    executeFetch(operation, fetchOptions).then(result => {\n      if (result !== undefined) {\n        next(result);\n      }\n\n      complete();\n    });\n\n    return () => {\n      if (abortController !== undefined) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nconst executeFetch = (operation: Operation, opts: RequestInit) => {\n  const { url, fetch: fetcher } = operation.context;\n\n  let response: Response | undefined;\n\n  return (fetcher || fetch)(url, opts)\n    .then(res => {\n      const { status } = res;\n      const statusRangeEnd = opts.redirect === 'manual' ? 400 : 300;\n      response = res;\n\n      if (status < 200 || status >= statusRangeEnd) {\n        throw new Error(res.statusText);\n      } else {\n        return res.json();\n      }\n    })\n    .then(result => makeResult(operation, result, response))\n    .catch(err => {\n      if (err.name !== 'AbortError') {\n        return makeErrorResult(operation, err, response);\n      }\n    });\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { ExchangeIO, Operation } from '../types';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchangeIO: ExchangeIO = ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(({ operationName }) => {\n      if (\n        operationName !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        console.warn(\n          `No exchange has handled operations of type \"${operationName}\". Check whether you've added an exchange responsible for these operations.`\n        );\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n","import { Exchange } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]): Exchange => {\n  if (exchanges.length === 1) {\n    return exchanges[0];\n  }\n\n  return payload => {\n    return exchanges.reduceRight((forward, exchange) => {\n      return exchange({ client: payload.client, forward });\n    }, payload.forward);\n  };\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","// This is the entrypoint for the urql/client bundle.\n// It'll be output to dist/es/core.js and dist/cjs/core.js\n// This file also contains the main urql Client\nexport * from './exchanges';\nexport * from './types';\n\nexport {\n  CombinedError,\n  stringifyVariables,\n  createRequest,\n  makeResult,\n  makeErrorResult,\n  formatDocument,\n} from './utils';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n} from 'wonka';\n\nimport {\n  composeExchanges,\n  defaultExchanges,\n  fallbackExchangeIO,\n} from './exchanges';\n\nimport {\n  Exchange,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n} from './types';\n\nimport { createRequest, toSuspenseSource, withPromise } from './utils';\nimport { DocumentNode } from 'graphql';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  exchange: Exchange;\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation: Operation) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n\n  constructor(opts: ClientOptions) {\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const { source: operations$, next: nextOperation } = makeSubject<\n      Operation\n    >();\n    this.operations$ = operations$;\n\n    // Internally operations aren't always dispatched immediately\n    // Since exchanges can dispatch and reexecute operations themselves,\n    // if we're inside an exchange we instead queue the operation and flush\n    // them in order after\n    const queuedOperations: Operation[] = [];\n    let isDispatching = false;\n\n    this.dispatchOperation = (operation: Operation) => {\n      queuedOperations.push(operation);\n      if (!isDispatching) {\n        isDispatching = true;\n        let queued;\n        while ((queued = queuedOperations.shift()) !== undefined)\n          nextOperation(queued);\n        isDispatching = false;\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    this.exchange = composeExchanges(exchanges);\n\n    // All operations run through the exchanges in a pipeline-like fashion\n    // and this observable then combines all their results\n    this.results$ = share(\n      this.exchange({\n        client: this,\n        forward: fallbackExchangeIO,\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  private createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => ({\n    url: this.url,\n    fetchOptions: this.fetchOptions,\n    fetch: this.fetch,\n    ...opts,\n    requestPolicy: (opts || {}).requestPolicy || this.requestPolicy,\n  });\n\n  createRequestOperation = (\n    type: OperationType,\n    request: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Operation => ({\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    operationName: type,\n    context: this.createOperationContext(opts),\n  });\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n\n    if (newActive <= 0) {\n      this.dispatchOperation({ ...operation, operationName: 'teardown' });\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation(operation: Operation): Source<OperationResult> {\n    const { key, operationName } = operation;\n    const operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === key)\n    );\n\n    if (operationName === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.operationName === 'teardown' && op.key === key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    return operation.context.suspense !== false &&\n      this.suspense &&\n      operationName === 'query'\n      ? toSuspenseSource<OperationResult>(result$ as Source<OperationResult>)\n      : (result$ as Source<OperationResult>);\n  }\n\n  reexecuteOperation = (operation: Operation) => {\n    // Reexecute operation only if any subscribers are still subscribed to the\n    // operation's exchange results\n    if ((this.activeOperations[operation.key] || 0) > 0) {\n      this.dispatchOperation(operation);\n    }\n  };\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data>>(\n      this.executeQuery(createRequest(query, variables), context)\n    );\n  }\n\n  executeQuery = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    const response$ = this.executeRequestOperation(operation);\n    const { pollInterval } = operation.context;\n\n    if (pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(pollInterval)]),\n        switchMap(() => response$)\n      );\n    }\n\n    return response$;\n  };\n\n  executeSubscription = (\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    return withPromise<OperationResult<Data>>(\n      this.executeMutation(createRequest(query, variables), context)\n    );\n  }\n\n  executeMutation = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n}\n"],"names":["const","shouldSkip","operationName","x","ssrExchange","params","data","isCached","operation","undefined","key","op","result","deserialized","extensions","error","CombinedError","networkError","Error","graphQLErrors","deserializeResult","serialized","map","serializeResult","ssr","ops$","isClient","client","suspense","sharedOps$","share","forwardedOps$","forward","filter","cachedOps$","tap","merge","restoreData","restore","_extends","extractData","initialState","query","formatDocument","addMetadata","cacheOutcome","cacheExchange","resultCache","Map","operationCache","Object","create","mapTypeNames","handleAfterMutation","afterMutation","handleAfterQuery","afterQuery","isOperationCached","requestPolicy","has","cachedResult","get","context","stale","reexecuteOperation","response","delete","pendingOperations","Set","add","collectTypesFromResponse","forEach","typeName","operations","clear","set","isSubscriptionOperation","subscriptionExchange","subscriptionResults$","mergeMap","teardown$","takeUntil","observableish","forwardSubscription","toString","print","variables","make","isComplete","sub","subscribe","next","makeResult","err","makeErrorResult","complete","unsubscribe","createSubscriptionSource","forward$","console","log","debugExchange","process","env","NODE_ENV","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","afterOperationResult","fetchExchange","isOperationFetchable","fetchResults$","createFetchSource","node","kind","Kind","OPERATION_DEFINITION","name","abortController","AbortController","extraOptions","fetchOptions","definitions","find","value","body","JSON","stringify","method","headers","signal","executeFetch","then","abort","opts","fetch","res","status","redirect","statusText","json","catch","warn","fallbackExchangeIO","composeExchanges","exchanges","length","payload","reduceRight","exchange","defaultExchanges","createClient","Client","url","this","type","request","createOperationContext","activeOperations","dispatchOperation","createRequestOperation","response$","executeRequestOperation","pollInterval","switchMap","fromValue","interval","makeSubject","operations$","queuedOperations","isDispatching","push","queued","shift","nextOperation","results$","publish","onOperationStart","onOperationEnd","prevActive","operationResults$","take","onStart","result$","onEnd","toSuspenseSource","withPromise","executeQuery","createRequest","mutation","executeMutation"],"mappings":";;;;;;;;AA4BAA,IAAMC;;SACc,mBAAlBC,iBAAsD,YAAlBA;;;cAWOC;SAAK,KAAKA;;;IA8B1CC,uBAAeC;MACpBC,OAAgB;MAEhBC,oBAAYC;YACRP,WAAWO,mBAAsCC,MAAxBH,KAAKE,UAAUE;;iBAiBvCC;YAAOJ,SAASI;;iBASnBA;oBAnDRH,WACAI;;UAGMC,eAAgC;mBACpCL;;QAEAM,iBAAYL;QACZM,YAAON;;eAEKA,MAAVM;QACFF,aAAaE,QAAQ,IAAIC,cAAc;UACrCC,cAAc,IAAIC,MAAMH,MAAME;UAC9BE,eAAeJ,MAAMI;;;aAIlBN;KAoCMO,CAAkBT,IADNL,KAAKK,GAAGD;;iBAFtBC;WAAMJ,SAASI;;iBAWfC;;SAEEX,WAAWO,YAAY;UACpBa;;YA7EVT,SAA2B;;UAAQG,YAAON;;iBAClCA,MAAVM;UACFH,OAAOG,QAAQ;YACbE,cAAc,KAAKF,MAAME;YACzBE,eAAeJ,MAAMI,cAAcG;;;eAIhCV;OAqEsBW,CAAgBX;MACnCN,KAAKE,UAAUE,OAAOW;;;iBAQrBT;WACIN,KAAKM,OAAOJ,UAAUE;;MA5C/Bc;;;oBAA4CC;UAG1CC,WACJrB,UAAqC,oBAApBA,OAAOqB,aAClBrB,OAAOqB,YACRC,OAAOC;UAERC,aAAaC,MAAML;UAErBM,gBAGFC,QADAC,aAAAA,CADAJ;UAOEK,aAGFZ,UAAAA,CADAW,aAAAA,CADAJ;WAQGH;QAEHK,gBAEEI,UAAAA,CADAJ;;QAWFG,aAEEC,UAAAA,CADAD;;aAOGE,MAAM,EAACL,eAAeG;;;EAG/BV,IAAIa,uBAAeC;WAAqBC,SAAcjC,MAAMgC;;EAC5Dd,IAAIgB;WAAoBD,SAAc,IAAIjC;;MAEtCD,UAAUA,OAAOoC;IACnBjB,IAAIa,YAAYhC,OAAOoC;;SAGlBjB;;;ACzHTxB,IAAMC;;SACc,eAAlBC,iBAAkD,YAAlBA;;;gBAOVM;+BACjBA;IACHkC,OAAOC,eAAenC,UAAUkC;;;;eA4D1B/B;SAAMiC,YAAYjC,IAAI;IAAEkC,cAAc;;;;eAH/BlC;SAAMV,aAAWU;;;IAhErBmC;;;MACLC,cAAc,IAAIC;MAClBC,iBAAiBC,OAAOC,OAAO;MAG/BC;MAKAC,sBAAsBC,cAC1BP,aACAE,gBACAtB;MAGI4B,mBAAmBC,WAAWT,aAAaE;MAE3CQ,6BAAoBjD;;WAOJ,uCACA,mBAAlBkD,kBACmB,iBAAlBA,iBAAkCX,YAAYY;;iBAU3CnD;QACIoD,eAAeb,YAAYc,IAAIrD,UAAUE;QACzCE,+BACDgD;MACHpD,WAAWoC,YAAYpC,WAAW;QAChCqC,cAAce,eAAe,QAAQ;;;QAID,wBAApCpD,UAAUsD,QAAQJ,eAAuC;MAC3D9C,OAAOmD,SAAQ;MACfC,mBAAmBrC,QAAQnB;;WAGtBI;;iBAfFD;YAAOV,aAAWU,OAAO8C,kBAAkB9C;;iBAiC9CsD;QAEAA,SAASzD,aAC4B,eAArCyD,SAASzD,UAAUN;MAEnBmD,oBAAoBY;WACf,IACLA,SAASzD,aAC4B,YAArCyD,SAASzD,UAAUN;MAEnBqD,iBAAiBU;;;iBApBVtD;YAAOV,aAAWU,QAAQ8C,kBAAkB9C;;kBA5BpDc;QACCI,aAAaC,MAAML;QAEnBS,aAGJZ,UAAAA,CADAW,aAAAA,CADAJ;QAoBIE,gBAcJI,UAAAA,CADAH,QADAV,UAAAA,CAXAc,MAAM,EAIFd,IAAI8B,aAAJ9B,CADAW,aAAAA,CADAJ,cAMAI,aAAAA,CADAJ;WAqBCO,MAAM,EAACF,YAAYH;;;;AAK9B/B,IAAMgE,8BAAsBrC,QAAgBnB;SACnCmB,OAAOqC,yCACTxD;IACHsD,+BACKtD,UAAUsD;MACbJ,eAAe;;;;;AAMrB,IAAaJ,yBACXP,aACAE,gBACAtB;iBAa0BjB;QACpBqC,YAAYY,IAAIjD,MAAM;UAClBF,YAAauC,YAAYc,IAAInD,KAAyBF;MAC5DuC,YAAYmB,OAAOxD;MACnBsD,mBAAmBrC,QAAQnB;;;kBAhB3ByD;QACEE,oBAAoB,IAAIC;mBAKT1D;MACjByD,kBAAkBE,IAAI3D;;IAJ1B4D,yBAAyBL,SAAS3D,MAAMiE,kBAAQC;UACxCC,aACJxB,eAAeuB,cAAcvB,eAAeuB,YAAY,IAAIJ;MAC9DK,WAAWF;MAGXE,WAAWC;;IAGbP,kBAAkBI;;;;AAUpBvE,IAAMwD,sBACJT,aACAE;kBACIgB;;;QAGA3D,QAAAA;;;IAIJyC,YAAY4B,IAAInE,UAAUE,KAAK;iBAAEF;YAAWF;;;IAE5CgE,yBAAyBL,SAAS3D,MAAMiE,kBAAQC;OAE5CvB,eAAeuB,cAAcvB,eAAeuB,YAAY,IAAIJ,MACnDC,IAAI7D,UAAUE;;;;;ACzG7BV,IAAM4E,mCAA2BpE;SACH,mBAA5BA,UAAUN;;;gBA2DCS;UAAOiE,wBAAwBjE;;;IAzD/BkE;;;;;oBAuCJpD;UACCI,aAAaC,MAAML;UACnBqD,uBAGJC,mBAASvE;;YAEDwE,YAEJ/C,iBAAOtB;iBAA2B,eAArBA,GAAGT,iBAAgCS,GAAGD,QAAQA;WAA3DuB,CADAJ;eAI+CoD,UAAUD,UAAVC,UA/CrDzE;cAGM0E,gBAAgBC,oBAAoB;YACxCzE,KAAKF,UAAUE,IAAI0E,SAAS;YAC5B1C,OAAO2C,MAAM7E,UAAUkC;YACvB4C,WAAW9E,UAAU8E;YACrBxB,sBAActD,UAAUsD;;iBAGnByB;;;gBACDC,cAAa;gBAEXC,MAAMP,cAAcQ,UAAU;cAClCC,eAAM/E;uBAAU+E,KAAKC,WAAWpF,WAAWI;;cAC3CG,gBAAO8E;uBAAOF,KAAKG,gBAAgBtF,WAAWqF;;cAC9CE;qBACOP;kBACH7D,OAAOqC,yCACFxD;oBACHN,eAAe;;;gBAInB6F;;;;cAKFP,cAAa;cACbC,IAAIO;;;SAiBQC,CAAyBzF;SAPvCuE,CADA9C,OAAO2C,wBAAP3C,CADAJ;UAaIqE,WAGJlE,QADAC,cAAAA,CADAJ;aAKKO,MAAM,EAAC0C,sBAAsBoB;;;;;eC3G5BtF;SAEFuF,QAAQC,IAAI,2CAA2CxF;;;eAJrDD;SAAMwF,QAAQC,IAAI,0CAA0CzF;;;IAR3D0F;;MACkB,iBAAzBC,QAAQC,IAAIC;yBACP/E;aAAQO,QAAQP;;;0BAEhBA;aAMHU,UAAAA,CADAH,QADAG,UAAAA,CAFAV;;;;;ICLKgF;;MACLC,eAAe,IAAItC;MAEnBuC,mCAA2BnG;;;QAET,eAAlBN,eAA8B;MAChCwG,aAAaxC,OAAOxD;cACb;WACF,IAAsB,YAAlBR,iBAA+C,mBAAlBA;cAC/B;;QAGH0G,aAAaF,aAAa/C,IAAIjD;IACpCgG,aAAarC,IAAI3D;YACTkG;;MAGJC;IACJH,aAAaxC,qBAAiBxD;;kBAGzBe;QACCyE,WAAsBjE,OAAO0E,wBAAP1E,CAANR;WACSU,IAAI0E,qBAAJ1E,CAAnBH,QAAQkE;;;;gBCbQ1F;;SAEH,YAAlBN,iBAA+C,eAAlBA;;;IAH3B4G;;MACLC;iBAuBKpG;YAAOoG,qBAAqBpG;;kBAlBhCc;QACCI,aAAaC,MAAML;QACnBuF,gBAGJjC,mBAASvE;;UAEDwE,YAEJ/C,iBAAOtB;eAA2B,eAArBA,GAAGT,iBAAgCS,GAAGD,QAAQA;SAA3DuB,CADAJ;aAIwCoD,UAAUD,UAAVC,CAA9BgC,kBAAkBzG;OAPhCuE,CADA9C,OAAO8E,qBAAP9E,CADAJ;QAaIqE,WAGJlE,QADAC,aAAAA,CADAJ;WAKKO,MAAM,EAAC4E,eAAed;;;;iBAM5BgB;SACQA,KAAKC,SAASC,KAAKC,wBAAwBH,KAAKI;;;AAO7DtH,IAAMiH,6BAAqBzG;MAEE,iBAAzB8F,QAAQC,IAAIC,YACgB,mBAA5BhG,UAAUN;UAEJ,IAAIgB,MACR;;SAIGqE;;;QACCgC,kBACuB,sBAApBC,kBACH,IAAIA,uBACJ/G;;QAIAgH,eAC4B,qBAAzB3D,QAAQ4D,eACX5D,QAAQ4D,iBACR5D,QAAQ4D,gBAAgB;QAExBxH,qBA1BQO,OANVyG,OAgCmC1G,UAAUkC,MAhChCiF,YAAYC,kBAMFV,KAAKI,OAAOJ,KAAKI,KAAKO,QAAQ;QANrDX;QAkCEY,OAAa;MACjBpF,OAAO2C,MAAM7E,UAAUkC;MACvB4C,WAAW9E,UAAU8E;;QAGD,SAAlBpF;MACF4H,KAAK5H,gBAAgBA;;QAGjBwH;MACJI,MAAMC,KAAKC,UAAUF;MACrBG,QAAQ;OACLR;MACHS;wBACkB;SACbT,aAAaS;MAElBC,aACsB1H,MAApB8G,kBAAgCA,gBAAgBY,cAAS1H;;IAG7D2H,aAAa5H,WAAWkH,cAAcW,eAAKzH;eAC1BH,MAAXG;QACF+E,KAAK/E;;MAGPmF;;;eAIwBtF,MAApB8G;QACFA,gBAAgBe;;;;;;AAMxBtI,IAAMoI,wBAAgB5H,WAAsB+H;YACV/H,UAAUsD;MAEtCG;uBAEeuE,gBAAYD,MAC5BF,eAAKI;;IAGJxE,WAAWwE;QAEPC,SAAS,OAAOA,WAHqB,aAAlBH,KAAKI,WAAwB,MAAM;YAIlD,IAAIzH,MAAMuH,IAAIG;;aAEbH,IAAII;;MAGdR,eAAKzH;WAAUgF,WAAWpF,WAAWI,QAAQqD;MAC7C6E,gBAAMjD;QACY,iBAAbA,IAAIyB;aACCxB,gBAAgBtF,WAAWqF,KAAK5B;;;;;;UCvHzB;;;;;MATI,eAAlB/D,iBACyB,iBAAzBoG,QAAQC,IAAIC;IAEZL,QAAQ4C,sDACyC7I;;;;IAT5C8I,8BAAiCvH;SAc1CQ,eAXAE,YAAAA,CADAV;;;ICHSwH,4BAAoBC;MACN,MAArBA,UAAUC;WACLD,UAAU;;kBAGZE;WACEF,UAAUG,sBAAarH,SAASsH;aAC9BA,SAAS;QAAE3H,QAAQyH,QAAQzH;iBAAQK;;QACzCoH,QAAQpH;;;;ICEFuH,mBAAmB,EAAC9C,eAAe3D,eAAegE;;IC4DlD0C,wBAAgBjB;SAAwB,IAAIkB,OAAOlB;;;IAGnDkB,SAeX,gBAAYlB;;0BAFOrF,OAAOC,OAAO;yCAwD/BoF;;MAEAmB,KAAKC,OAAKD;MACVhC,cAAciC,OAAKjC;MACnBc,OAAOmB,OAAKnB;OACTD;MACH7E,gBAAgB6E,QAAQ,IAAI7E,iBAAiBiG,OAAKjG;;;yCAIlDkG,MACAC,SACAtB;WACe;MACf7H,KAAKmJ,QAAQnJ;MACbgC,OAAOmH,QAAQnH;MACf4C,WAAWuE,QAAQvE;MACnBpF,eAAe0J;MACf9F,SAAS6F,OAAKG,uBAAuBvB;;;qCAgEjB/H;SAGfmJ,OAAKI,iBAAiBvJ,UAAUE,QAAQ,KAAK;MAChDiJ,OAAKK,kBAAkBxJ;;;+BAmBzBkC,OACA6F;QAEM/H,YAAYmJ,OAAKM,uBAAuB,SAASvH,OAAO6F;QACxD2B,YAAYP,OAAKQ,wBAAwB3J;uBACtBA,UAAUsD;QAE/BsG;aAGAC;eAAgBH;SAAhBG,CADAjI,MAAM,EAACkI,UAAU,IAAIC,SAASH;;WAK3BF;;sCAIPxH,OACA6F;QAEM/H,YAAYmJ,OAAKM,uBAAuB,gBAAgBvH,OAAO6F;WAC9DoB,OAAKQ,wBAAwB3J;;kCAcpCkC,OACA6F;QAEM/H,YAAYmJ,OAAKM,uBAAuB,YAAYvH,OAAO6F;WAC1DoB,OAAKQ,wBAAwB3J;;OAtM/BkJ,MAAMnB,KAAKmB;OACXhC,eAAea,KAAKb;OACpBc,QAAQD,KAAKC;OACb5G,aAAa2G,KAAK3G;OAClB8B,gBAAgB6E,KAAK7E,iBAAiB;YAIU8G;;OAGhDC;MAMCC,mBAAgC;MAClCC,iBAAgB;OAEfX,6BAAqBxJ;IACxBkK,iBAAiBE,KAAKpK;SACjBmK,eAAe;MAClBA,iBAAgB;UACZE;kBAC2CpK,OAAvCoK,SAASH,iBAAiBI;QAChCC,cAAcF;;MAChBF,iBAAgB;;;OASfrB,WAAWL,sBAJKxI,MAAnB8H,KAAKW,YAA0BX,KAAKW,YAAYK;OAQ7CyB,WAAWlJ,MACd6H,KAAKL,SAAS;IACZ3H,QAAQgI;IACR3H,SAASgH;IAFXW,CAGGA,KAAKc;EAKUQ,QAAftB,KAAKqB;;;iBA0BJE,6CAAiB1K;;OAElBuJ,iBAAiBrJ,QAAQiJ,KAAKI,iBAAiBrJ,QAAQ,KAAK;OAC5DsJ,kBAAkBxJ;;;iBAIjB2K,yCAAe3K;;MAEf4K,aAAazB,KAAKI,iBAAiBrJ,QAAQ;OAC9BiJ,KAAKI,iBAAiBrJ,OACvC0K,cAAc,IAAI,IAAIA,aAAa,MAEpB;SACVpB,wCAAuBxJ;MAAWN,eAAe;;;;;iBAK1DiK,2DAAwB3J;;;;MAEhB6K,oBAEJpJ,iBAAQwG;WAAyBA,IAAIjI,UAAUE,QAAQA;KAAvDuB,CADA0H,KAAKqB;MAIe,eAAlB9K;WAKAoL,KAAK,EAALA,CADAC;aAA+B5B,OAAKK,kBAAkBxJ;OAAtD+K,CADAF;;MAMErG,YAEJ/C,iBACGtB;WAAuC,eAArBA,GAAGT,iBAAgCS,GAAGD,QAAQA;KADnEuB,CADA0H,KAAKc;MAMDe,UAMJC;IACE9B,OAAKwB,eAAe3K;KADtBiL,CAHAF;IACE5B,OAAKuB,iBAAiB1K;KADxB+K,CADAtG,UAAUD,UAAVC,CADAoG;UAUoC,MAA/B7K,UAAUsD,QAAQlC,YACvB+H,KAAK/H,YACa,YAAlB1B,gBACEwL,iBAAkCF,WACjCA;;;iBAWP9I,uBACEA,SACA4C,WACAxB;OAEKA,WAAuC,oBAArBA,QAAQlC;IAC7BkC,gCAAeA;MAASlC,WAAU;;;SAG7B+J,YACLhC,KAAKiC,aAAaC,cAAcnJ,SAAO4C,YAAYxB;;;iBA8BvDgI,6BACEpJ,OACA4C,WACAxB;SAEO6H,YACLhC,KAAKoC,gBAAgBF,cAAcnJ,OAAO4C,YAAYxB;;;"}