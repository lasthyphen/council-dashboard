{"version":3,"file":"urql.js","sources":["../../src/context.ts","../../src/hooks/constants.ts","../../src/hooks/useMutation.ts","../../src/hooks/useRequest.ts","../../src/hooks/useQuery.ts","../../src/hooks/useSubscription.ts","../../src/components/Mutation.ts","../../src/components/Query.ts","../../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from './client';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback } from 'react';\nimport { pipe, toPromise } from 'wonka';\nimport { useClient } from '../context';\nimport { OperationResult, OperationContext } from '../types';\nimport { CombinedError, createRequest } from '../utils';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseMutationResponse<T, V> = [\n  UseMutationState<T>,\n  (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>\n];\n\nexport const useMutation = <T = any, V = object>(\n  query: DocumentNode | string\n): UseMutationResponse<T, V> => {\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<T>>(initialState);\n\n  const executeMutation = useCallback(\n    (variables?: V, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      const request = createRequest(query, variables as any);\n\n      return pipe(\n        client.executeMutation(request, context || {}),\n        toPromise\n      ).then(result => {\n        setState({\n          fetching: false,\n          stale: !!result.stale,\n          data: result.data,\n          error: result.error,\n          extensions: result.extensions,\n        });\n        return result;\n      });\n    },\n    [client, query, setState]\n  );\n\n  return [state, executeMutation];\n};\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLRequest } from '../types';\nimport { createRequest } from '../utils';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport const useRequest = (\n  query: string | DocumentNode,\n  variables?: any\n): GraphQLRequest => {\n  const prev = useRef<undefined | GraphQLRequest>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { useOperator } from 'react-wonka';\n\nimport { useClient } from '../context';\nimport { OperationContext, RequestPolicy } from '../types';\nimport { CombinedError } from '../utils';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<V> {\n  query: string | DocumentNode;\n  variables?: V;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseQueryResponse<T> = [\n  UseQueryState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useQuery = <T = any, V = object>(\n  args: UseQueryArgs<V>\n): UseQueryResponse<T> => {\n  const client = useClient();\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeQuery(request, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval,\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const [state, update] = useOperator(\n    query$$ =>\n      pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result, partial: { fetching: boolean }) => ({\n            ...result,\n            stale: false,\n            ...partial,\n          }),\n          initialState\n        )\n      ),\n    useMemo(() => (args.pause ? null : makeQuery$()), [args.pause, makeQuery$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeQuery$(opts)),\n    [update, makeQuery$]\n  );\n\n  return [state, executeQuery];\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { useOperator } from 'react-wonka';\n\nimport { useClient } from '../context';\nimport { CombinedError } from '../utils';\nimport { OperationContext } from '../types';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<V> {\n  query: DocumentNode | string;\n  variables?: V;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseSubscriptionResponse<T> = [\n  UseSubscriptionState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useSubscription = <T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<V>,\n  handler?: SubscriptionHandler<T, R>\n): UseSubscriptionResponse<R> => {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription(request, { ...args.context, ...opts });\n    },\n    [client, request, args.context]\n  );\n\n  const [state, update] = useOperator(\n    subscription$$ =>\n      pipe(\n        subscription$$,\n        switchMap(subscription$ => {\n          if (!subscription$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true }),\n            pipe(\n              subscription$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan((result, partial: any) => {\n          const { current: handler } = handlerRef;\n          // If a handler has been passed, it's used to merge new data in\n          const data =\n            partial.data !== undefined\n              ? typeof handler === 'function'\n                ? handler(result.data, partial.data)\n                : partial.data\n              : result.data;\n          return { ...result, stale: false, ...partial, data };\n        }, initialState)\n      ),\n    useMemo(() => (args.pause ? null : makeSubscription$()), [\n      args.pause,\n      makeSubscription$,\n    ]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  return [state, executeSubscription];\n};\n","import { ReactElement } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { OperationResult, OperationContext } from '../types';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<T, V> {\n  query: DocumentNode | string;\n  children: (arg: MutationState<T, V>) => ReactElement<any>;\n}\n\nexport interface MutationState<T, V> extends UseMutationState<T> {\n  executeMutation: (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport function Mutation<T = any, V = any>(\n  props: MutationProps<T, V>\n): ReactElement<any> {\n  const [state, executeMutation] = useMutation<T, V>(props.query);\n  return props.children({ ...state, executeMutation });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<T, V> extends UseQueryArgs<V> {\n  children: (arg: QueryState<T>) => ReactElement<any>;\n}\n\nexport interface QueryState<T> extends UseQueryState<T> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<T = any, V = any>(\n  props: QueryProps<T, V>\n): ReactElement<any> {\n  const [state, executeQuery] = useQuery<T, V>(props);\n  return props.children({ ...state, executeQuery });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '../types';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<T, R, V> extends UseSubscriptionArgs<V> {\n  handler?: SubscriptionHandler<T, R>;\n  children: (arg: SubscriptionState<R>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<T> extends UseSubscriptionState<T> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<T = any, R = T, V = any>(\n  props: SubscriptionProps<T, R, V>\n): ReactElement<any> {\n  const [state, executeSubscription] = useSubscription<T, R, V>(\n    props,\n    props.handler\n  );\n  return props.children({ ...state, executeSubscription });\n}\n"],"names":["const","defaultClient","createClient","url","Context","createContext","Provider","Consumer","let","hasWarnedAboutDefault","useClient","client","useContext","process","env","NODE_ENV","console","warn","initialState","fetching","stale","error","undefined","data","extensions","useMutation","query","useState","result","setState","useCallback","variables","context","request","createRequest","toPromise","executeMutation","then","useRequest","prev","useRef","useMemo","current","key","partial","query$","fromValue","concat","map","query$$","scan","switchMap","useQuery","args","makeQuery$","opts","executeQuery","requestPolicy","pollInterval","useOperator","pause","update","subscription$","useSubscription","handler","handlerRef","makeSubscription$","executeSubscription","subscription$$","Mutation","props","children","Query","Subscription"],"mappings":"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"}