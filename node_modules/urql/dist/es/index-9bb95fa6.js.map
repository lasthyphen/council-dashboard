{"version":3,"file":"index-9bb95fa6.js","sources":["../../src/utils/error.ts","../../src/utils/hash.ts","../../src/utils/stringifyVariables.ts","../../src/utils/request.ts","../../src/utils/result.ts","../../src/utils/typenames.ts","../../src/utils/toSuspenseSource.ts","../../src/utils/withPromise.ts"],"sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | GraphQLError | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (h: number, x: string): number => {\n  h = h | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\n// This is a djb2 hashing function\nexport const hash = (x: string): number => phash(5381 | 0, x) >>> 0;\n","const seen = new Set();\n\nconst stringify = (x: any): string => {\n  if (x === undefined) {\n    return '';\n  } else if (typeof x == 'number') {\n    return isFinite(x) ? '' + x : 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x);\n  } else if (x === null) {\n    return 'null';\n  } else if (x.toJSON) {\n    return x.toJSON();\n  }\n\n  let out = '';\n  if (Array.isArray(x)) {\n    out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  } else if (seen.has(x)) {\n    throw new TypeError('Converting circular structure to JSON');\n  }\n\n  const keys = Object.keys(x).sort();\n\n  seen.add(x);\n  out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value.length !== 0) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { DocumentNode, parse, print } from 'graphql';\nimport { hash, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { GraphQLRequest, Operation, OperationContext } from '../types';\n\ninterface Documents {\n  [key: number]: DocumentNode;\n}\n\nconst hashQuery = (q: string): number => hash(q.replace(/[\\s,]+/g, ' ').trim());\n\nconst docs: Documents = Object.create(null);\nconst keyProp = '__key';\n\nexport const createRequest = (\n  q: string | DocumentNode,\n  vars?: object\n): GraphQLRequest => {\n  let key: number;\n  let query: DocumentNode;\n  if (typeof q === 'string') {\n    key = hashQuery(q);\n    query = docs[key] !== undefined ? docs[key] : parse(q);\n  } else if ((q as any)[keyProp] !== undefined) {\n    key = (q as any)[keyProp];\n    query = q;\n  } else {\n    key = hashQuery(print(q));\n    query = docs[key] !== undefined ? docs[key] : q;\n  }\n\n  docs[key] = query;\n  (query as any)[keyProp] = key;\n\n  return {\n    key: vars ? phash(key, stringifyVariables(vars)) >>> 0 : key,\n    query,\n    variables: vars || {},\n  };\n};\n\n/** Spreads the provided metadata to the source operation's meta property in context.  */\nexport const addMetadata = (\n  source: Operation,\n  meta: Exclude<OperationContext['meta'], undefined>\n) => ({\n  ...source,\n  context: {\n    ...source.context,\n    meta: {\n      ...source.context.meta,\n      ...meta,\n    },\n  },\n});\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    typeof result.extensions === 'object' && result.extensions !== null\n      ? result.extensions\n      : undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import {\n  DocumentNode,\n  FieldNode,\n  InlineFragmentNode,\n  Kind,\n  visit,\n} from 'graphql';\n\ninterface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (obj: EntityLike | EntityLike[], types: string[] = []) => {\n  if (Array.isArray(obj)) {\n    obj.forEach(inner => {\n      collectTypes(inner, types);\n    });\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        const val = obj[key];\n        if (key === '__typename' && typeof val === 'string') {\n          types.push(val);\n        } else if (typeof val === 'object' && val !== null) {\n          collectTypes(val, types);\n        }\n      }\n    }\n  }\n\n  return types;\n};\n\nexport const collectTypesFromResponse = (response: object) =>\n  collectTypes(response as EntityLike).filter((v, i, a) => a.indexOf(v) === i);\n\nconst formatNode = (n: FieldNode | InlineFragmentNode) => {\n  if (n.selectionSet === undefined) {\n    return false;\n  }\n\n  if (\n    n.selectionSet.selections.some(\n      s => s.kind === 'Field' && s.name.value === '__typename'\n    )\n  ) {\n    return n;\n  }\n\n  return {\n    ...n,\n    selectionSet: {\n      ...n.selectionSet,\n      selections: [\n        ...n.selectionSet.selections,\n        {\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename',\n          },\n        },\n      ],\n    },\n  };\n};\n\nexport const formatDocument = (astNode: DocumentNode) =>\n  visit(astNode, {\n    Field: formatNode,\n    InlineFragment: formatNode,\n  });\n","import { pipe, share, onPush, toPromise, takeWhile, take, Source } from 'wonka';\n\n/** This converts a Source to a suspense Source; It will forward the first result synchronously or throw a promise that resolves when the result becomes available */\nexport const toSuspenseSource = <T>(source: Source<T>): Source<T> => sink => {\n  const shared = share(source);\n  let hasResult = false;\n  let hasSuspended = false;\n\n  pipe(\n    shared,\n    takeWhile(() => !hasSuspended),\n    onPush(() => (hasResult = true))\n  )(sink);\n\n  if (!hasResult) {\n    hasSuspended = true;\n    sink(0); /* End */\n    throw pipe(shared, take(1), toPromise);\n  }\n};\n","import { Source, pipe, toPromise, take } from 'wonka';\nimport { PromisifiedSource } from '../types';\n\nexport function withPromise<T>(source$: Source<T>): PromisifiedSource<T> {\n  (source$ as PromisifiedSource<T>).toPromise = () =>\n    pipe(\n      source$,\n      take(1),\n      toPromise\n    );\n  return source$ as PromisifiedSource<T>;\n}\n"],"names":["const","rehydrateGraphQlError","error","GraphQLError","message","nodes","source","positions","path","extensions","this","CombinedError","normalizedGraphQLErrors","map","networkErr","graphQlErrs","undefined","forEach","err","trim","generateErrorMessage","networkError","super","name","graphQLErrors","response","toString","Error","phash","h","x","let","i","l","length","charCodeAt","seen","Set","stringify","isFinite","JSON","toJSON","out","Array","isArray","value","has","TypeError","keys","Object","sort","add","key","delete","stringifyVariables","clear","hashQuery","q","replace","docs","create","createRequest","vars","query","parse","print","variables","addMetadata","meta","context","makeResult","operation","result","data","errors","makeErrorResult","collectTypes","obj","types","inner","prototype","hasOwnProperty","call","val","push","v","a","indexOf","collectTypesFromResponse","filter","s","kind","formatNode","n","selectionSet","selections","some","Kind","FIELD","NAME","formatDocument","astNode","visit","Field","InlineFragment","toSuspenseSource","sink","shared","share","hasResult","hasSuspended","onPush","takeWhile","toPromise","take","withPromise","source$"],"mappings":"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"}