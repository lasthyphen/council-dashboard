{"version":3,"file":"core.js","sources":["../../src/exchanges/ssr.ts","../../src/exchanges/cache.ts","../../src/exchanges/subscription.ts","../../src/exchanges/debug.ts","../../src/exchanges/dedup.ts","../../src/exchanges/fetch.ts","../../src/exchanges/fallback.ts","../../src/exchanges/compose.ts","../../src/exchanges/index.ts","../../src/client.ts"],"sourcesContent":["import { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: any;\n  error?: {\n    networkError?: string;\n    graphQLErrors: string[];\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'subscription' && operationName !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = { data, error: undefined };\n  if (error !== undefined) {\n    result.error = {\n      networkError: '' + error.networkError,\n      graphQLErrors: error.graphQLErrors.map(x => '' + x),\n    };\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data } = result;\n  const deserialized: OperationResult = {\n    operation,\n    data,\n    extensions: undefined,\n    error: undefined,\n  };\n  if (error !== undefined) {\n    deserialized.error = new CombinedError({\n      networkError: new Error(error.networkError),\n      graphQLErrors: error.graphQLErrors,\n    });\n  }\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(\n        cachedOps$,\n        tap((result: OperationResult) => {\n          delete data[result.operation.key];\n        })\n      );\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport {\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ operationName }: Operation) =>\n  operationName !== 'mutation' && operationName !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => ({\n    ...operation,\n    query: formatDocument(operation.query),\n  });\n\n  const handleAfterMutation = afterMutation(\n    resultCache,\n    operationCache,\n    client\n  );\n\n  const handleAfterQuery = afterQuery(resultCache, operationCache);\n\n  const isOperationCached = operation => {\n    const {\n      key,\n      operationName,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      operationName === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      forward,\n      tap(response => {\n        if (\n          response.operation &&\n          response.operation.operationName === 'mutation'\n        ) {\n          handleAfterMutation(response);\n        } else if (\n          response.operation &&\n          response.operation.operationName === 'query'\n        ) {\n          handleAfterQuery(response);\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation({\n    ...operation,\n    context: {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    },\n  });\n};\n\n// Invalidates the cache given a mutation's response\nexport const afterMutation = (\n  resultCache: ResultCache,\n  operationCache: OperationCache,\n  client: Client\n) => (response: OperationResult) => {\n  const pendingOperations = new Set<number>();\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.forEach(key => {\n      pendingOperations.add(key);\n    });\n    operations.clear();\n  });\n\n  pendingOperations.forEach(key => {\n    if (resultCache.has(key)) {\n      const operation = (resultCache.get(key) as OperationResult).operation;\n      resultCache.delete(key);\n      reexecuteOperation(client, operation);\n    }\n  });\n};\n\n// Mark typenames on typenameInvalidate for early invalidation\nconst afterQuery = (\n  resultCache: ResultCache,\n  operationCache: OperationCache\n) => (response: OperationResult) => {\n  const { operation, data, error } = response;\n\n  if (data === undefined || data === null) {\n    return;\n  }\n\n  resultCache.set(operation.key, { operation, data, error });\n\n  collectTypesFromResponse(response.data).forEach(typeName => {\n    const operations =\n      operationCache[typeName] || (operationCache[typeName] = new Set());\n    operations.add(operation.key);\n  });\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: object;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n}\n\nconst isSubscriptionOperation = (operation: Operation) =>\n  operation.operationName === 'subscription';\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n\n      const sub = observableish.subscribe({\n        next: result => next(makeResult(operation, result)),\n        error: err => next(makeErrorResult(operation, err)),\n        complete: () => {\n          if (!isComplete) {\n            client.reexecuteOperation({\n              ...operation,\n              operationName: 'teardown',\n            });\n          }\n\n          complete();\n        },\n      });\n\n      return () => {\n        isComplete = true;\n        sub.unsubscribe();\n      };\n    });\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, operationName } = operation;\n    if (operationName === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    } else if (operationName !== 'query' && operationName !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { Kind, DocumentNode, OperationDefinitionNode, print } from 'graphql';\nimport { filter, make, merge, mergeMap, pipe, share, takeUntil } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\n\ninterface Body {\n  query: string;\n  variables: void | object;\n  operationName?: string;\n}\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward }) => {\n  const isOperationFetchable = (operation: Operation) => {\n    const { operationName } = operation;\n    return operationName === 'query' || operationName === 'mutation';\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(isOperationFetchable),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.operationName === 'teardown' && op.key === key)\n        );\n\n        return pipe(createFetchSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isOperationFetchable(op)),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n\nconst getOperationName = (query: DocumentNode): string | null => {\n  const node = query.definitions.find(\n    (node: any): node is OperationDefinitionNode => {\n      return node.kind === Kind.OPERATION_DEFINITION && node.name;\n    }\n  );\n\n  return node !== undefined && node.name ? node.name.value : null;\n};\n\nconst createFetchSource = (operation: Operation) => {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    operation.operationName === 'subscription'\n  ) {\n    throw new Error(\n      'Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?'\n    );\n  }\n\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined'\n        ? new AbortController()\n        : undefined;\n\n    const { context } = operation;\n\n    const extraOptions =\n      typeof context.fetchOptions === 'function'\n        ? context.fetchOptions()\n        : context.fetchOptions || {};\n\n    const operationName = getOperationName(operation.query);\n\n    const body: Body = {\n      query: print(operation.query),\n      variables: operation.variables,\n    };\n\n    if (operationName !== null) {\n      body.operationName = operationName;\n    }\n\n    const fetchOptions = {\n      body: JSON.stringify(body),\n      method: 'POST',\n      ...extraOptions,\n      headers: {\n        'content-type': 'application/json',\n        ...extraOptions.headers,\n      },\n      signal:\n        abortController !== undefined ? abortController.signal : undefined,\n    };\n\n    executeFetch(operation, fetchOptions).then(result => {\n      if (result !== undefined) {\n        next(result);\n      }\n\n      complete();\n    });\n\n    return () => {\n      if (abortController !== undefined) {\n        abortController.abort();\n      }\n    };\n  });\n};\n\nconst executeFetch = (operation: Operation, opts: RequestInit) => {\n  const { url, fetch: fetcher } = operation.context;\n\n  let response: Response | undefined;\n\n  return (fetcher || fetch)(url, opts)\n    .then(res => {\n      const { status } = res;\n      const statusRangeEnd = opts.redirect === 'manual' ? 400 : 300;\n      response = res;\n\n      if (status < 200 || status >= statusRangeEnd) {\n        throw new Error(res.statusText);\n      } else {\n        return res.json();\n      }\n    })\n    .then(result => makeResult(operation, result, response))\n    .catch(err => {\n      if (err.name !== 'AbortError') {\n        return makeErrorResult(operation, err, response);\n      }\n    });\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { ExchangeIO, Operation } from '../types';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchangeIO: ExchangeIO = ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(({ operationName }) => {\n      if (\n        operationName !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        console.warn(\n          `No exchange has handled operations of type \"${operationName}\". Check whether you've added an exchange responsible for these operations.`\n        );\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n","import { Exchange } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]): Exchange => {\n  if (exchanges.length === 1) {\n    return exchanges[0];\n  }\n\n  return payload => {\n    return exchanges.reduceRight((forward, exchange) => {\n      return exchange({ client: payload.client, forward });\n    }, payload.forward);\n  };\n};\n","export { ssrExchange } from './ssr';\nexport { cacheExchange } from './cache';\nexport { subscriptionExchange } from './subscription';\nexport { debugExchange } from './debug';\nexport { dedupExchange } from './dedup';\nexport { fetchExchange } from './fetch';\nexport { fallbackExchangeIO } from './fallback';\nexport { composeExchanges } from './compose';\n\nimport { cacheExchange } from './cache';\nimport { dedupExchange } from './dedup';\nimport { fetchExchange } from './fetch';\n\nexport const defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];\n","// This is the entrypoint for the urql/client bundle.\n// It'll be output to dist/es/core.js and dist/cjs/core.js\n// This file also contains the main urql Client\nexport * from './exchanges';\nexport * from './types';\n\nexport {\n  CombinedError,\n  stringifyVariables,\n  createRequest,\n  makeResult,\n  makeErrorResult,\n  formatDocument,\n} from './utils';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n} from 'wonka';\n\nimport {\n  composeExchanges,\n  defaultExchanges,\n  fallbackExchangeIO,\n} from './exchanges';\n\nimport {\n  Exchange,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n} from './types';\n\nimport { createRequest, toSuspenseSource, withPromise } from './utils';\nimport { DocumentNode } from 'graphql';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  exchange: Exchange;\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation: Operation) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n\n  constructor(opts: ClientOptions) {\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const { source: operations$, next: nextOperation } = makeSubject<\n      Operation\n    >();\n    this.operations$ = operations$;\n\n    // Internally operations aren't always dispatched immediately\n    // Since exchanges can dispatch and reexecute operations themselves,\n    // if we're inside an exchange we instead queue the operation and flush\n    // them in order after\n    const queuedOperations: Operation[] = [];\n    let isDispatching = false;\n\n    this.dispatchOperation = (operation: Operation) => {\n      queuedOperations.push(operation);\n      if (!isDispatching) {\n        isDispatching = true;\n        let queued;\n        while ((queued = queuedOperations.shift()) !== undefined)\n          nextOperation(queued);\n        isDispatching = false;\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    this.exchange = composeExchanges(exchanges);\n\n    // All operations run through the exchanges in a pipeline-like fashion\n    // and this observable then combines all their results\n    this.results$ = share(\n      this.exchange({\n        client: this,\n        forward: fallbackExchangeIO,\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  private createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => ({\n    url: this.url,\n    fetchOptions: this.fetchOptions,\n    fetch: this.fetch,\n    ...opts,\n    requestPolicy: (opts || {}).requestPolicy || this.requestPolicy,\n  });\n\n  createRequestOperation = (\n    type: OperationType,\n    request: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Operation => ({\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    operationName: type,\n    context: this.createOperationContext(opts),\n  });\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n\n    if (newActive <= 0) {\n      this.dispatchOperation({ ...operation, operationName: 'teardown' });\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation(operation: Operation): Source<OperationResult> {\n    const { key, operationName } = operation;\n    const operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === key)\n    );\n\n    if (operationName === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.operationName === 'teardown' && op.key === key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    return operation.context.suspense !== false &&\n      this.suspense &&\n      operationName === 'query'\n      ? toSuspenseSource<OperationResult>(result$ as Source<OperationResult>)\n      : (result$ as Source<OperationResult>);\n  }\n\n  reexecuteOperation = (operation: Operation) => {\n    // Reexecute operation only if any subscribers are still subscribed to the\n    // operation's exchange results\n    if ((this.activeOperations[operation.key] || 0) > 0) {\n      this.dispatchOperation(operation);\n    }\n  };\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data>>(\n      this.executeQuery(createRequest(query, variables), context)\n    );\n  }\n\n  executeQuery = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    const response$ = this.executeRequestOperation(operation);\n    const { pollInterval } = operation.context;\n\n    if (pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(pollInterval)]),\n        switchMap(() => response$)\n      );\n    }\n\n    return response$;\n  };\n\n  executeSubscription = (\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data>> {\n    return withPromise<OperationResult<Data>>(\n      this.executeMutation(createRequest(query, variables), context)\n    );\n  }\n\n  executeMutation = <Data = any>(\n    query: GraphQLRequest,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation(operation);\n  };\n}\n"],"names":["const","shouldSkip","operationName","x","operation","query","formatDocument","op","addMetadata","cacheOutcome","cacheExchange","resultCache","Map","operationCache","Object","create","mapTypeNames","handleAfterMutation","afterMutation","client","handleAfterQuery","afterQuery","isOperationCached","requestPolicy","has","cachedResult","get","key","result","context","stale","reexecuteOperation","response","ops$","sharedOps$","share","cachedOps$","map","filter","forwardedOps$","tap","forward","merge","delete","pendingOperations","Set","add","collectTypesFromResponse","data","forEach","typeName","operations","clear","set","isSubscriptionOperation","console","log","dedupExchange","inFlightKeys","filterIncomingOperation","isInFlight","afterOperationResult","forward$","fetchExchange","isOperationFetchable","fetchResults$","mergeMap","teardown$","takeUntil","createFetchSource","node","kind","Kind","OPERATION_DEFINITION","name","process","env","NODE_ENV","Error","make","abortController","AbortController","undefined","extraOptions","fetchOptions","definitions","find","value","body","print","variables","JSON","stringify","method","headers","signal","executeFetch","then","next","complete","abort","opts","fetch","res","status","redirect","statusText","json","makeResult","catch","err","makeErrorResult","warn","fallbackExchangeIO","composeExchanges","exchanges","length","payload","reduceRight","exchange","defaultExchanges","Client","url","this","type","request","createOperationContext","activeOperations","dispatchOperation","createRequestOperation","response$","executeRequestOperation","pollInterval","switchMap","fromValue","interval","suspense","makeSubject","operations$","queuedOperations","isDispatching","push","queued","shift","nextOperation","results$","publish","onOperationStart","onOperationEnd","prevActive","operationResults$","take","onStart","result$","onEnd","toSuspenseSource","withPromise","executeQuery","createRequest","mutation","executeMutation","params","isCached","deserialized","extensions","error","CombinedError","networkError","graphQLErrors","deserializeResult","serialized","serializeResult","ssr","isClient","restoreData","restore","_extends","extractData","initialState","subscriptionResults$","observableish","forwardSubscription","toString","isComplete","sub","subscribe","unsubscribe","createSubscriptionSource"],"mappings":"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"}