"use strict";

var index = require("./index-dddbd19e.js");

var wonka = require("wonka");

var graphql = require("graphql");

var shouldSkip = function (ref) {
  var operationName = ref.operationName;
  return "subscription" !== operationName && "query" !== operationName;
};

function _ref(x) {
  return "" + x;
}

var shouldSkip$1 = function (ref) {
  var operationName = ref.operationName;
  return "mutation" !== operationName && "query" !== operationName;
};

function _ref$1(operation) {
  return index._extends(index._extends({}, operation), {
    query: index.formatDocument(operation.query)
  });
}

function _ref5(op) {
  return index.addMetadata(op, {
    cacheOutcome: "miss"
  });
}

function _ref7(op) {
  return shouldSkip$1(op);
}

var cacheExchange = function (ref) {
  var forward = ref.forward;
  var client = ref.client;
  var resultCache = new Map();
  var operationCache = Object.create(null);
  var mapTypeNames = _ref$1;
  var handleAfterMutation = afterMutation(resultCache, operationCache, client);
  var handleAfterQuery = afterQuery(resultCache, operationCache);

  var isOperationCached = function (operation) {
    var requestPolicy = operation.context.requestPolicy;
    return "query" === operation.operationName && "network-only" !== requestPolicy && ("cache-only" === requestPolicy || resultCache.has(operation.key));
  };

  function _ref2(operation) {
    var cachedResult = resultCache.get(operation.key);

    var result = index._extends(index._extends({}, cachedResult), {
      operation: index.addMetadata(operation, {
        cacheOutcome: cachedResult ? "hit" : "miss"
      })
    });

    if ("cache-and-network" === operation.context.requestPolicy) {
      result.stale = !0;
      reexecuteOperation(client, operation);
    }

    return result;
  }

  function _ref3(op) {
    return !shouldSkip$1(op) && isOperationCached(op);
  }

  function _ref4(response) {
    if (response.operation && "mutation" === response.operation.operationName) {
      handleAfterMutation(response);
    } else if (response.operation && "query" === response.operation.operationName) {
      handleAfterQuery(response);
    }
  }

  function _ref6(op) {
    return !shouldSkip$1(op) && !isOperationCached(op);
  }

  return function (ops$) {
    var sharedOps$ = wonka.share(ops$);
    var cachedOps$ = wonka.map(_ref2)(wonka.filter(_ref3)(sharedOps$));
    var forwardedOps$ = wonka.tap(_ref4)(forward(wonka.map(_ref5)(wonka.merge([wonka.map(mapTypeNames)(wonka.filter(_ref6)(sharedOps$)), wonka.filter(_ref7)(sharedOps$)]))));
    return wonka.merge([cachedOps$, forwardedOps$]);
  };
};

var reexecuteOperation = function (client, operation) {
  return client.reexecuteOperation(index._extends(index._extends({}, operation), {
    context: index._extends(index._extends({}, operation.context), {
      requestPolicy: "network-only"
    })
  }));
};

var afterMutation = function (resultCache, operationCache, client) {
  function _ref9(key) {
    if (resultCache.has(key)) {
      var operation = resultCache.get(key).operation;
      resultCache.delete(key);
      reexecuteOperation(client, operation);
    }
  }

  return function (response) {
    var pendingOperations = new Set();

    function _ref8(key) {
      pendingOperations.add(key);
    }

    index.collectTypesFromResponse(response.data).forEach(function (typeName) {
      var operations = operationCache[typeName] || (operationCache[typeName] = new Set());
      operations.forEach(_ref8);
      operations.clear();
    });
    pendingOperations.forEach(_ref9);
  };
};

var afterQuery = function (resultCache, operationCache) {
  return function (response) {
    var operation = response.operation;
    var data = response.data;

    if (null == data) {
      return;
    }

    resultCache.set(operation.key, {
      operation: operation,
      data: data,
      error: response.error
    });
    index.collectTypesFromResponse(response.data).forEach(function (typeName) {
      (operationCache[typeName] || (operationCache[typeName] = new Set())).add(operation.key);
    });
  };
};

var isSubscriptionOperation = function (operation) {
  return "subscription" === operation.operationName;
};

function _ref$2(op) {
  return !isSubscriptionOperation(op);
}

function _ref2(result) {
  return console.log("[Exchange debug]: Completed operation: ", result);
}

function _ref3(op) {
  return console.log("[Exchange debug]: Incoming operation: ", op);
}

var dedupExchange = function (ref) {
  var forward = ref.forward;
  var inFlightKeys = new Set();

  var filterIncomingOperation = function (operation) {
    var key = operation.key;
    var operationName = operation.operationName;

    if ("teardown" === operationName) {
      inFlightKeys.delete(key);
      return !0;
    } else if ("query" !== operationName && "subscription" !== operationName) {
      return !0;
    }

    var isInFlight = inFlightKeys.has(key);
    inFlightKeys.add(key);
    return !isInFlight;
  };

  var afterOperationResult = function (ref) {
    inFlightKeys.delete(ref.operation.key);
  };

  return function (ops$) {
    var forward$ = wonka.filter(filterIncomingOperation)(ops$);
    return wonka.tap(afterOperationResult)(forward(forward$));
  };
};

function _ref$3(operation) {
  var operationName = operation.operationName;
  return "query" === operationName || "mutation" === operationName;
}

var fetchExchange = function (ref) {
  var forward = ref.forward;
  var isOperationFetchable = _ref$3;

  function _ref2(op) {
    return !isOperationFetchable(op);
  }

  return function (ops$) {
    var sharedOps$ = wonka.share(ops$);
    var fetchResults$ = wonka.mergeMap(function (operation) {
      var key = operation.key;
      var teardown$ = wonka.filter(function (op) {
        return "teardown" === op.operationName && op.key === key;
      })(sharedOps$);
      return wonka.takeUntil(teardown$)(createFetchSource(operation));
    })(wonka.filter(isOperationFetchable)(sharedOps$));
    var forward$ = forward(wonka.filter(_ref2)(sharedOps$));
    return wonka.merge([fetchResults$, forward$]);
  };
};

function _ref3$1(node) {
  return node.kind === graphql.Kind.OPERATION_DEFINITION && node.name;
}

var createFetchSource = function (operation) {
  if ("production" !== process.env.NODE_ENV && "subscription" === operation.operationName) {
    throw new Error("Received a subscription operation in the httpExchange. You are probably trying to create a subscription. Have you added a subscriptionExchange?");
  }

  return wonka.make(function (ref) {
    var next = ref.next;
    var complete = ref.complete;
    var abortController = "undefined" != typeof AbortController ? new AbortController() : void 0;
    var context = operation.context;
    var extraOptions = "function" == typeof context.fetchOptions ? context.fetchOptions() : context.fetchOptions || {};
    var operationName = void 0 !== (node = operation.query.definitions.find(_ref3$1)) && node.name ? node.name.value : null;
    var node;
    var body = {
      query: graphql.print(operation.query),
      variables: operation.variables
    };

    if (null !== operationName) {
      body.operationName = operationName;
    }

    var fetchOptions = index._extends(index._extends({
      body: JSON.stringify(body),
      method: "POST"
    }, extraOptions), {
      headers: index._extends({
        "content-type": "application/json"
      }, extraOptions.headers),
      signal: void 0 !== abortController ? abortController.signal : void 0
    });

    executeFetch(operation, fetchOptions).then(function (result) {
      if (void 0 !== result) {
        next(result);
      }

      complete();
    });
    return function () {
      if (void 0 !== abortController) {
        abortController.abort();
      }
    };
  });
};

var executeFetch = function (operation, opts) {
  var ref = operation.context;
  var response;
  return (ref.fetch || fetch)(ref.url, opts).then(function (res) {
    var status = res.status;
    response = res;

    if (status < 200 || status >= ("manual" === opts.redirect ? 400 : 300)) {
      throw new Error(res.statusText);
    } else {
      return res.json();
    }
  }).then(function (result) {
    return index.makeResult(operation, result, response);
  }).catch(function (err) {
    if ("AbortError" !== err.name) {
      return index.makeErrorResult(operation, err, response);
    }
  });
};

function _ref$4() {
  return !1;
}

function _ref2$1(ref) {
  var operationName = ref.operationName;

  if ("teardown" !== operationName && "production" !== process.env.NODE_ENV) {
    console.warn('No exchange has handled operations of type "' + operationName + "\". Check whether you've added an exchange responsible for these operations.");
  }
}

var fallbackExchangeIO = function (ops$) {
  return wonka.filter(_ref$4)(wonka.tap(_ref2$1)(ops$));
};

var composeExchanges = function (exchanges) {
  if (1 === exchanges.length) {
    return exchanges[0];
  }

  return function (payload) {
    return exchanges.reduceRight(function (forward, exchange) {
      return exchange({
        client: payload.client,
        forward: forward
      });
    }, payload.forward);
  };
};

var defaultExchanges = [dedupExchange, cacheExchange, fetchExchange];

var Client = function Client(opts) {
  var this$1 = this;
  this.activeOperations = Object.create(null);

  this.createOperationContext = function (opts) {
    return index._extends(index._extends({
      url: this$1.url,
      fetchOptions: this$1.fetchOptions,
      fetch: this$1.fetch
    }, opts), {
      requestPolicy: (opts || {}).requestPolicy || this$1.requestPolicy
    });
  };

  this.createRequestOperation = function (type, request, opts) {
    return {
      key: request.key,
      query: request.query,
      variables: request.variables,
      operationName: type,
      context: this$1.createOperationContext(opts)
    };
  };

  this.reexecuteOperation = function (operation) {
    if ((this$1.activeOperations[operation.key] || 0) > 0) {
      this$1.dispatchOperation(operation);
    }
  };

  this.executeQuery = function (query, opts) {
    var operation = this$1.createRequestOperation("query", query, opts);
    var response$ = this$1.executeRequestOperation(operation);
    var pollInterval = operation.context.pollInterval;

    if (pollInterval) {
      return wonka.switchMap(function _ref() {
        return response$;
      })(wonka.merge([wonka.fromValue(0), wonka.interval(pollInterval)]));
    }

    return response$;
  };

  this.executeSubscription = function (query, opts) {
    var operation = this$1.createRequestOperation("subscription", query, opts);
    return this$1.executeRequestOperation(operation);
  };

  this.executeMutation = function (query, opts) {
    var operation = this$1.createRequestOperation("mutation", query, opts);
    return this$1.executeRequestOperation(operation);
  };

  this.url = opts.url;
  this.fetchOptions = opts.fetchOptions;
  this.fetch = opts.fetch;
  this.suspense = !!opts.suspense;
  this.requestPolicy = opts.requestPolicy || "cache-first";
  var ref = wonka.makeSubject();
  var nextOperation = ref.next;
  this.operations$ = ref.source;
  var queuedOperations = [];
  var isDispatching = !1;

  this.dispatchOperation = function (operation) {
    queuedOperations.push(operation);

    if (!isDispatching) {
      isDispatching = !0;
      var queued;

      while (void 0 !== (queued = queuedOperations.shift())) {
        nextOperation(queued);
      }

      isDispatching = !1;
    }
  };

  this.exchange = composeExchanges(void 0 !== opts.exchanges ? opts.exchanges : defaultExchanges);
  this.results$ = wonka.share(this.exchange({
    client: this,
    forward: fallbackExchangeIO
  })(this.operations$));
  wonka.publish(this.results$);
};

Client.prototype.onOperationStart = function onOperationStart(operation) {
  var key = operation.key;
  this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;
  this.dispatchOperation(operation);
};

Client.prototype.onOperationEnd = function onOperationEnd(operation) {
  var key = operation.key;
  var prevActive = this.activeOperations[key] || 0;

  if ((this.activeOperations[key] = prevActive <= 0 ? 0 : prevActive - 1) <= 0) {
    this.dispatchOperation(index._extends(index._extends({}, operation), {
      operationName: "teardown"
    }));
  }
};

Client.prototype.executeRequestOperation = function executeRequestOperation(operation) {
  var this$1 = this;
  var key = operation.key;
  var operationName = operation.operationName;
  var operationResults$ = wonka.filter(function (res) {
    return res.operation.key === key;
  })(this.results$);

  if ("mutation" === operationName) {
    return wonka.take(1)(wonka.onStart(function _ref2() {
      return this$1.dispatchOperation(operation);
    })(operationResults$));
  }

  var teardown$ = wonka.filter(function (op) {
    return "teardown" === op.operationName && op.key === key;
  })(this.operations$);
  var result$ = wonka.onEnd(function () {
    this$1.onOperationEnd(operation);
  })(wonka.onStart(function () {
    this$1.onOperationStart(operation);
  })(wonka.takeUntil(teardown$)(operationResults$)));
  return !1 !== operation.context.suspense && this.suspense && "query" === operationName ? index.toSuspenseSource(result$) : result$;
};

Client.prototype.query = function query(query$1, variables, context) {
  if (!context || "boolean" != typeof context.suspense) {
    context = index._extends(index._extends({}, context), {
      suspense: !1
    });
  }

  return index.withPromise(this.executeQuery(index.createRequest(query$1, variables), context));
};

Client.prototype.mutation = function mutation(query, variables, context) {
  return index.withPromise(this.executeMutation(index.createRequest(query, variables), context));
};

exports.CombinedError = index.CombinedError;
exports.createRequest = index.createRequest;
exports.formatDocument = index.formatDocument;
exports.makeErrorResult = index.makeErrorResult;
exports.makeResult = index.makeResult;
exports.stringifyVariables = index.stringifyVariables;
exports.Client = Client;
exports.cacheExchange = cacheExchange;
exports.composeExchanges = composeExchanges;

exports.createClient = function (opts) {
  return new Client(opts);
};

exports.debugExchange = function (ref) {
  var forward = ref.forward;

  if ("production" === process.env.NODE_ENV) {
    return function _ref(ops$) {
      return forward(ops$);
    };
  } else {
    return function _ref4(ops$) {
      return wonka.tap(_ref2)(forward(wonka.tap(_ref3)(ops$)));
    };
  }
};

exports.dedupExchange = dedupExchange;
exports.defaultExchanges = defaultExchanges;
exports.fallbackExchangeIO = fallbackExchangeIO;
exports.fetchExchange = fetchExchange;

exports.ssrExchange = function (params) {
  var data = {};

  var isCached = function (operation) {
    return !shouldSkip(operation) && void 0 !== data[operation.key];
  };

  function _ref2(op) {
    return !isCached(op);
  }

  function _ref3(op) {
    return function (operation, result) {
      var error = result.error;
      var deserialized = {
        operation: operation,
        data: result.data,
        extensions: void 0,
        error: void 0
      };

      if (void 0 !== error) {
        deserialized.error = new index.CombinedError({
          networkError: new Error(error.networkError),
          graphQLErrors: error.graphQLErrors
        });
      }

      return deserialized;
    }(op, data[op.key]);
  }

  function _ref4(op) {
    return isCached(op);
  }

  function _ref5(result) {
    var operation = result.operation;

    if (!shouldSkip(operation)) {
      var serialized = function (ref) {
        var error = ref.error;
        var result = {
          data: ref.data,
          error: void 0
        };

        if (void 0 !== error) {
          result.error = {
            networkError: "" + error.networkError,
            graphQLErrors: error.graphQLErrors.map(_ref)
          };
        }

        return result;
      }(result);

      data[operation.key] = serialized;
    }
  }

  function _ref6(result) {
    delete data[result.operation.key];
  }

  var ssr = function (ref) {
    var client = ref.client;
    var forward = ref.forward;
    return function (ops$) {
      var isClient = params && "boolean" == typeof params.isClient ? !!params.isClient : !client.suspense;
      var sharedOps$ = wonka.share(ops$);
      var forwardedOps$ = forward(wonka.filter(_ref2)(sharedOps$));
      var cachedOps$ = wonka.map(_ref3)(wonka.filter(_ref4)(sharedOps$));

      if (!isClient) {
        forwardedOps$ = wonka.tap(_ref5)(forwardedOps$);
      } else {
        cachedOps$ = wonka.tap(_ref6)(cachedOps$);
      }

      return wonka.merge([forwardedOps$, cachedOps$]);
    };
  };

  ssr.restoreData = function (restore) {
    return index._extends(data, restore);
  };

  ssr.extractData = function () {
    return index._extends({}, data);
  };

  if (params && params.initialState) {
    ssr.restoreData(params.initialState);
  }

  return ssr;
};

exports.subscriptionExchange = function (ref) {
  var forwardSubscription = ref.forwardSubscription;
  return function (ref) {
    var client = ref.client;
    var forward = ref.forward;
    return function (ops$) {
      var sharedOps$ = wonka.share(ops$);
      var subscriptionResults$ = wonka.mergeMap(function (operation) {
        var key = operation.key;
        var teardown$ = wonka.filter(function (op) {
          return "teardown" === op.operationName && op.key === key;
        })(sharedOps$);
        return wonka.takeUntil(teardown$)(function (operation) {
          var observableish = forwardSubscription({
            key: operation.key.toString(36),
            query: graphql.print(operation.query),
            variables: operation.variables,
            context: index._extends({}, operation.context)
          });
          return wonka.make(function (ref) {
            var next = ref.next;
            var complete = ref.complete;
            var isComplete = !1;
            var sub = observableish.subscribe({
              next: function (result) {
                return next(index.makeResult(operation, result));
              },
              error: function (err) {
                return next(index.makeErrorResult(operation, err));
              },
              complete: function () {
                if (!isComplete) {
                  client.reexecuteOperation(index._extends(index._extends({}, operation), {
                    operationName: "teardown"
                  }));
                }

                complete();
              }
            });
            return function () {
              isComplete = !0;
              sub.unsubscribe();
            };
          });
        }(operation));
      })(wonka.filter(isSubscriptionOperation)(sharedOps$));
      var forward$ = forward(wonka.filter(_ref$2)(sharedOps$));
      return wonka.merge([subscriptionResults$, forward$]);
    };
  };
};