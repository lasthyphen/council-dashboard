"use strict";

var index = require("./index-dddbd19e.js");

var wonka = require("wonka");

var core = require("./core.js");

var react = require("react");

var reactWonka = require("react-wonka");

var defaultClient = core.createClient({
  url: "/graphql"
});
var Context = react.createContext(defaultClient);
var Provider = Context.Provider;
var Consumer = Context.Consumer;
var hasWarnedAboutDefault = !1;

var useClient = function () {
  var client = react.useContext(Context);

  if ("production" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = !0;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }

  return client;
};

var initialState = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0
};

var useMutation = function (query) {
  var client = useClient();
  var ref = react.useState(initialState);
  var setState = ref[1];

  function _ref(result) {
    setState({
      fetching: !1,
      stale: !!result.stale,
      data: result.data,
      error: result.error,
      extensions: result.extensions
    });
    return result;
  }

  return [ref[0], react.useCallback(function (variables, context) {
    setState(index._extends(index._extends({}, initialState), {
      fetching: !0
    }));
    var request = index.createRequest(query, variables);
    return wonka.toPromise(client.executeMutation(request, context || {})).then(_ref);
  }, [client, query, setState])];
};

var useRequest = function (query, variables) {
  var prev = react.useRef(void 0);
  return react.useMemo(function () {
    var request = index.createRequest(query, variables);

    if (void 0 !== prev.current && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }, [query, variables]);
};

function _ref(result, partial) {
  return index._extends(index._extends(index._extends({}, result), {
    stale: !1
  }), partial);
}

function _ref2(ref) {
  return {
    fetching: !1,
    stale: !!ref.stale,
    data: ref.data,
    error: ref.error,
    extensions: ref.extensions
  };
}

function _ref3(query$) {
  if (!query$) {
    return wonka.fromValue({
      fetching: !1
    });
  }

  return wonka.concat([wonka.fromValue({
    fetching: !0
  }), wonka.map(_ref2)(query$), wonka.fromValue({
    fetching: !1
  })]);
}

function _ref4(query$$) {
  return wonka.scan(_ref, initialState)(wonka.switchMap(_ref3)(query$$));
}

var useQuery = function (args) {
  var client = useClient();
  var request = useRequest(args.query, args.variables);
  var makeQuery$ = react.useCallback(function (opts) {
    return client.executeQuery(request, index._extends(index._extends({
      requestPolicy: args.requestPolicy,
      pollInterval: args.pollInterval
    }, args.context), opts));
  }, [client, request, args.requestPolicy, args.pollInterval, args.context]);
  var ref = reactWonka.useOperator(_ref4, react.useMemo(function () {
    return args.pause ? null : makeQuery$();
  }, [args.pause, makeQuery$]), initialState);
  var update = ref[1];
  return [ref[0], react.useCallback(function (opts) {
    return update(makeQuery$(opts));
  }, [update, makeQuery$])];
};

function _ref2$1(ref) {
  return {
    fetching: !0,
    stale: !!ref.stale,
    data: ref.data,
    error: ref.error,
    extensions: ref.extensions
  };
}

function _ref3$1(subscription$) {
  if (!subscription$) {
    return wonka.fromValue({
      fetching: !1
    });
  }

  return wonka.concat([wonka.fromValue({
    fetching: !0
  }), wonka.map(_ref2$1)(subscription$), wonka.fromValue({
    fetching: !1
  })]);
}

var useSubscription = function (args, handler) {
  var client = useClient();
  var handlerRef = react.useRef(handler);
  handlerRef.current = handler;
  var request = useRequest(args.query, args.variables);
  var makeSubscription$ = react.useCallback(function (opts) {
    return client.executeSubscription(request, index._extends(index._extends({}, args.context), opts));
  }, [client, request, args.context]);

  function _ref(result, partial) {
    var handler = handlerRef.current;
    var data = void 0 !== partial.data ? "function" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;
    return index._extends(index._extends(index._extends(index._extends({}, result), {
      stale: !1
    }), partial), {
      data: data
    });
  }

  var ref = reactWonka.useOperator(function (subscription$$) {
    return wonka.scan(_ref, initialState)(wonka.switchMap(_ref3$1)(subscription$$));
  }, react.useMemo(function () {
    return args.pause ? null : makeSubscription$();
  }, [args.pause, makeSubscription$]), initialState);
  var update = ref[1];
  return [ref[0], react.useCallback(function (opts) {
    return update(makeSubscription$(opts));
  }, [update, makeSubscription$])];
};

exports.CombinedError = index.CombinedError;
exports.createRequest = index.createRequest;
exports.formatDocument = index.formatDocument;
exports.makeErrorResult = index.makeErrorResult;
exports.makeResult = index.makeResult;
exports.stringifyVariables = index.stringifyVariables;
exports.Client = core.Client;
exports.cacheExchange = core.cacheExchange;
exports.composeExchanges = core.composeExchanges;
exports.createClient = core.createClient;
exports.debugExchange = core.debugExchange;
exports.dedupExchange = core.dedupExchange;
exports.defaultExchanges = core.defaultExchanges;
exports.fallbackExchangeIO = core.fallbackExchangeIO;
exports.fetchExchange = core.fetchExchange;
exports.ssrExchange = core.ssrExchange;
exports.subscriptionExchange = core.subscriptionExchange;
exports.Consumer = Consumer;
exports.Context = Context;

exports.Mutation = function Mutation(props) {
  var ref = useMutation(props.query);
  var executeMutation = ref[1];
  return props.children(index._extends(index._extends({}, ref[0]), {
    executeMutation: executeMutation
  }));
};

exports.Provider = Provider;

exports.Query = function Query(props) {
  var ref = useQuery(props);
  var executeQuery = ref[1];
  return props.children(index._extends(index._extends({}, ref[0]), {
    executeQuery: executeQuery
  }));
};

exports.Subscription = function Subscription(props) {
  var ref = useSubscription(props, props.handler);
  var executeSubscription = ref[1];
  return props.children(index._extends(index._extends({}, ref[0]), {
    executeSubscription: executeSubscription
  }));
};

exports.useClient = useClient;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;