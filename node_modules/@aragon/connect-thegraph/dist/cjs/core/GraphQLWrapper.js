"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _client, _pollInterval, _verbose;
Object.defineProperty(exports, "__esModule", { value: true });
const isomorphic_unfetch_1 = __importDefault(require("isomorphic-unfetch"));
const core_1 = require("@urql/core");
const wonka_1 = require("wonka");
// Average block time is about 13 seconds on the 2020-08-14
// See https://etherscan.io/chart/blocktime
const POLL_INTERVAL_DEFAULT = 13 * 1000;
function createRequest(query, args) {
    // Make every operation type a query, until GraphQL subscriptions get added again.
    if (query.definitions) {
        query = {
            ...query,
            definitions: query.definitions.map((definition) => ({
                ...definition,
                operation: 'query',
            })),
        };
    }
    return core_1.createRequest(query, args);
}
class GraphQLWrapper {
    constructor(subgraphUrl, options = {}) {
        var _a, _b;
        _client.set(this, void 0);
        _pollInterval.set(this, void 0);
        _verbose.set(this, void 0);
        if (typeof options === 'boolean') {
            console.warn('GraphQLWrapper: please use `new GraphQLWrapper(url, { verbose })` rather than `new GraphQLWrapper(url, verbose)`.');
            options = { verbose: options };
        }
        options = options;
        __classPrivateFieldSet(this, _verbose, (_a = options.verbose) !== null && _a !== void 0 ? _a : false);
        __classPrivateFieldSet(this, _pollInterval, (_b = options.pollInterval) !== null && _b !== void 0 ? _b : POLL_INTERVAL_DEFAULT);
        __classPrivateFieldSet(this, _client, new core_1.Client({ maskTypename: true, url: subgraphUrl, fetch: isomorphic_unfetch_1.default }));
    }
    close() {
        // Do nothing for now.
        // Will be used when GraphQL subscriptions will be added again.
    }
    subscribeToQuery(query, args = {}, callback) {
        const request = createRequest(query, args);
        return wonka_1.pipe(__classPrivateFieldGet(this, _client).executeQuery(request, {
            pollInterval: __classPrivateFieldGet(this, _pollInterval),
            requestPolicy: 'cache-and-network',
        }), wonka_1.subscribe((result) => {
            if (__classPrivateFieldGet(this, _verbose)) {
                console.log(this.describeQueryResult(result));
            }
            if (result.error) {
                throw new Error([
                    'Error performing subscription.',
                    `${result.error.name}: ${result.error.message}`,
                    this.describeQueryResult(result),
                ].join('\n'));
            }
            callback(result);
        }));
    }
    subscribeToQueryWithParser(query, args = {}, callback, parser) {
        return this.subscribeToQuery(query, args, async (result) => {
            callback(await this.parseQueryResult(parser, result));
        });
    }
    async performQuery(query, args = {}) {
        const result = await __classPrivateFieldGet(this, _client).query(query, args).toPromise();
        if (__classPrivateFieldGet(this, _verbose)) {
            console.log(this.describeQueryResult(result));
        }
        if (result.error) {
            throw new Error(this.describeQueryResultError(result) + this.describeQueryResult(result));
        }
        return result;
    }
    async performQueryWithParser(query, args = {}, parser) {
        const result = await this.performQuery(query, args);
        return this.parseQueryResult(parser, result);
    }
    async parseQueryResult(parser, result) {
        try {
            return parser(result);
        }
        catch (error) {
            throw new Error(error.message + '\n\n' + this.describeQueryResult(result));
        }
    }
    describeQueryResultError(result) {
        if (!result.error) {
            return '';
        }
        return `${result.error.name}: ${result.error.message}\n\n`;
    }
    describeQueryResult(result) {
        var _a;
        const queryStr = (_a = result.operation.query.loc) === null || _a === void 0 ? void 0 : _a.source.body;
        const dataStr = JSON.stringify(result.data, null, 2);
        const argsStr = JSON.stringify(result.operation.variables, null, 2);
        const subgraphUrl = result.operation.context.url;
        return [
            `Subgraph: ${subgraphUrl}`,
            `Arguments: ${argsStr}`,
            `Query: ${queryStr}`,
            `Returned data: ${dataStr}`,
        ].join('\n\n');
    }
}
exports.default = GraphQLWrapper;
_client = new WeakMap(), _pollInterval = new WeakMap(), _verbose = new WeakMap();
//# sourceMappingURL=GraphQLWrapper.js.map